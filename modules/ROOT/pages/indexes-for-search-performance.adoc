:description: This section explains how to manage indexes used for search performance.

[[administration-indexes-search-performance]]
= Indexes for search performance

[abstract]
--
This section explains how to manage indexes used for search performance.
--

For query performance purposes, it is important to also understand how the indexes are used by the Cypher planner.
Refer to xref::query-tuning/index.adoc[] for examples and in-depth discussions on how query plans result from different index and query scenarios.
See specifically xref::query-tuning/indexes.adoc[The use of indexes] for examples of how various index scenarios result in different query plans.

For information on index configuration and limitations, refer to link:{neo4j-docs-base-uri}/operations-manual/{page-version}/performance/index-configuration[Operations Manual -> Index configuration].


[[administration-indexes-types]]
== Indexes (types and limitations)

A database index is a redundant copy of some of the data in the database for the purpose of making searches of related data more efficient.
This comes at the cost of additional storage space and slower writes, so deciding what to index and what not to index is an important and often non-trivial task.

Once an index has been created, it will be managed and kept up to date by the DBMS.
Neo4j will automatically pick up and start using the index once it has been created and brought online.

There are multiple index types available:

* Range index.
* Lookup index.
* Text index.
* Point index.
* Full-text index.

// The BTREE index type was replaced in 5.0 by more specific index types (RANGE, POINT, and TEXT).
// RANGE is now the default index type for CREATE INDEX.

See xref::indexes-for-full-text-search.adoc[Full-text search index] for more information about full-text indexes.
Lookup indexes contain nodes with one or more labels or relationship types, without regard for any properties.

Cypher enables the creation of range indexes on one or more properties for all nodes or relationships with a given label or relationship type:

* An index created on a single property for any given label or relationship type is called a _single-property index_.
* An index created on more than one property for any given label or relationship type is called a _composite index_.

Differences in the usage patterns between composite and single-property indexes are described in xref::indexes-for-search-performance.adoc#administration-indexes-single-vs-composite-index[].

Additionally, text and point indexes are a kind of single-property indexes, with the limitation that they only recognize properties with string and point values, respectively.
Nodes or relationships with the indexed label or relationship type where the indexed property is of another value type are not included in the index.

The following is true for indexes:

* Best practice is to give the index a name when it is created.
If the index is not explicitly named, it gets an auto-generated name.
* The index name must be unique among both indexes and constraints.
* Index creation is by default not idempotent, and an error will be thrown if you attempt to create the same index twice.
Using the keyword `IF NOT EXISTS` makes the command idempotent, and no error will be thrown if you attempt to create the same index twice.


[[administration-indexes-syntax]]
== Syntax

[IMPORTANT]
====
The index name must be unique among both indexes and constraints.
====

[NOTE]
====
Best practice is to give the index a name when it is created.
If the index is not explicitly named, it gets an auto-generated name.
====

[NOTE]
====
The `+CREATE ... INDEX ...+` command is optionally idempotent. This mean that its default behavior is to throw an error if an attempt is made to create the same index twice.
With `IF NOT EXISTS`, no error is thrown and nothing happens should an index with the same name or same schema and index type already exist.
It may still throw an error if conflicting constraints exist, such as constraints with the same name or schema and backing index type.
====


.+Create a range index on nodes+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
CREATE [RANGE] INDEX [index_name] [IF NOT EXISTS]
FOR (n:LabelName)
ON (n.propertyName_1[,
    n.propertyName_2,
    ...
    n.propertyName_n])
[OPTIONS "{" option: value[, ...] "}"]
----

| Description
|
Create a range index on nodes, either on a single property or composite.

Index provider can be specified using the `OPTIONS` clause.

|===


.+Create a range index on relationships+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
CREATE [RANGE] INDEX [index_name] [IF NOT EXISTS]
FOR ()-"["r:TYPE_NAME"]"-()
ON (r.propertyName_1[,
    r.propertyName_2,
    ...
    r.propertyName_n])
[OPTIONS "{" option: value[, ...] "}"]
----

| Description
|
Create a range index on relationships, either on a single property or composite.

Index provider can be specified using the `OPTIONS` clause.

|===


.+Create a node label lookup index+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
CREATE LOOKUP INDEX [index_name] [IF NOT EXISTS]
FOR (n)
ON EACH labels(n)
[OPTIONS "{" option: value[, ...] "}"]
----

| Description
|
Create a node label lookup index.

Index provider can be specified using the `OPTIONS` clause.

|===


.+Create a relationship type lookup index+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
CREATE LOOKUP INDEX [index_name] [IF NOT EXISTS]
FOR ()-"["r"]"-()
ON [EACH] type(r)
[OPTIONS "{" option: value[, ...] "}"]
----

| Description
|
Create a relationship type lookup index.

Index provider can be specified using the `OPTIONS` clause.

|===


.+Create a text index on nodes+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
CREATE TEXT INDEX [index_name] [IF NOT EXISTS]
FOR (n:LabelName)
ON (n.propertyName)
[OPTIONS "{" option: value[, ...] "}"]
----

| Description
|
Create a text index on nodes where the property has a string value.

Index provider can be specified using the `OPTIONS` clause.

|===


.+Create a text index on relationships+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
CREATE TEXT INDEX [index_name] [IF NOT EXISTS]
FOR ()-"["r:TYPE_NAME"]"-()
ON (r.propertyName)
[OPTIONS "{" option: value[, ...] "}"]
----

| Description
|
Create a text index on relationships where the property has a string value.

Index provider can be specified using the `OPTIONS` clause.

|===


.+Create a point index on nodes+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
CREATE POINT INDEX [index_name] [IF NOT EXISTS]
FOR (n:LabelName)
ON (n.propertyName)
[OPTIONS "{" option: value[, ...] "}"]
----

| Description
|
Create a point index on nodes where the property has a point value.

Index provider and configuration can be specified using the `OPTIONS` clause.

|===


.+Create a point index on relationships+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
CREATE POINT INDEX [index_name] [IF NOT EXISTS]
FOR ()-"["r:TYPE_NAME"]"-()
ON (r.propertyName)
[OPTIONS "{" option: value[, ...] "}"]
----

| Description
|
Create a point index on relationships where the property has a point value.

Index provider and configuration can be specified using the `OPTIONS` clause.

|===


.+Drop an index+
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
DROP INDEX index_name [IF EXISTS]
----

| Description
| Drop an index of any index type.

| Note
|
The command is optionally idempotent. This means that its default behavior is to throw an error if an attempt is made to drop the same index twice.
With `IF EXISTS`, no error is thrown and nothing happens should the index not exist.

|===

.List indexes
[options="noheader", width="100%", cols="2, 8a"]
|===

| Syntax
|
[source, syntax, role="noheader"]
----
SHOW [ALL \| FULLTEXT \| LOOKUP \| POINT \| RANGE \| TEXT] INDEX[ES]
  [YIELD { * \| field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]
  [WHERE expression]
  [RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]]
----

| Description
| List indexes in the database, either all or filtered on index type.

| Note
| When using the `RETURN` clause, the `YIELD` clause is mandatory and must not be omitted.

|===


Creating an index requires xref::access-control/database-administration.adoc#access-control-database-administration-index[the `CREATE INDEX` privilege],
while dropping an index requires xref::access-control/database-administration.adoc#access-control-database-administration-index[the `DROP INDEX` privilege] and
listing indexes require xref::access-control/database-administration.adoc#access-control-database-administration-index[the `SHOW INDEX` privilege].

xref::query-tuning/using.adoc[Planner hints and the USING keyword] describes how to make the Cypher planner use specific indexes (especially in cases where the planner would not necessarily have used them).


[[administration-indexes-single-vs-composite-index]]
== Composite index limitations

Like single-property range indexes, composite range indexes support all predicates:

* equality check: `n.prop = value`
* list membership check: `n.prop IN list`
* existence check: `n.prop IS NOT NULL`
* range search: `n.prop > value`
* prefix search: `STARTS WITH`

[NOTE]
====
For details about each operator, see xref::syntax/operators.adoc[Operators].
====

However, predicates might be planned as existence check and a filter.
For most predicates, this can be avoided by following these restrictions:

* If there is any `equality check` and `list membership check` predicates,
they need to be for the first properties defined by the index.
* There can be up to one `range search` or `prefix search` predicate.
* There can be any number of `existence check` predicates.
* Any predicate after a `range search`, `prefix search` or `existence check` predicate has to be an `existence check` predicate.

[NOTE]
====
The `suffix search` (`ENDS WITH`) and `substring search` (`CONTAINS`) predicates can utilize the index as well.
However, they are always planned as an existence check and a filter and any predicates following after will therefore also be planned as such.
====

For example, an index on nodes with `:Label(prop1,prop2,prop3,prop4,prop5,prop6)` and predicates:

[source, cypher, role=noplay, indent=0]
----
WHERE n.prop1 = 'x' AND n.prop2 = 1 AND n.prop3 > 5 AND n.prop4 < 'e' AND n.prop5 = true AND n.prop6 IS NOT NULL
----

will be planned as:

[source, cypher, role=noplay, indent=0]
----
WHERE n.prop1 = 'x' AND n.prop2 = 1 AND n.prop3 > 5 AND n.prop4 IS NOT NULL AND n.prop5 IS NOT NULL AND n.prop6 IS NOT NULL
----

with filters on `n.prop4 < 'e'` and `n.prop5 = true`, since `n.prop3` has a `range search` predicate.

And an index on nodes with `:Label(prop1,prop2)` with predicates:

[source, cypher, role=noplay, indent=0]
----
WHERE n.prop1 ENDS WITH 'x' AND n.prop2 = false
----

will be planned as:

[source, cypher, role=noplay, indent=0]
----
WHERE n.prop1 IS NOT NULL AND n.prop2 IS NOT NULL
----

with filters on `n.prop1 ENDS WITH 'x'` and `n.prop2 = false`, since `n.prop1` has a `suffix search` predicate.

Composite indexes require predicates on all properties indexed.
If there are predicates on only a subset of the indexed properties, it will not be possible to use the composite index.
To get this kind of fallback behavior, it is necessary to create additional indexes on the relevant sub-set of properties or on single properties.


[[administration-indexes-examples]]
== +CREATE INDEX+

*Examples:*

* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-single-property-range-index-for-nodes[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-single-property-range-index-for-relationships[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-range-index-only-if-it-does-not-already-exist[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-range-index-specifying-the-index-provider[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-composite-range-index-for-nodes[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-composite-range-index-for-relationships[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-node-label-lookup-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-relationship-type-lookup-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-token-lookup-index-specifying-the-index-provider[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-node-point-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-relationship-point-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-point-index-only-if-it-does-not-already-exist[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-point-index-specifying-the-index-provider[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-point-index-specifying-the-index-configuration[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-point-index-specifying-both-the-index-provider-and-configuration[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-node-text-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-relationship-text-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-text-index-only-if-it-does-not-already-exist[]
* xref::indexes-for-search-performance.adoc#administration-indexes-create-a-text-index-specifying-the-index-provider[]
* xref::indexes-for-search-performance.adoc#administration-indexes-failure-to-create-an-already-existing-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-failure-to-create-an-index-with-the-same-name-as-an-already-existing-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-failure-to-create-an-index-when-a-constraint-already-exists[]
* xref::indexes-for-search-performance.adoc#administration-indexes-failure-to-create-an-index-with-the-same-name-as-an-already-existing-constraint[]


[discrete]
[[administration-indexes-create-a-single-property-range-index-for-nodes]]
=== Create a single-property range index for nodes

A named range index on a single property for all nodes with a particular label can be created with:

[source, syntax, role="noheader"]
----
CREATE INDEX index_name FOR (n:Label) ON (n.property)
----

Note that the index is not immediately available, but is created in the background.


.+CREATE INDEX+
======

////
CREATE (_0:`Person` {`age`:35, `country`:"UK", `firstname`:"John", `highScore`:54321, `middlename`:"Ron", `name`:"john", `surname`:"Smith"})
CREATE (_1:`Person` {`age`:40, `country`:"Sweden", `firstname`:"Andy", `highScore`:12345, `middlename`:"Mark", `name`:"andy", `surname`:"Jones"})
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX node_range_index_name FOR (n:Person) ON (n.surname)
----

[NOTE]
====
The index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======


[discrete]
[[administration-indexes-create-a-single-property-range-index-for-relationships]]
=== Create a single-property range index for relationships

A named range index on a single property for all relationships with a particular relationship type can be created with:

[source, syntax, role="noheader"]
----
CREATE INDEX index_name FOR ()-[r:TYPE]-() ON (r.property)
----

Note that the index is not immediately available, but is created in the background.


.+CREATE INDEX+
======

////
CREATE (_0:`Person` {`age`:35, `country`:"UK", `firstname`:"John", `highScore`:54321, `middlename`:"Ron", `name`:"john", `surname`:"Smith"})
CREATE (_1:`Person` {`age`:40, `country`:"Sweden", `firstname`:"Andy", `highScore`:12345, `middlename`:"Mark", `name`:"andy", `surname`:"Jones"})
CREATE (_0)-[:`KNOWS` {`lastMet`:2021, `lastMetIn`:"Stockholm", `metIn`:"Malmo", `since`:1992}]->(_1)
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX rel_range_index_name FOR ()-[r:KNOWS]-() ON (r.since)
----

[NOTE]
====
The index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======


[discrete]
[[administration-indexes-create-a-range-index-only-if-it-does-not-already-exist]]
=== Create a range index only if it does not already exist

If it is not known whether an index exists or not, add `IF NOT EXISTS` to ensure it does.


.+CREATE RANGE INDEX+
======

////
CREATE RANGE index `node_range_index_name` for (n:`Person`) ON (n.`surname`)

CREATE (_0:`Person` {`age`:35, `country`:"UK", `firstname`:"John", `highScore`:54321, `middlename`:"Ron", `name`:"john", `surname`:"Smith"})
CREATE (_1:`Person` {`age`:40, `country`:"Sweden", `firstname`:"Andy", `highScore`:12345, `middlename`:"Mark", `name`:"andy", `surname`:"Jones"})
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX node_range_index_name IF NOT EXISTS
FOR (n:Person) ON (n.surname)
----

[NOTE]
====
The index will not be created if there already exists an index with the same schema and type, same name or both.
====

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-indexes-create-a-range-index-specifying-the-index-provider]]
=== Create a range index specifying the index provider

To create a range index with a specific index provider, the `OPTIONS` clause is used.
Only one valid value exists for the index provider, `range-1.0`, which is the default value.


.+CREATE INDEX+
======

.Query
[source, cypher, indent=0]
----
CREATE INDEX range_index_with_provider
FOR ()-[r:TYPE]-() ON (r.prop1)
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

There is no supported index configuration for range indexes.


[discrete]
[[administration-indexes-create-a-composite-range-index-for-nodes]]
=== Create a composite range index for nodes

A named range index on multiple properties for all nodes with a particular label -- i.e. a composite index -- can be created with:

[source, syntax, role="noheader"]
----
CREATE INDEX index_name FOR (n:Label) ON (n.prop1, ..., n.propN)
----

Only nodes with the specified label and that contain all the properties in the index definition will be added to the index.
Note that the composite index is not immediately available, but is created in the background.


.+CREATE INDEX+
======

The following statement will create a named composite range index on all nodes labeled with `Person` and which have both an `age` and `country` property:

////
CREATE (_0:`Person` {`age`:35, `country`:"UK", `firstname`:"John", `highScore`:54321, `middlename`:"Ron", `name`:"john", `surname`:"Smith"})
CREATE (_1:`Person` {`age`:40, `country`:"Sweden", `firstname`:"Andy", `highScore`:12345, `middlename`:"Mark", `name`:"andy", `surname`:"Jones"})
----
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX composite_range_node_index_name FOR (n:Person) ON (n.age, n.country)
----

[NOTE]
====
The index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======


[discrete]
[[administration-indexes-create-a-composite-range-index-for-relationships]]
=== Create a composite range index for relationships

A named range index on multiple properties for all relationships with a particular relationship type -- i.e. a composite index -- can be created with:

[source, syntax, role="noheader"]
----
CREATE INDEX index_name FOR ()-[r:TYPE]-() ON (r.prop1, ..., r.propN)
----

Only relationships with the specified type and that contain all the properties in the index definition will be added to the index.
Note that the composite index is not immediately available, but is created in the background.


.+CREATE INDEX+
======

The following statement will create a named composite range index on all relationships labeled with `PURCHASED` and which have both a `date` and `amount` property:

////
CREATE (_0:`Person` {`age`:35, `country`:"UK", `firstname`:"John", `highScore`:54321, `middlename`:"Ron", `name`:"john", `surname`:"Smith"})
CREATE (_1:`Person` {`age`:40, `country`:"Sweden", `firstname`:"Andy", `highScore`:12345, `middlename`:"Mark", `name`:"andy", `surname`:"Jones"})
CREATE (_1)-[:`KNOWS`]->(_0)
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX composite_range_rel_index_name FOR ()-[r:PURCHASED]-() ON (r.date, r.amount)
----

[NOTE]
====
The index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======


[discrete]
[[administration-indexes-create-a-node-label-lookup-index]]
=== Create a node label lookup index

A named node label lookup index for all nodes with one or more labels can be created with:

[source, syntax, role="noheader"]
----
CREATE LOOKUP INDEX index_name FOR (n) ON EACH labels(n)
----

[NOTE]
====
The index is not immediately available, but is created in the background.
====


.+CREATE LOOKUP INDEX+
======

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')
////

.Query
[source, cypher, indent=0]
----
CREATE LOOKUP INDEX node_label_lookup_index FOR (n) ON EACH labels(n)
----

[NOTE]
====
Note that a node label lookup index can only be created once and that the index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

[NOTE]
====
Only one node label lookup index can exist at the time.
====

[discrete]
[[administration-indexes-create-a-relationship-type-lookup-index]]
=== Create a relationship type lookup index

A named relationship type lookup index for all relationships with any relationship type can be created with:

[source, syntax, role="noheader"]
----
CREATE LOOKUP INDEX index_name FOR ()-[r]-() ON EACH type(r)
----

[NOTE]
====
The index is not immediately available, but is created in the background.
====

.+CREATE LOOKUP INDEX+
======

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')
CREATE (n0)-[TYPE1]->(n1)
CREATE (n0)-[TYPE2]->(n2)
////

.Query
[source, cypher, indent=0]
----
CREATE LOOKUP INDEX rel_type_lookup_index FOR ()-[r]-() ON EACH type(r)
----

[NOTE]
====
Note that a relationship type lookup index can only be created once and that the index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

[NOTE]
====
Only one relationship type lookup index can exist at the time.
====

// do we want an IF NOT EXISTS example for LOOKUP indexes?

[discrete]
[[administration-indexes-create-a-token-lookup-index-specifying-the-index-provider]]
=== Create a token lookup index specifying the index provider

Token lookup indexes (node label and relationship type lookup indexes) allow setting the index provider using the `OPTIONS` clause.
Only one valid value exists for the index provider, `token-lookup-1.0`, which is the default value.

// Cypher only has the keyword LOOKUP why is the option named `token-lookup` ???
// -> the name `token-lookup` came from kernel but wasn't added as part of the cypher commands,
//    because there is currently only one type of lookup indexes which are token lookup ones.
//    The name `token` is a collective word for both node label and relationship type,
//    hence the `node label lookup index` and `relationship type lookup index` variations above.

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')
////


.+CREATE LOOKUP INDEX+
======

.Query
[source, cypher, indent=0]
----
CREATE LOOKUP INDEX node_label_lookup_index_2 FOR (n) ON EACH labels(n)
OPTIONS {indexProvider: 'token-lookup-1.0'}
----

[NOTE]
====
Note that the above command will fail if any node label lookup index already exists.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

There is no supported index configuration for token lookup indexes.


[discrete]
[[administration-indexes-create-a-node-point-index]]
=== Create a node point index

A named point index on a single property for all nodes with a particular label can be created with:

[source, syntax, role="noheader"]
----
CREATE POINT INDEX index_name FOR (n:Label) ON (n.property)
----

Note that the index is not immediately available, but is created in the background.


.+CREATE POINT INDEX+
======

.Query
[source, cypher, indent=0]
----
CREATE POINT INDEX node_index_name FOR (n:Person) ON (n.sublocation)
----

[NOTE]
====
The index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

[NOTE]
====
Note that point indexes only recognize point values and do not support multiple properties.
====

[discrete]
[[administration-indexes-create-a-relationship-point-index]]
=== Create a relationship point index

A named point index on a single property for all relationships with a particular relationship type can be created with:

[source, syntax, role="noheader"]
----
CREATE POINT INDEX index_name FOR ()-[r:TYPE]-() ON (r.property)
----

Note that the index is not immediately available, but is created in the background.


.+CREATE POINT INDEX+
======

.Query
[source, cypher, indent=0]
----
CREATE POINT INDEX rel_index_name FOR ()-[r:STREET]-() ON (r.intersection)
----

[NOTE]
====
The index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

[NOTE]
====
Note that point indexes only recognize point values and do not support multiple properties.
====

[[administration-indexes-create-a-point-index-only-if-it-does-not-already-exist]]
=== Create a point index only if it does not already exist

If it is not known whether an index exists or not, add `IF NOT EXISTS` to ensure it does.


.+CREATE POINT INDEX+
======

////
CREATE POINT index for (n:`Person`) ON (n.`sublocation`)
////

.Query
[source, cypher, indent=0]
----
CREATE POINT INDEX node_index_name IF NOT EXISTS
FOR (n:Person) ON (n.sublocation)
----

[NOTE]
====
Note that the index will not be created if there already exists an index with the same schema and type, same name or both.
====

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-indexes-create-a-point-index-specifying-the-index-provider]]
=== Create a point index specifying the index provider

To create a point index with a specific index provider, the `OPTIONS` clause is used.
Only one valid value exists for the index provider, `point-1.0`, which is the default value.

.+CREATE POINT INDEX+
======

.Query
[source, cypher, indent=0]
----
CREATE POINT INDEX index_with_provider
FOR (n:Label) ON (n.prop1)
OPTIONS {
  indexProvider: 'point-1.0'
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

Specifying the index provider can be combined with specifying index configuration.


[discrete]
[[administration-indexes-create-a-point-index-specifying-the-index-configuration]]
=== Create a point index specifying the index configuration

To create a point index with a specific index configuration, the `OPTIONS` clause is used.

The valid configuration settings are:

* `spatial.cartesian.min`
* `spatial.cartesian.max`
* `spatial.cartesian-3d.min`
* `spatial.cartesian-3d.max`
* `spatial.wgs-84.min`
* `spatial.wgs-84.max`
* `spatial.wgs-84-3d.min`
* `spatial.wgs-84-3d.max`

Non-specified settings have their respective default values.


.+CREATE POINT INDEX+
======

.Query
[source, cypher, indent=0]
----
CREATE POINT INDEX index_with_config
FOR (n:Label) ON (n.prop2)
OPTIONS {
  indexConfig: {
    `spatial.cartesian.min`: [-100.0, -100.0],
    `spatial.cartesian.max`: [100.0, 100.0]
  }
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

Specifying the index configuration can be combined with specifying index provider.


[discrete]
[[administration-indexes-create-a-point-index-specifying-both-the-index-provider-and-configuration]]
=== Create a point index specifying both the index provider and configuration

To create a point index with a specific index provider and configuration, the `OPTIONS` clause is used.
Only one valid value exists for the index provider, `point-1.0`, which is the default value.

The valid configuration settings are:

* `spatial.cartesian.min`
* `spatial.cartesian.max`
* `spatial.cartesian-3d.min`
* `spatial.cartesian-3d.max`
* `spatial.wgs-84.min`
* `spatial.wgs-84.max`
* `spatial.wgs-84-3d.min`
* `spatial.wgs-84-3d.max`

Non-specified settings have their respective default values.

.+CREATE POINT INDEX+
======

.Query
[source, cypher, indent=0]
----
CREATE POINT INDEX index_with_options
FOR ()-[r:TYPE]-() ON (r.prop1)
OPTIONS {
 indexProvider: 'point-1.0',
 indexConfig: {
   `spatial.wgs-84.min`: [-100.0, -80.0],
   `spatial.wgs-84.max`: [100.0, 80.0]
  }
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

Index provider and configuration can also be specified separately.


[discrete]
[[administration-indexes-create-a-node-text-index]]
=== Create a node text index

A named text index on a single property for all nodes with a particular label can be created with:

[source, syntax, role="noheader"]
----
CREATE TEXT INDEX index_name FOR (n:Label) ON (n.property)
----

[NOTE]
====
The index is not immediately available, but is created in the background.
====

.+CREATE TEXT INDEX+
======

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')
////

.Query
[source, cypher, indent=0]
----
CREATE TEXT INDEX node_index_name FOR (n:Person) ON (n.nickname)
----

[NOTE]
====
The index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

[NOTE]
====
Text indexes only recognize string values and do not support multiple properties.
====

[discrete]
[[administration-indexes-create-a-relationship-text-index]]
=== Create a relationship text index

A named text index on a single property for all relationships with a particular relationship type can be created with:

[source, syntax, role="noheader"]
----
CREATE TEXT INDEX index_name FOR ()-[r:TYPE]-() ON (r.property)
----

[NOTE]
====
The index is not immediately available, but is created in the background.
====

.+CREATE TEXT INDEX+
======

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')
CREATE (n0)-[:KNOWS {interest: 'tennis'}]->(n1)
////

.Query
[source, cypher, indent=0]
----
CREATE TEXT INDEX rel_index_name FOR ()-[r:KNOWS]-() ON (r.interest)
----

[NOTE]
====
The index name must be unique.
====

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

[NOTE]
====
Note that text indexes only recognize string values and do not support multiple properties.
====

[discrete]
[[administration-indexes-create-a-text-index-only-if-it-does-not-already-exist]]
=== Create a text index only if it does not already exist

If it is not known whether an index exists or not, add `IF NOT EXISTS` to ensure it does.


.+CREATE TEXT INDEX+
======

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')

CREATE TEXT INDEX node_index_name IF NOT EXISTS FOR (n:Person) ON (n.name)
////

.Query
[source, cypher, indent=0]
----
CREATE TEXT INDEX node_index_name IF NOT EXISTS FOR (n:Person) ON (n.nickname)
----

[NOTE]
====
Note that the index will not be created if there already exists an index with the same schema and type, same name or both.
====

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-indexes-create-a-text-index-specifying-the-index-provider]]
=== Create a text index specifying the index provider

To create a text index with a specific index provider, the `OPTIONS` clause is used.
The valid values for the index provider are `text-2.0` and `text-1.0` (deprecated). The default provider is `text-2.0`.

.+CREATE TEXT INDEX+
======

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')
CREATE (n0)-[:TYPE1 {prop1: 'tennis'}]->(n1)
////

.Query
[source, cypher, indent=0]
----
CREATE TEXT INDEX index_with_provider FOR ()-[r:TYPE]-() ON (r.prop1)
OPTIONS {indexProvider: 'text-1.0'}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes added: 1
----

======

There is no supported index configuration for text indexes.

[discrete]
[[administration-indexes-failure-to-create-an-already-existing-index]]
=== Failure to create an already existing index

Create an index on the property `title` on nodes with the `Book` label, when that index already exists.

.+CREATE RANGE INDEX+
======

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')

CREATE INDEX example_index FOR (n:Book) ON (n.title)
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX bookTitleIndex FOR (book:Book) ON (book.title)
----

In this case the index can not be created because it already exists.

.Error message
[source, role=nocopy, indent=0]
----
There already exists an index (:Book {title}).
----

======


[discrete]
[[administration-indexes-failure-to-create-an-index-with-the-same-name-as-an-already-existing-index]]
=== Failure to create an index with the same name as an already existing index

Create a named index on the property `numberOfPages` on nodes with the `Book` label, when an index with the given name already exists.


.+CREATE RANGE INDEX+
======

////
CREATE (n0:Label1:Label2 {prop1: 3, prop2: 'Green')
CREATE (n1:Label1:Label3 {prop1: 5, prop2: 'Pink')
CREATE (n2:Label1 {prop1: 7, prop2: 'Blue')

CREATE INDEX indexOnBooks FOR (n:Label1) ON (b.prop1)
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX indexOnBooks FOR (book:Book) ON (book.numberOfPages)
----

In this case the index can't be created because there already exists an index with the given name.

.Error message
[source, role=nocopy, indent=0]
----
There already exists an index called 'indexOnBooks'.
----

======


[discrete]
[[administration-indexes-failure-to-create-an-index-when-a-constraint-already-exists]]
=== Failure to create an index when a constraint already exists

Create an index on the property `isbn` on nodes with the `Book` label, when an index-backed constraint already exists on that schema.


.+CREATE RANGE INDEX+
======

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE (book.isbn) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX bookIsbnIndex FOR (book:Book) ON (book.isbn)
----

In this case the index can not be created because a index-backed constraint already exists on that label and property combination.

.Error message
[source, role=nocopy, indent=0]
----
There is a uniqueness constraint on (:Book {isbn}), so an index is already created that matches this.
----

======


[discrete]
[[administration-indexes-failure-to-create-an-index-with-the-same-name-as-an-already-existing-constraint]]
=== Failure to create an index with the same name as an already existing constraint

Create a named index on the property `numberOfPages` on nodes with the `Book` label, when a constraint with the given name already exists.


.+CREATE RANGE INDEX+
======

////
CREATE CONSTRAINT bookRecommendations FOR (book:Book) REQUIRE (book.recommend) IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE INDEX bookRecommendations FOR (book:Book) ON (book.recommendations)
----

In this case the index can not be created because there already exists a constraint with the given name.

.Error message
[source, role=nocopy, indent=0]
----
There already exists a constraint called 'bookRecommendations'.
----

======


[[administration-indexes-list-indexes]]
== +SHOW INDEXES+

Listing indexes can be done with `SHOW INDEXES`, which will produce a table with the following columns:

.List indexes output
[options="header", cols="4,6"]
|===
| Column | Description

| `id`
| The id of the index. label:default-output[]

| `name`
| Name of the index (explicitly set by the user or automatically assigned). label:default-output[]

| `state`
| Current state of the index. label:default-output[]

| `populationPercent`
| % of index population. label:default-output[]

| `type`
| The IndexType of this index (`FULLTEXT`, `LOOKUP`, `POINT`, `RANGE`, or `TEXT`). label:default-output[]

// New in 5.0
| `owningConstraint`
| The name of the constraint the index is associated with or `null`, in case it is not associated with any constraint. label:default-output[]

| `entityType`
| Type of entities this index represents (nodes or relationship). label:default-output[]

| `labelsOrTypes`
| The labels or relationship types of this index. label:default-output[]

| `properties`
| The properties of this index. label:default-output[]

| `indexProvider`
| The index provider for this index. label:default-output[]

| `options`
| The options passed to `CREATE` command.

| `failureMessage`
| The failure description of a failed index.

| `createStatement`
| Statement used to create the index.

|===

[NOTE]
====
The command `SHOW INDEXES` returns only the default output.
For a full output use the optional `YIELD` command.
Full output: `+SHOW INDEXES YIELD *+`.
====

Listing indexes also allows for `WHERE` and `YIELD` clauses to filter the returned rows and columns.


== +SHOW INDEXES+

*Examples:*

* xref::indexes-for-search-performance.adoc#administration-indexes-listing-all-indexes[]
* xref::indexes-for-search-performance.adoc#administration-indexes-listing-indexes-with-filtering[]


[discrete]
[[administration-indexes-listing-all-indexes]]
=== Listing all indexes

To list all indexes with the default output columns, the `SHOW INDEXES` command can be used.
If all columns are required, use `SHOW INDEXES YIELD *`.


.+SHOW INDEXES+
======

////
CREATE RANGE INDEX `index_664b28a2` for (n:`Person`) ON (n.`middlename`);
CREATE RANGE INDEX `index_58a1c03e` for (n:`Person`) ON (n.`location`);
CREATE RANGE INDEX `index_8a688dca` for (n:`Person`) ON (n.`highScore`);
CREATE RANGE INDEX `index_b87724c3` for (n:`Person`) ON (n.`firstname`);
CREATE TEXT INDEX `index_763f72db` for (n:`Person`) ON (n.`middlename`);
CREATE TEXT INDEX `index_eadb868e` for (n:`Person`) ON (n.`surname`);
CREATE POINT INDEX `index_c3493fe4` for (n:`Person`) ON (n.`location`);
CREATE CONSTRAINT `constraint_1bc95fcb` for (n:`Person`) require (n.`name`) is unique;
////

.Query
[source, cypher, indent=0]
----
SHOW INDEXES
----

One of the output columns from `SHOW INDEXES` is the name of the index.
This can be used to drop the index with the xref::indexes-for-search-performance.adoc#administration-indexes-drop-an-index[`DROP INDEX` command].

// SHOW INDEXES default outputs
// 4.4: id, name, state, populationPercent, uniqueness, type, entityType, labelsOrTypes, properties, indexProvider
// 5.0: id, name, state, populationPercent, type, entityType, labelsOrTypes, properties, indexProvider, owningConstraint

.Result
[queryresult]
----
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| id | name                  | state    | populationPercent | type     | entityType     | labelsOrTypes | properties     | indexProvider      | owningConstraint      |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 10 | "constraint_1bc95fcb" | "ONLINE" | 100.0             | "RANGE"  | "NODE"         | ["Person"]    | ["name"]       | "range-1.0"        | "constraint_1bc95fcb" |
| 4  | "index_58a1c03e"      | "ONLINE" | 100.0             | "RANGE"  | "NODE"         | ["Person"]    | ["location"]   | "point-1.0"        | <null>                |
| 3  | "index_664b28a2"      | "ONLINE" | 100.0             | "RANGE"  | "NODE"         | ["Person"]    | ["middlename"] | "range-1.0"        | <null>                |
| 7  | "index_763f72db"      | "ONLINE" | 100.0             | "TEXT"   | "NODE"         | ["Person"]    | ["middlename"] | "text-1.0"         | <null>                |
| 5  | "index_8a688dca"      | "ONLINE" | 100.0             | "RANGE"  | "NODE"         | ["Person"]    | ["highScore"]  | "range-1.0"        | <null>                |
| 6  | "index_b87724c3"      | "ONLINE" | 100.0             | "RANGE"  | "NODE"         | ["Person"]    | ["firstname"]  | "range-1.0"        | <null>                |
| 9  | "index_c3493fe4"      | "ONLINE" | 100.0             | "POINT"  | "NODE"         | ["Person"]    | ["location"]   | "point-1.0"        | <null>                |
| 1  | "index_d7c12ba3"      | "ONLINE" | 100.0             | "LOOKUP" | "NODE"         | <null>        | <null>         | "token-lookup-1.0" | <null>                |
| 2  | "index_deeafdb2"      | "ONLINE" | 100.0             | "LOOKUP" | "RELATIONSHIP" | <null>        | <null>         | "token-lookup-1.0" | <null>                |
| 8  | "index_eadb868e"      | "ONLINE" | 100.0             | "TEXT"   | "NODE"         | ["Person"]    | ["surname"]    | "text-1.0"         | <null>                |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
7 rows
----

======


[discrete]
[[administration-indexes-listing-indexes-with-filtering]]
=== Listing indexes with filtering

One way of filtering the output from `SHOW INDEXES` by index type is the use of type keywords, listed in the xref::indexes-for-search-performance.adoc#administration-indexes-syntax[syntax table].

For example, to show only range indexes, use `SHOW RANGE INDEXES`.

Another more flexible way of filtering the output is to use the `WHERE` clause.
An example is to only show indexes not belonging to constraints.


.+SHOW RANGE INDEXES+
======

////
CREATE RANGE INDEX `index_664b28a2` for (n:`Person`) ON (n.`middlename`);
CREATE RANGE INDEX `index_8a688dca` for (n:`Person`) ON (n.`highScore`);
CREATE RANGE INDEX `index_b87724c3` for (n:`Person`) ON (n.`firstname`);
CREATE RANGE INDEX `index_6e62c571` for ()-[r:`KNOWS`]-() ON (r.`since`);
CREATE CONSTRAINT `constraint_1bc95fcb` for (n:`Person`) require (n.`name`) is unique;
CREATE TEXT INDEX `index_763f72db` for (n:`Person`) ON (n.`middlename`);
CREATE TEXT INDEX `index_eadb868e` for (n:`Person`) ON (n.`surname`);
////

.Query
[source, cypher, indent=0]
----
SHOW RANGE INDEXES WHERE owningConstraint IS NULL
----

This will only return the default output columns.

To get all columns, use:

[source, syntax, role="noheader"]
----
SHOW INDEXES YIELD * WHERE ...
----

.Result
[queryresult]
----
+-----------------------------------------------------------------------------------------------------------------------------------------------------+
| id | name             | state    | populationPercent | type    | entityType     | labelsOrTypes | properties     | indexProvider | owningConstraint |
+-----------------------------------------------------------------------------------------------------------------------------------------------------+
| 3  | "index_664b28a2" | "ONLINE" | 100.0             | "RANGE" | "NODE"         | ["Person"]    | ["middlename"] | "range-1.0"   | <null>           |
| 6  | "index_6e62c571" | "ONLINE" | 100.0             | "RANGE" | "RELATIONSHIP" | ["KNOWS"]     | ["since"]      | "range-1.0"   | <null>           |
| 4  | "index_8a688dca" | "ONLINE" | 100.0             | "RANGE" | "NODE"         | ["Person"]    | ["highScore"]  | "range-1.0"   | <null>           |
| 5  | "index_b87724c3" | "ONLINE" | 100.0             | "RANGE" | "NODE"         | ["Person"]    | ["firstname"]  | "range-1.0"   | <null>           |
+-----------------------------------------------------------------------------------------------------------------------------------------------------+
4 rows
----

======


[[administration-indexes-drop-indexes]]
== +DROP INDEX+

An index can be dropped (removed) using the name with the `DROP INDEX index_name` command.
This command can drop indexes of any type, except those backing constraints.
The name of the index can be found using the xref::indexes-for-search-performance.adoc#administration-indexes-list-indexes[`SHOW INDEXES` command], given in the output column `name`.


[[drop-indexes-examples]]
== +DROP INDEX+

*Examples:*

* xref::indexes-for-search-performance.adoc#administration-indexes-drop-an-index[]
* xref::indexes-for-search-performance.adoc#administration-indexes-drop-a-non-existing-index[]


[discrete]
[[administration-indexes-drop-an-index]]
=== Drop an index


.+DROP INDEX+
======

////
CREATE index `index_example` for (n:`Example`) ON (n.`example`);
////

.Query
[source, cypher, indent=0]
----
DROP INDEX index_name
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Indexes removed: 1
----

======


[discrete]
[[administration-indexes-drop-a-non-existing-index]]
=== Drop a non-existing index

If it is uncertain if an index exists and you want to drop it if it does but not get an error should it not, use `IF EXISTS`.


.+DROP INDEX+
======

.Query
[source, cypher, indent=0]
----
DROP INDEX missing_index_name IF EXISTS
----

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


