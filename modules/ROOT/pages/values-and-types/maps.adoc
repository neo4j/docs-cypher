:description: This section describes how to use maps in Cyphers.

[[cypher-maps]]
= Maps

This section describes how to use maps in Cypher.

[NOTE]
====
Information regarding property access operators such as `.` and `[]` can be found xref::syntax/operators.adoc#query-operators-map[here].
The behavior of the `[]` operator with respect to `null` is detailed xref::values-and-types/working-with-null.adoc#cypher-null-bracket-operator[here].
====


[[cypher-literal-maps]]
== Literal maps

Cypher supports construction of maps.
The key names in a map must be of type `String`.
If returned through an link:{neo4j-docs-base-uri}/http-api/{page-version}[HTTP API call], a JSON object will be returned.
If returned in Java, an object of type `java.util.Map<String,Object>` will be returned.


.Query
[source, cypher, indent=0]
----
RETURN {key: 'Value', listKey: [{inner: 'Map1'}, {inner: 'Map2'}]}
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +{key: 'Value', listKey: [{inner: 'Map1'}, {inner: 'Map2'}]}+
| +{'listKey': [{'inner': 'Map1'}, {'inner': 'Map2'}], 'key': 'Value'}+
1+d|Rows: 1
|===


[[cypher-map-projection]]
== Map projection

Cypher supports map projections, which allows for the construction of map projections from nodes, relationships, and other map values.

A map projection begins with the variable bound to the graph entity to be projected from, and contains a body of comma-separated map elements, enclosed by `{` and  `}`.

.Map projection 
[source, syntax]
----
map_variable {map_element, [, ...n]}
----

A map element projects one or more key-value pairs to the map projection.
There exist four different types of map projection elements:

* Property selector - Projects the property name as the key, and the value from the `map_variable` as the value for the projection.
* Literal entry - This is a key-value pair, with the value being an arbitrary expression `key: <expression>`.
* Variable selector - Projects a variable, with the variable name as the key, and the value the variable is pointing to as the value of the projection. 
Its syntax is just the variable.
* All-properties selector - projects all key-value pairs from the `map_variable` value.

The following conditions apply:

* If the `map_variable` points to a `null` value, the whole map projection will evaluate to `null`.
* The key names in a map must be of type `String`.


[[cypher-map-projection-examples]]
=== Example graph

The following graph is used for the examples below:

image::values_and_types_maps_graph.svg[]

To recreate it, run the following query against an empty Neo4j database:

[source, cypher, role=test-setup]
----
CREATE
  (keanu:Person {name: 'Keanu Reeves', nationality: 'Canadian'}),
  (carrieAnne:Person {name: 'Carrie-Anne Moss'}),
  (thematrixrevolutions:Movie {title: 'The Matrix Revolutions', released: 2003}),
  (thematrixreloaded:Movie {title: 'The Matrix Reloaded', released: 2003}),
  (thematrix:Movie {title: 'The Matrix', released: 1999}),
  (thedevilsadvocate:Movie {title: 'The Devils Advocate', released: 1997}),
  (matrix4:Movie {title: 'The Matrix Resurrections', released: 2021}),
  (keanu)-[:ACTED_IN]->(thematrix),
  (keanu)-[:ACTED_IN]->(thematrixrevolutions),
  (keanu)-[:ACTED_IN]->(thematrixreloaded),
  (keanu)-[:ACTED_IN]->(matrix4),
  (keanu)-[:ACTED_IN]->(thedevilsadvocate),
  (carrieAnne)-[:ACTED_IN]->(thematrix),
  (carrieAnne)-[:ACTED_IN]->(thematrixrevolutions),
  (carrieAnne)-[:ACTED_IN]->(thematrixreloaded),
  (carrieAnne)-[:ACTED_IN]->(matrix4)
----

=== Examples

The below query finds the `Keanu Reeves` and the movies he has acted in. 
It is an example of a map projection with a literal entry, which in turn also uses map projection inside the aggregating xref:functions/aggregating.adoc#functions-collect[collect()] function.

.Query
[source, cypher, indent=0]
----
MATCH (actor:Person {name: 'Keanu Reeves'})-[:ACTED_IN]->(movie:Movie)
WITH actor, collect(movie{.title, .released}) AS movies
RETURN actor{actor.name, movies: movies}
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +actor+
| +{movies: [{title: "The Devils Advocate", released: 1997}, {title: "The Matrix Revolutions", released: 2003}, {title: "The Matrix Resurrections", released: 2021}, {title: "The Matrix Reloaded", released: 2003}, {title: "The Matrix", released: 1999}], name: "Keanu Reeves"}+
1+d|Rows: 1
|===

The below query finds all `Person` nodes in the graph that have one or more relationships with the type `ACTED_IN` connected to `Movie` nodes. 
It uses the xref::functions/aggregating.adoc#unctions-count[count()] function to count how many `Movie` nodes are connected to each `Person` node in this way, and uses a variable selector to project the value of the count. 

.Query
[source, cypher]
----
MATCH (actor:Person)-[:ACTED_IN]->(movie:Movie)
WITH actor, count(movie) AS nmbrOfMovies
RETURN actor{.name, nmbrOfMovies}
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +actor+
| +{nmbrOfMovies: 5, name: "Keanu Reeves"}+
| +{nmbrOfMovies: 4, name: "Carrie-Anne Moss"}+
1+d|Rows: 2
|===

The below query returns all properties from the `Keanu Reeves` node.
An all-properties selector is used to project all the node properties, and additionally, explicitly project the property `age`.
Since this property does not exist on the node `Keanu Reeves`, a `null` value is projected instead.

.Query
[source, cypher]
----
MATCH (actor:Person {name: 'Keanu Reeves'})
RETURN actor{.*, .age}
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +actor+
| +{nationality: "Canadian", name: "Keanu Reeves", age: null}+
1+d|Rows: 1
|===

