:description: information about the concepts behind slotted, pipelined, and parallel runtime. 

[[runtimes-concepts]]
= Concepts

This is a step-by-step guide to the concepts behind Cypher runtimes.
It starts with explaining the role a runtime plays in the lifecycle of a Cypher query, and how to read query plans produced by the Cypher planner.
It then explores the three available runtimes in more detail and their different methods of executing Cypher queries. 

[[runtimes-cypher-query-lifecycle]]
== Cypher runtimes and the lifecycle of a Cypher query

A Cypher query begins as a declarative query string, describing the graph pattern to match in a database.
After parsing, the query string goes through the planner,  which produces an imperative plan, known as the logical plan, to determine the most efficient way of executing the query given the current state of the database.
In the final phase, this logical plan is turned into an executable physical plan, which actually runs the query against the database. Executing this physical plan is the task of the Cypher runtime. 

image::

In Cypher, there are three types of runtimes: slotted, pipelined, and parallel.
In general, the default runtimes provide the best query performance.
However, there are scenarios when deciding which runtime to use can be an important step in maximizing the efficiency of queries.

[[runtimes-example-graph]]

To explain the different Cypher runtimes, a graph based on the UK national rail network is used.
The data in the graph is taken from link:https://www.raildeliverygroup.com/our-services/rail-data/fares-timetable-data.html[publically available datasets].






