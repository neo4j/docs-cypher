:description: This page contains information about each Cypher operator.
:page-aliases: planning-and-tuning/operators-detail.adoc
= Operators in detail

This page contains details and an example query for all operators available in Cypher.
The operators are grouped by the similarity of their characteristics.

Certain operators are only used by a subset of the xref::planning-and-tuning/runtimes/concepts.adoc[runtimes] that Cypher can choose from.
If that is the case, the example queries will be prefixed with an option to choose one of these runtimes.

////
[source, cypher, role=test-setup]
----
CREATE (me:Person {name: 'me'}),
       (andy:Person {name: 'Andy'}),
       (bob:Person {name: 'Bob'}),
       (mattias:Person {name: 'Mattias'}),
       (lovis:Person {name: 'Lovis'}),
       (pontus:Person {name: 'Pontus'}),
       (max:Person {name: 'Max'}),
       (konstantin:Person {name: 'Konstantin'}),
       (stefan:Person {name: 'Stefan'}),
       (mats:Person {name: 'Mats'}),
       (petra:Person {name: 'Petra'}),
       (craig:Person {name: 'Craig'}),
       (steven:Person {name: 'Steven'}),
       (chris:Person {name: 'Chris'}),
       (london:Location {name: 'London'}),
       (malmo:Location {name: 'Malmo'}),
       (sf:Location {name: 'San Francisco'}),
       (berlin:Location {name: 'Berlin'}),
       (newyork:Location {name: 'New York'}),
       (kuala:Location {name: 'Kuala Lumpur'}),
       (stockholm:Location {name: 'Stockholm'}),
       (paris:Location {name: 'Paris'}),
       (madrid:Location {name: 'Madrid'}),
       (rome:Location {name: 'Rome'}),
       (england:Country {name: 'England'}),
       (field:Team {name: 'Field'}),
       (engineering:Team {name: 'Engineering', id:42}),
       (sales:Team {name: 'Sales'}),
       (monads:Team {name: 'Team Monads'}),
       (birds:Team {name: 'Team Enlightened Birdmen'}),
       (quality:Team {name: 'Team Quality'}),
       (rassilon:Team {name: 'Team Rassilon'}),
       (executive:Team {name: 'Team Executive'}),
       (remoting:Team {name: 'Team Remoting'}),
       (other:Team {name: 'Other'}),
       (me)-[:WORKS_IN {id: 0, duration: 190, title: 'senior sales engineer', badgeNumber: 4332}]->(london),
       (bob)-[:WORKS_IN {id: 1, duration: 187, title: 'junior developer', badgeNumber: 3293}]->(london),
       (andy)-[:WORKS_IN {id: 2, duration: 150, title: ''}]->(london),
       (mattias)-[:WORKS_IN {id: 3, duration: 230, title: 'senior developer', badgeNumber: 7627}]->(london),
       (lovis)-[:WORKS_IN {id: 4, duration: 230, title: 'junior developer'}]->(sf),
       (pontus)-[:WORKS_IN {id: 5, duration: 230, title: 'junior developer', badgeNumber: 9596}]->(malmo),
       (max)-[:WORKS_IN {id: 6, duration: 230, title: 'field engineer', badgeNumber: 4416}]->(newyork),
       (konstantin)-[:WORKS_IN {id: 7, duration: 230, title: 'frontend developer'}]->(london),
       (stefan)-[:WORKS_IN {id: 8, duration: 230, title: 'chief architect', badgeNumber: 2951}]->(london),
       (stefan)-[:WORKS_IN {id: 9, duration: 230, title: 'language architect', badgeNumber: 7092}]->(berlin),
       (mats)-[:WORKS_IN {id: 10, duration: 230, title: 'senior developer', badgeNumber: 1402}]->(malmo),
       (petra)-[:WORKS_IN {id: 11, duration: 230, title: 'language architect'}]->(london),
       (craig)-[:WORKS_IN {id: 12, duration: 230, title: 'senior developer'}]->(malmo),
       (steven)-[:WORKS_IN {id: 13, duration: 230, title: 'junior developer', badgeNumber: 1515}]->(malmo),
       (chris)-[:WORKS_IN {id: 14, duration: 230, title: 'field engineer', badgeNumber: 6828}]->(madrid),
       (london)-[:IN]->(england),
       (me)-[:FRIENDS_WITH]->(andy),
       (andy)-[:FRIENDS_WITH]->(bob),
       (mattias)-[:FRIENDS_WITH]->(max),
       (pontus)-[:FRIENDS_WITH]->(mats),
       (konstantin)-[:FRIENDS_WITH]->(steven),
       (craig)-[:FRIENDS_WITH]->(stefan),
       (petra)-[:FRIENDS_WITH]->(lovis),
       (me)-[:FRIENDS_WITH]->(chris),
       (chris)-[:FRIENDS_WITH]->(stefan),
       (bob)-[:FRIENDS_WITH]->(andy),
       (steven)-[:FRIENDS_WITH]->(mats),
       (mattias)-[:FRIENDS_WITH]->(me);

CREATE CONSTRAINT constraint_WORKS_IN_id_unique IF NOT EXISTS FOR ()-[r:WORKS_IN]-() REQUIRE (r.id) IS UNIQUE;
CREATE CONSTRAINT constraint_WORKS_IN_badgeNumber_unique IF NOT EXISTS FOR ()-[r:WORKS_IN]-() REQUIRE (r.badgeNumber) IS UNIQUE;
----
////


[[query-plan-all-nodes-scan]]
== All Nodes Scan
// AllNodesScan

The `AllNodesScan` operator reads all nodes from the node store.
The variable that will contain the nodes is seen in the arguments.
Any query using this operator is likely to encounter performance problems on a non-trivial database.


.AllNodesScan
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
RETURN n
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | n       |             35 |   35 |       0 |                |                        |           |                     |
| |               +---------+----------------+------+---------+----------------+                        |           |                     |
| +AllNodesScan   | n       |             35 |   35 |      36 |            120 |                    3/0 |     0.354 | Fused in Pipeline 0 |
+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 36, total allocated memory: 184
----

======


[[query-plan-directed-relationship-index-scan]]
== Directed Relationship Index Scan
// DirectedRelationshipIndexScan

////
[source, cypher, role=test-setup]
----
CREATE RANGE INDEX range_worksin_title FOR ()-[r:WORKS_IN]->() ON (r.title)
----
////

The `DirectedRelationshipIndexScan` operator examines all values stored in an index, returning all relationships and their start and end nodes with a particular relationship type and a specified property.


.DirectedRelationshipIndexScan
======

.Query
[source, cypher]
----
PROFILE
MATCH ()-[r: WORKS_IN]->()
WHERE r.title IS NOT NULL
RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+--------------------------------+----------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                       | Details                                                                    | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+--------------------------------+----------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                | r                                                                          |             15 |   15 |       0 |                |                        |           |                     |
| |                              +----------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedRelationshipIndexScan | RANGE INDEX (anon_0)-[r:WORKS_IN(title)]->(anon_1) WHERE title IS NOT NULL |             15 |   15 |      16 |            120 |                    3/1 |     2.464 | Fused in Pipeline 0 |
+--------------------------------+----------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 16, total allocated memory: 184
----

======


[[query-plan-undirected-relationship-index-scan]]
== Undirected Relationship Index Scan
// UndirectedRelationshipIndexScan

The `UndirectedRelationshipIndexScan` operator examines all values stored in an index, returning all relationships and their start and end nodes with a particular relationship type and a specified property.


.UndirectedRelationshipIndexScan
======

.Query
[source, cypher]
----
PROFILE
MATCH ()-[r: WORKS_IN]-()
WHERE r.title IS NOT NULL
RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+----------------------------------+---------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                         | Details                                                                   | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+----------------------------------+---------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                  | r                                                                         |             30 |   30 |       0 |                |                        |           |                     |
| |                                +---------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedRelationshipIndexScan | RANGE INDEX (anon_0)-[r:WORKS_IN(title)]-(anon_1) WHERE title IS NOT NULL |             30 |   30 |      16 |            120 |                    3/1 |     1.266 | Fused in Pipeline 0 |
+----------------------------------+---------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 16, total allocated memory: 184
----

======


[[query-plan-directed-relationship-index-seek]]
== Directed Relationship Index Seek
// DirectedRelationshipIndexSeek

The `DirectedRelationshipIndexSeek` operator finds relationships and their start and end nodes using an index seek.
The relationship variable and the index used are shown in the arguments of the operator.


.DirectedRelationshipIndexSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (candidate)-[r:WORKS_IN]->()
WHERE r.title = 'chief architect'
RETURN candidate
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+--------------------------------+-----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                       | Details                                                                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+--------------------------------+-----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                | candidate                                                                         |              2 |    1 |       0 |                |                        |           |                     |
| |                              +-----------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedRelationshipIndexSeek | RANGE INDEX (candidate)-[r:WORKS_IN(title)]->(anon_0) WHERE title = $autostring_0 |              2 |    1 |       2 |            120 |                    3/1 |     0.591 | Fused in Pipeline 0 |
+--------------------------------+-----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 184
----

======


[[query-plan-undirected-relationship-index-seek]]
== Undirected Relationship Index Seek
// UndirectedRelationshipIndexSeek

The `UndirectedRelationshipIndexSeek` operator finds relationships and their start and end nodes using an index seek.
The relationship variable and the index used are shown in the arguments of the operator.


.UndirectedRelationshipIndexSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (candidate)-[r:WORKS_IN]-()
WHERE r.title = 'chief architect'
RETURN candidate
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+----------------------------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                         | Details                                                                          | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+----------------------------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                  | candidate                                                                        |              4 |    2 |       0 |                |                        |           |                     |
| |                                +----------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedRelationshipIndexSeek | RANGE INDEX (candidate)-[r:WORKS_IN(title)]-(anon_0) WHERE title = $autostring_0 |              4 |    2 |       2 |            120 |                    3/1 |     0.791 | Fused in Pipeline 0 |
+----------------------------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 184
----

======


[[query-plan-directed-relationship-by-element-id-seek]]
== Directed Relationship By Element Id Seek
// DirectedRelationshipByElementIdSeek

The `DirectedRelationshipByElementIdSeek` operator reads one or more relationships by element id from the relationship store, and produces both the relationship and the nodes on either side.


.DirectedRelationshipByElementIdSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (n1)-[r]->()
WHERE elementId(r) = 0
RETURN r, n1
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+--------------------------------------+----+----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| Operator                             | Id | Details                                            | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline      |
+--------------------------------------+----+----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +ProduceResults                      |  0 | r, n1                                              |              1 |    0 |       0 |              0 |                    0/0 |     0.314 |               |
| |                                    +----+----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+               |
| +DirectedRelationshipByElementIdSeek |  1 | (n1)-[r]->(anon_0) WHERE elementId(r) = $autoint_0 |              1 |    0 |       0 |            248 |                    0/0 |     2.337 | In Pipeline 0 |
+--------------------------------------+----+----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+

Total database accesses: 0, total allocated memory: 312
----

======

[[query-plan-directed-relationship-by-id-seek]]
== Directed Relationship By Id Seek
// DirectedRelationshipByIdSeek

The `DirectedRelationshipByIdSeek` operator reads one or more relationships by id from the relationship store, and produces both the relationship and the nodes on either side.


.DirectedRelationshipByIdSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (n1)-[r]->()
WHERE id(r) = 0
RETURN r, n1
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------------------+----+---------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                      | Id | Details                                     | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-------------------------------+----+---------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults               |  0 | r, n1                                       |              1 |    1 |       7 |              0 |                        |           |                     |
| |                             +----+---------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedRelationshipByIdSeek |  1 | (n1)-[r]->(anon_0) WHERE id(r) = $autoint_0 |              1 |    1 |       1 |            248 |                    3/0 |     0.483 | Fused in Pipeline 0 |
+-------------------------------+----+---------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 8, total allocated memory: 312
----

======

[[query-plan-undirected-relationship-by-element-id-seek]]
== Undirected Relationship By Element Id Seek
// UndirectedRelationshipByElementIdSeek

The `UndirectedRelationshipByElementIdSeek` operator reads one or more relationships by element id from the relationship store.
As the direction is unspecified, two rows are produced for each relationship as a result of alternating the combination of the start and end node.


.UndirectedRelationshipByElementIdSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (n1)-[r]-()
WHERE elementId(r) = 1
RETURN r, n1
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------------------------+--------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                              | Details                                    | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------------------------+--------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                       | r, n1                                      |              2 |    2 |       0 |                |                        |           |                     |
| |                                     +--------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedRelationshipByElementIdSeek| (n1)-[r]-(anon_0) WHERE elementId(r) = $autoint_0 |       2 |    2 |       1 |            120 |                    4/0 |     0.332 | Fused in Pipeline 0 |
+---------------------------------+--------------------------------------------+-----+---------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 184
----

======

[[query-plan-undirected-relationship-by-id-seek]]
== Undirected Relationship By Id Seek
// UndirectedRelationshipByIdSeek

The `UndirectedRelationshipByIdSeek` operator reads one or more relationships by id from the relationship store.
As the direction is unspecified, two rows are produced for each relationship as a result of alternating the combination of the start and end node.


.UndirectedRelationshipByIdSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (n1)-[r]-()
WHERE id(r) = 1
RETURN r, n1
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------------------+----+--------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                        | Id | Details                                    | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------------------+----+--------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                 |  0 | r, n1                                      |              2 |    2 |      14 |              0 |                        |           |                     |
| |                               +----+--------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedRelationshipByIdSeek |  1 | (n1)-[r]-(anon_0) WHERE id(r) = $autoint_0 |              2 |    2 |       1 |            248 |                    3/0 |     1.005 | Fused in Pipeline 0 |
+---------------------------------+----+--------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 15, total allocated memory: 312
----

======


[[query-plan-directed-relationship-index-contains-scan]]
== Directed Relationship Index Contains Scan
// DirectedRelationshipIndexContainsScan

////
[source, cypher, role=test-setup]
----
CREATE TEXT INDEX text_worksin_title FOR ()-[r:WORKS_IN]->() ON (r.title)
----
////

The `DirectedRelationshipIndexContainsScan` operator examines all values stored in an index, searching for entries containing a specific string; for example, in queries including `CONTAINS`.
Although this is slower than an index seek (since all entries need to be examined), it is still faster than the indirection resulting from a type scan using `DirectedRelationshipTypeScan`, and a property store filter.


.DirectedRelationshipIndexContainsScan
======

.Query
[source, cypher]
----
PROFILE
MATCH ()-[r: WORKS_IN]->()
WHERE r.title CONTAINS 'senior'
RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+----------------------------------------+--------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                               | Details                                                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+----------------------------------------+--------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                        | r                                                                                    |              0 |    4 |       0 |                |                        |           |                     |
| |                                      +--------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedRelationshipIndexContainsScan | TEXT INDEX (anon_0)-[r:WORKS_IN(title)]->(anon_1) WHERE title CONTAINS $autostring_0 |              0 |    4 |       5 |            120 |                    3/0 |     1.051 | Fused in Pipeline 0 |
+----------------------------------------+--------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 5, total allocated memory: 184
----

======


[[query-plan-undirected-relationship-index-contains-scan]]
== Undirected Relationship Index Contains Scan
// UndirectedRelationshipIndexContainsScan

The `UndirectedRelationshipIndexContainsScan` operator examines all values stored in an index, searching for entries containing a specific string; for example, in queries including `CONTAINS`.
Although this is slower than an index seek (since all entries need to be examined), it is still faster than the indirection resulting from a type scan using `DirectedRelationshipTypeScan`, and a property store filter.


.UndirectedRelationshipIndexContainsScan
======

.Query
[source, cypher]
----
PROFILE
MATCH ()-[r: WORKS_IN]-()
WHERE r.title CONTAINS 'senior'
RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------------------------+-------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                                 | Details                                                                             | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------------------------------+-------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                          | r                                                                                   |              0 |    8 |       0 |                |                        |           |                     |
| |                                        +-------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedRelationshipIndexContainsScan | TEXT INDEX (anon_0)-[r:WORKS_IN(title)]-(anon_1) WHERE title CONTAINS $autostring_0 |              0 |    8 |       5 |            120 |                    3/0 |     2.684 | Fused in Pipeline 0 |
+------------------------------------------+-------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 5, total allocated memory: 184
----

======


[[query-plan-directed-relationship-index-ends-with-scan]]
== Directed Relationship Index Ends With Scan
// DirectedRelationshipIndexEndsWithScan

The `DirectedRelationshipIndexEndsWithScan` operator examines all values stored in an index, searching for entries ending in a specific string; for example, in queries containing `ENDS WITH`.
Although this is slower than an index seek (since all entries need to be examined), it is still faster than the indirection resulting from a label scan using `NodeByLabelScan`, and a property store filter.


.DirectedRelationshipIndexEndsWithScan
======

.Query
[source, cypher]
----
PROFILE
MATCH ()-[r: WORKS_IN]->()
WHERE r.title ENDS WITH 'developer'
RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+----------------------------------------+---------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                               | Details                                                                               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+----------------------------------------+---------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                        | r                                                                                     |              0 |    8 |       0 |                |                        |           |                     |
| |                                      +---------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedRelationshipIndexEndsWithScan | TEXT INDEX (anon_0)-[r:WORKS_IN(title)]->(anon_1) WHERE title ENDS WITH $autostring_0 |              0 |    8 |       9 |            120 |                    3/0 |     1.887 | Fused in Pipeline 0 |
+----------------------------------------+---------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 9, total allocated memory: 184
----

======


[[query-plan-undirected-relationship-index-ends-with-scan]]
== Undirected Relationship Index Ends With Scan
// UndirectedRelationshipIndexEndsWithScan

The `UndirectedRelationshipIndexEndsWithScan` operator examines all values stored in an index, searching for entries ending in a specific string; for example, in queries containing `ENDS WITH`.
Although this is slower than an index seek (since all entries need to be examined), it is still faster than the indirection resulting from a label scan using `NodeByLabelScan`, and a property store filter.


.UndirectedRelationshipIndexEndsWithScan
======

.Query
[source, cypher]
----
PROFILE
MATCH ()-[r: WORKS_IN]-()
WHERE r.title ENDS WITH 'developer'
RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------------------------+--------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                                 | Details                                                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------------------------------+--------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                          | r                                                                                    |              0 |   16 |       0 |                |                        |           |                     |
| |                                        +--------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedRelationshipIndexEndsWithScan | TEXT INDEX (anon_0)-[r:WORKS_IN(title)]-(anon_1) WHERE title ENDS WITH $autostring_0 |              0 |   16 |       9 |            120 |                    3/0 |     1.465 | Fused in Pipeline 0 |
+------------------------------------------+--------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 9, total allocated memory: 184
----

======


[[query-plan-directed-relationship-index-seek-by-range]]
== Directed Relationship Index Seek By Range
// DirectedRelationshipIndexSeekByRange

////
[source, cypher, role=test-setup]
----
CREATE RANGE INDEX range_worksin_duration FOR ()-[r:WORKS_IN]->() ON (r.duration)
----
////

The `DirectedRelationshipIndexSeekByRange` operator finds relationships and their start and end nodes using an index seek where the value of the property matches a given prefix string.
`DirectedRelationshipIndexSeekByRange` can be used for `STARTS WITH` and comparison operators such as `+<+`, `+>+`, `+<=+` and `+>=+`.


.DirectedRelationshipIndexSeekByRange
======

.Query
[source, cypher]
----
PROFILE
MATCH (candidate: Person)-[r:WORKS_IN]->(location)
WHERE r.duration > 100
RETURN candidate
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------------------------+----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                              | Details                                                                                | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------------------------+----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                       | candidate                                                                              |              4 |   15 |       0 |                |                        |           |                     |
| |                                     +----------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter                               | candidate:Person                                                                       |              4 |   15 |      30 |                |                        |           |                     |
| |                                     +----------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedRelationshipIndexSeekByRange | RANGE INDEX (candidate)-[r:WORKS_IN(duration)]->(location) WHERE duration > $autoint_0 |              4 |   15 |      16 |            120 |                    4/1 |     0.703 | Fused in Pipeline 0 |
+---------------------------------------+----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 46, total allocated memory: 184
----

======


[[query-plan-undirected-relationship-index-seek-by-range]]
== Undirected Relationship Index Seek By Range
// UndirectedRelationshipIndexSeekByRange

The `UndirectedRelationshipIndexSeekByRange` operator finds relationships and their start and end nodes using an index seek where the value of the property matches a given prefix string.
`UndirectedRelationshipIndexSeekByRange` can be used for `STARTS WITH` and comparison operators such as `+<+`, `+>+`, `+<=+` and `+>=+`.


.UndirectedRelationshipIndexSeekByRange
======

.Query
[source, cypher]
----
PROFILE
MATCH (candidate: Person)-[r:WORKS_IN]-(location)
WHERE r.duration > 100
RETURN candidate
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------------------------+---------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                                | Details                                                                               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------------------------------+---------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                         | candidate                                                                             |              5 |   15 |       0 |                |                        |           |                     |
| |                                       +---------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter                                 | candidate:Person                                                                      |              5 |   15 |      60 |                |                        |           |                     |
| |                                       +---------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedRelationshipIndexSeekByRange | RANGE INDEX (candidate)-[r:WORKS_IN(duration)]-(location) WHERE duration > $autoint_0 |              8 |   30 |      16 |            120 |                    4/1 |     1.214 | Fused in Pipeline 0 |
+-----------------------------------------+---------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 76, total allocated memory: 184
----

======


[[query-plan-union-node-by-labels-scan]]
== Union Node By Labels Scan
// UnionNodeByLabelsScan
// New in 5.0

The `UnionNodeByLabelsScan` operator fetches all nodes that have at least one of the provided labels from the node label index.
======

.Query
[source,cypher]
----
PROFILE
MATCH (countryOrLocation:Country|Location)
RETURN countryOrLocation
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------+------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+
| Operator               | Details                            | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by            | Pipeline            |
+------------------------+------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+
| +ProduceResults        | countryOrLocation                  |             17 |   11 |       0 |                |                        |           |                       |                     |
| |                      +------------------------------------+----------------+------+---------+----------------+                        |           |                       |                     |
| +UnionNodeByLabelsScan | countryOrLocation:Country|Location |             17 |   11 |      13 |            120 |                    3/1 |     0.660 | countryOrLocation ASC | Fused in Pipeline 0 |
+------------------------+------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+

Total database accesses: 13, total allocated memory: 184
----

======


[[query-plan-intersection-node-by-labels-scan]]
== Intersection Node By Labels Scan
// IntersectionNodeByLabelsScan
// New in 5.4

_This feature was introduced in Neo4j 5.5._

The `IntersectionNodeByLabelsScan` operator fetches all nodes that have all of the provided labels from the node label index.
======

.Query
[source,cypher]
----
PROFILE
MATCH (countryAndLocation:Country&Location)
RETURN countryAndLocation
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128


+-------------------------------+----+-------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                      | Id | Details                             | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-------------------------------+----+-------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults               |  0 | countryAndLocation                  |             10 |    0 |       0 |                |                        |           |                     |
| |                             +----+-------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +IntersectionNodeByLabelsScan |  1 | countryAndLocation:Country&Location |             10 |    0 |       0 |            120 |                    0/0 |     1.011 | Fused in Pipeline 0 |
+-------------------------------+----+-------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 13, total allocated memory: 184
----

======


[[query-plan-directed-all-relationships-scan]]
== Directed All Relationships Scan ==
The `DirectedAllRelationshipsScan` operator fetches all relationships and their start and end nodes in the database.
======

.Query
[source,cypher]
----
PROFILE
MATCH ()-[r]->() RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------------------+------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                      | Details                | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-------------------------------+------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults               | r                      |             28 |   28 |       0 |                |                        |           |                     |
| |                             +------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedAllRelationshipsScan | (anon_0)-[r]->(anon_1) |             28 |   28 |      28 |            120 |                    3/0 |     0.502 | Fused in Pipeline 0 |
+-------------------------------+------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 28, total allocated memory: 184

----
======

[[query-plan-undirected-all-relationships-scan]]
== Undirected All Relationships Scan ==
The `UndirectedAllRelationshipsScan` operator fetches all relationships and their start and end nodes in the database.

======
.Query
[source,cypher]
----
PROFILE
MATCH ()-[r]-() RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------------------+-----------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                        | Details               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------------------+-----------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                 | r                     |             56 |   56 |       0 |                |                        |           |                     |
| |                               +-----------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedAllRelationshipsScan | (anon_0)-[r]-(anon_1) |             56 |   56 |      28 |            120 |                    3/0 |     1.110 | Fused in Pipeline 0 |
+---------------------------------+-----------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 28, total allocated memory: 184

----
======

[[query-plan-directed-relationship-type-scan]]
== Directed Relationship Type Scan
// DirectedRelationshipTypeScan

The `DirectedRelationshipTypeScan` operator fetches all relationships and their start and end nodes with a specific type from the relationship type index.


.DirectedRelationshipTypeScan
======

.Query
[source, cypher]
----
PROFILE
MATCH ()-[r: FRIENDS_WITH]->()
RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------------------+-------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                      | Details                             | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-------------------------------+-------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults               | r                                   |             12 |   12 |       0 |                |                        |           |                     |
| |                             +-------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedRelationshipTypeScan | (anon_0)-[r:FRIENDS_WITH]->(anon_1) |             12 |   12 |      13 |            120 |                    2/1 |     0.557 | Fused in Pipeline 0 |
+-------------------------------+-------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 13, total allocated memory: 184
----

======


[[query-plan-undirected-relationship-type-scan]]
== Undirected Relationship Type Scan
// UndirectedRelationshipTypeScan

The `UndirectedRelationshipTypeScan` operator fetches all relationships and their start and end nodes with a specific type from the relationship type index.

======

.Query
[source, cypher]
----
PROFILE
MATCH ()-[r: FRIENDS_WITH]-()
RETURN r
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------------------+------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                        | Details                            | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------------------+------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                 | r                                  |             24 |   24 |       0 |                |                        |           |                     |
| |                               +------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +UndirectedRelationshipTypeScan | (anon_0)-[r:FRIENDS_WITH]-(anon_1) |             24 |   24 |      13 |            120 |                    2/1 |     0.749 | Fused in Pipeline 0 |
+---------------------------------+------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 13, total allocated memory: 184
----

======


[[query-plan-directed-union-relationship-types-scan]]
== Directed Union Relationship Types Scan
// DirectedUnionRelationshipTypeScan

The `DirectedUnionRelationshipTypeScan` operator fetches all relationships and their start and end nodes with at least one of the provided types from the relationship type index.


.DirectedUnionRelationshipTypeScan
======

.Query
[source,cypher]
----
PROFILE
MATCH ()-[friendOrFoe: FRIENDS_WITH|FOE]->()
RETURN friendOrFoe
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------------------------+---------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------+---------------------+
| Operator                            | Details                                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by      | Pipeline            |
+-------------------------------------+---------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------+---------------------+
| +ProduceResults                     | friendOrFoe                                       |             15 |   12 |       0 |                |                        |           |                 |                     |
| |                                   +---------------------------------------------------+----------------+------+---------+----------------+                        |           |                 |                     |
| +DirectedUnionRelationshipTypesScan | (anon_0)-[friendOrFoe:FRIENDS_WITH|FOE]->(anon_1) |             15 |   12 |      14 |            120 |                    3/1 |     2.027 | friendOrFoe ASC | Fused in Pipeline 0 |
+-------------------------------------+---------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------+---------------------+

Total database accesses: 14, total allocated memory: 184
----

======


[[query-plan-undirected-union-relationship-types-scan]]
== Undirected Union Relationship Types Scan
// UndirectedUnionRelationshipTypeScan

The `UndirectedUnionRelationshipTypeScan` operator fetches all relationships and their start and end nodes with at least one of the provided types from the relationship type index.


.UndirectedUnionRelationshipTypeScan
======

.Query
[source,cypher]
----
PROFILE
MATCH ()-[friendOrFoe: FRIENDS_WITH|FOE]-()
RETURN friendOrFoe
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------------------------+--------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------+---------------------+
| Operator                              | Details                                          | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by      | Pipeline            |
+---------------------------------------+--------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------+---------------------+
| +ProduceResults                       | friendOrFoe                                      |             30 |   24 |       0 |                |                        |           |                 |                     |
| |                                     +--------------------------------------------------+----------------+------+---------+----------------+                        |           |                 |                     |
| +UndirectedUnionRelationshipTypesScan | (anon_0)-[friendOrFoe:FRIENDS_WITH|FOE]-(anon_1) |             30 |   24 |      14 |            120 |                    3/1 |     0.887 | friendOrFoe ASC | Fused in Pipeline 0 |
+---------------------------------------+--------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------+---------------------+

Total database accesses: 14, total allocated memory: 184
----

======

[[query-plan-node-by-elementid-seek]]
== Node By ElementId Seek
// NodeByElementIdSeek

_This feature was introduced in Neo4j 5.3._

The `NodeByElementIdSeek` operator reads one or more nodes by ID from the node store, specified via the function xref::functions/scalar.adoc#functions-elementid[elementId()].

.NodeByElementIdSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
WHERE elementId(n) = 0
RETURN n
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator               | Details                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults        | n                                 |              1 |    1 |       0 |                |                        |           |                     |
| |                      +-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+----------------------                        |           |                     |
| +NodeByElementIdSeek   | n WHERE elementId(n) = $autoint_0 |              1 |    1 |       1 |            120 |                    3/0 |     2.108 | Fused in Pipeline 0 |
+------------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 184
----

======

[[query-plan-node-by-id-seek]]
== Node By Id Seek
// NodeByIdSeek

The `NodeByIdSeek` operator reads one or more nodes by ID from the node store, specified via the function xref::functions/scalar.adoc#functions-id[id()].


.NodeByIdSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
WHERE id(n) = 0
RETURN n
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----+----------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Id | Details                    | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----+----------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults |  0 | n                          |              1 |    1 |       2 |              0 |                        |           |                     |
| |               +----+----------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByIdSeek   |  1 | n WHERE id(n) = $autoint_0 |              1 |    1 |       1 |            248 |                    2/0 |     1.109 | Fused in Pipeline 0 |
+-----------------+----+----------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 312

1 row
----

======

[[query-plan-node-by-element-id-seek]]
== Node By Element Id Seek
// NodeByElementIdSeek

The `NodeByElementIdSeek` operator reads one or more nodes by element ID from the node store, specified via the function xref::functions/scalar.adoc#functions-elementid[elementId()].


.NodeByElementIdSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
WHERE elementId(n) = 0
RETURN n
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+----------------------+----+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| Operator             | Id | Details                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline      |
+----------------------+----+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +ProduceResults      |  0 | n                                 |              1 |    0 |       0 |                |                    0/0 |     0.042 |               |
| |                    +----+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+               |
| +NodeByElementIdSeek |  1 | n WHERE elementId(n) = $autoint_0 |              1 |    0 |       1 |            248 |                    0/0 |     0.107 | In Pipeline 0 |
+----------------------+----+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+



Total database accesses: 1, total allocated memory: 184
----

======


[[query-plan-node-by-label-scan]]
== Node By Label Scan
// NodeByLabelScan

The `NodeByLabelScan` operator fetches all nodes with a specific label from the node label index.


.NodeByLabelScan
======

.Query
[source, cypher]
----
PROFILE
MATCH (person:Person)
RETURN person
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Details       | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  | person        |             14 |   14 |       0 |                |                        |           |                     |
| |                +---------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan | person:Person |             14 |   14 |      15 |            120 |                    2/1 |     0.522 | Fused in Pipeline 0 |
+------------------+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 15, total allocated memory: 184
----

======


[[query-plan-node-index-seek]]
== Node Index Seek
// NodeIndexSeek

////
[source, cypher, role=test-setup]
----
CREATE RANGE INDEX range_location_name FOR (l:Location) ON (l.name)
----
////

The `NodeIndexSeek` operator finds nodes using an index seek.
The node variable and the index used are shown in the arguments of the operator.
If the index is a unique index, the operator is instead called xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-node-unique-index-seek[NodeUniqueIndexSeek].


.NodeIndexSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (location:Location {name: 'Malmo'})
RETURN location
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | location                                                       |              1 |    1 |       0 |                |                        |           |                     |
| |               +----------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexSeek  | RANGE INDEX location:Location(name) WHERE name = $autostring_0 |              1 |    1 |       2 |            120 |                    2/1 |     0.401 | Fused in Pipeline 0 |
+-----------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 184
----

======


[[query-plan-node-unique-index-seek]]
== Node Unique Index Seek
// NodeUniqueIndexSeek

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT team_name IF NOT EXISTS FOR (t:Team) REQUIRE (t.name) IS UNIQUE
----
////

The `NodeUniqueIndexSeek` operator finds nodes using an index seek within a unique index.
The node variable and the index used are shown in the arguments of the operator.
If the index is not unique, the operator is instead called xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-node-index-seek[NodeIndexSeek].
If the index seek is used to solve a xref::clauses/merge.adoc[MERGE] clause, it will also be marked with `(Locking)`.
This makes it clear that any nodes returned from the index will be locked in order to prevent concurrent conflicting updates.


.NodeUniqueIndexSeek
======

.Query
[source, cypher]
----
PROFILE
MATCH (t:Team {name: 'Malmo'})
RETURN t
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+----------------------+------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator             | Details                                        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+----------------------+------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults      | t                                              |              1 |    0 |       0 |                |                        |           |                     |
| |                    +------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeUniqueIndexSeek | UNIQUE t:Team(name) WHERE name = $autostring_0 |              1 |    0 |       1 |            120 |                    0/1 |     0.280 | Fused in Pipeline 0 |
+----------------------+------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 184
----

======


[[query-plan-multi-node-index-seek]]
== Multi Node Index Seek
// MultiNodeIndexSeek

////
[source, cypher, role=test-setup]
----
CREATE RANGE INDEX range_person_name FOR (p:Person) ON (p.name)
----
////

The `MultiNodeIndexSeek` operator finds nodes using multiple index seeks.
It supports using multiple distinct indexes for different nodes in the query.
The node variables and the indexes used are shown in the arguments of the operator.

The operator yields a cartesian product of all index seeks.
For example, if the operator does two seeks and the first seek finds the nodes `a1, a2` and the second `b1, b2, b3`, the `MultiNodeIndexSeek` will yield the rows `(a1, b1), (a1, b2), (a1, b3), (a2, b1), (a2, b2), (a2, b3)`.


.MultiNodeIndexSeek
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=pipelined
MATCH
  (location:Location {name: 'Malmo'}),
  (person:Person {name: 'Bob'})
RETURN location, person
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------+-----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator            | Details                                                         | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------+-----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults     | location, person                                                |              1 |    1 |       0 |                |                        |           |                     |
| |                   +-----------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +MultiNodeIndexSeek | RANGE INDEX location:Location(name) WHERE name = $autostring_0, |              1 |    0 |       0 |            120 |                    2/2 |     1.910 | Fused in Pipeline 0 |
|                     | RANGE INDEX person:Person(name) WHERE name = $autostring_1      |                |      |         |                |                        |           |                     |
+---------------------+-----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 0, total allocated memory: 184
----

======


[[query-plan-asserting-multi-node-index-seek]]
== Asserting Multi Node Index Seek
// AssertingMultiNodeIndexSeek

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT team_id IF NOT EXISTS FOR (t:Team) REQUIRE (t.id) IS UNIQUE
----
////

The `AssertingMultiNodeIndexSeek` operator is used to ensure that no property uniqueness constraints are violated.
The example looks for the presence of a team with the supplied name and id, and if one does not exist, it will be created.
Owing to the existence of two property uniqueness constraints on `:Team(name)` and `:Team(id)`, any node that would be found by the `UniqueIndexSeek` operator must be the very same node or the constraints would be violated.


.AssertingMultiNodeIndexSeek
======

.Query
[source, cypher]
----
PROFILE
MERGE (t:Team {name: 'Engineering', id: 42})
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------------+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                     | Details                                                                                 | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------------------+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults              |                                                                                         |              1 |    0 |       0 |                |                        |           |                     |
| |                            +-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult                 |                                                                                         |              1 |    0 |       0 |                |                        |           |                     |
| |                            +-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Merge                       | CREATE (t:Team {name: $autostring_0, id: $autoint_1})                                   |              1 |    1 |       0 |                |                        |           |                     |
| |                            +-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +AssertingMultiNodeIndexSeek | UNIQUE t:Team(name) WHERE name = $autostring_0, UNIQUE t:Team(id) WHERE id = $autoint_1 |              0 |    2 |       4 |            120 |                    0/2 |     1.584 | Fused in Pipeline 0 |
+------------------------------+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 4, total allocated memory: 184
----

======


[[query-plan-node-index-seek-by-range]]
== Node Index Seek By Range
// NodeIndexSeekByRange


The `NodeIndexSeekByRange` operator finds nodes using an index seek where the value of the property matches a given prefix string.
`NodeIndexSeekByRange` can be used for `STARTS WITH` and comparison operators such as `+<+`, `+>+`, `+<=+` and `+>=+`.
If the index is a unique index, the operator is instead called `NodeUniqueIndexSeekByRange`.


.NodeIndexSeekByRange
======

.Query
[source, cypher]
----
PROFILE
MATCH (l:Location)
WHERE l.name STARTS WITH 'Lon'
RETURN l
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------+-------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator              | Details                                                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------------+-------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults       | l                                                                 |              2 |    1 |       0 |                |                        |           |                     |
| |                     +-------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexSeekByRange | RANGE INDEX l:Location(name) WHERE name STARTS WITH $autostring_0 |              2 |    1 |       2 |            120 |                    3/0 |     0.825 | Fused in Pipeline 0 |
+-----------------------+-------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 184
----

======


[[query-plan-node-unique-index-seek-by-range]]
== Node Unique Index Seek By Range
// NodeUniqueIndexSeekByRange

The `NodeUniqueIndexSeekByRange` operator finds nodes using an index seek within a unique index, where the value of the property matches a given prefix string.
`NodeUniqueIndexSeekByRange` is used by `STARTS WITH` and comparison operators such as `+<+`, `+>+`, `+<=+`, and `+>=+`.
If the index is not unique, the operator is instead called `NodeIndexSeekByRange`.


.NodeUniqueIndexSeekByRange
======

.Query
[source, cypher]
----
PROFILE
MATCH (t:Team)
WHERE t.name STARTS WITH 'Ma'
RETURN t
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                    | Details                                                  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults             | t                                                        |              2 |    0 |       0 |                |                        |           |                     |
| |                           +----------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeUniqueIndexSeekByRange | UNIQUE t:Team(name) WHERE name STARTS WITH $autostring_0 |              2 |    0 |       1 |            120 |                    1/0 |     0.623 | Fused in Pipeline 0 |
+-----------------------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 184
----

======


[[query-plan-node-index-contains-scan]]
== Node Index Contains Scan ==
// NodeIndexContainsScan

////
[source, cypher, role=test-setup]
----
CREATE TEXT INDEX text_location_name FOR (l:Location) ON (l.name)
----
////

The `NodeIndexContainsScan` operator examines all values stored in an index, searching for entries containing a specific string; for example, in queries including `CONTAINS`.
Although this is slower than an index seek (since all entries need to be examined), it is still faster than the indirection resulting from a label scan using `NodeByLabelScan`, and a property store filter.


.NodeIndexContainsScan
======

.Query
[source, cypher]
----
PROFILE
MATCH (l:Location)
WHERE l.name CONTAINS 'al'
RETURN l
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------+---------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator               | Details                                                       | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------------+---------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults        | l                                                             |              0 |    2 |       0 |                |                        |           |                     |
| |                      +---------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexContainsScan | TEXT INDEX l:Location(name) WHERE name CONTAINS $autostring_0 |              0 |    2 |       3 |            120 |                    2/0 |     1.305 | Fused in Pipeline 0 |
+------------------------+---------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 184
----

======


[[query-plan-node-index-ends-with-scan]]
== Node Index Ends With Scan
// NodeIndexEndsWithScan

The `NodeIndexEndsWithScan` operator examines all values stored in an index, searching for entries ending in a specific string; for example, in queries containing `ENDS WITH`.
Although this is slower than an index seek (since all entries need to be examined), it is still faster than the indirection resulting from a label scan using `NodeByLabelScan`, and a property store filter.


.NodeIndexEndsWithScan
======

.Query
[source, cypher]
----
PROFILE
MATCH (l:Location)
WHERE l.name ENDS WITH 'al'
RETURN l
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator               | Details                                                        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults        | l                                                              |              0 |    0 |       0 |                |                        |           |                     |
| |                      +----------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexEndsWithScan | TEXT INDEX l:Location(name) WHERE name ENDS WITH $autostring_0 |              0 |    0 |       1 |            120 |                    0/0 |     4.409 | Fused in Pipeline 0 |
+------------------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 184
----

======


[[query-plan-node-index-scan]]
== Node Index Scan
// NodeIndexScan

The `NodeIndexScan` operator examines all values stored in an index, returning all nodes with a particular label and a specified property.


.NodeIndexScan
======

.Query
[source, cypher]
----
PROFILE
MATCH (l:Location)
WHERE l.name IS NOT NULL
RETURN l
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+-----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                             | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+-----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | l                                                   |             10 |   10 |       0 |                |                        |           |                     |
| |               +-----------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexScan  | RANGE INDEX l:Location(name) WHERE name IS NOT NULL |             10 |   10 |      11 |            120 |                    2/1 |     0.557 | Fused in Pipeline 0 |
+-----------------+-----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 11, total allocated memory: 184
----

======



// --- apply operators ---

[[query-plan-apply]]
== Apply
// Apply

All the different `Apply` operators (listed below) share the same basic functionality: they perform a nested loop by taking a single row from the left-hand side, and using the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-argument[Argument] operator on the right-hand side, execute the operator tree on the right-hand side.
The versions of the `Apply` operators differ in how the results are managed.
The `Apply` operator (i.e. the standard version) takes the row produced by the right-hand side -- which at this point contains data from both the left-hand and right-hand sides -- and yields it.


.Apply
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person {name: 'me'})
MATCH (q:Person {name: p.secondName})
RETURN p, q
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Details                                               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  | p, q                                                  |              1 |    0 |       0 |                |                        |           |                     |
| |                +-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Apply           |                                                       |              1 |    0 |       0 |                |                        |           |                     |
| |\               +-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +NodeIndexSeek | RANGE INDEX q:Person(name) WHERE name = p.secondName  |              1 |    0 |       0 |           2152 |                    0/0 |     0.219 | Fused in Pipeline 1 |
| |                +-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeIndexSeek   | RANGE INDEX p:Person(name) WHERE name = $autostring_0 |              1 |    1 |       2 |            120 |                    0/1 |     0.236 | In Pipeline 0       |
+------------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 2216
----

======


[[query-plan-semi-apply]]
== Semi Apply
// SemiApply

The `SemiApply` operator tests for the presence of a pattern predicate, and is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.
If the right-hand side operator yields at least one row, the row from the left-hand side operator is yielded by the `SemiApply` operator.
This makes `SemiApply` a filtering operator, used mostly for pattern predicates in queries.


.SemiApply
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MATCH (p:Person)
WHERE (p)-[:FRIENDS_WITH]->(:Person)
RETURN p.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------+-------------------------------------+----------------+------+---------+------------------------+
| Operator        | Details                             | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-----------------+-------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults | `p.name`                            |             11 |   10 |       0 |                    0/0 |
| |               +-------------------------------------+----------------+------+---------+------------------------+
| +Projection     | p.name AS `p.name`                  |             11 |   10 |      10 |                    1/0 |
| |               +-------------------------------------+----------------+------+---------+------------------------+
| +SemiApply      |                                     |             11 |   10 |       0 |                    0/0 |
| |\              +-------------------------------------+----------------+------+---------+------------------------+
| | +Filter       | anon_3:Person                       |             12 |    0 |      10 |                    0/0 |
| | |             +-------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)  | (p)-[anon_2:FRIENDS_WITH]->(anon_3) |             12 |   10 |      51 |                   28/0 |
| | |             +-------------------------------------+----------------+------+---------+------------------------+
| | +Argument     | p                                   |             14 |   14 |       0 |                    0/0 |
| |               +-------------------------------------+----------------+------+---------+------------------------+
| +NodeByLabelScan| p:Person                            |             14 |   14 |      35 |                    1/0 |
+-----------------+-------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 142, total allocated memory: 64
----

======


[[query-plan-anti-semi-apply]]
== Anti Semi Apply
// AntiSemiApply

The `AntiSemiApply` operator tests for the absence of a pattern, and is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.
If the right-hand side operator yields no rows, the row from the left-hand side operator is yielded by the `AntiSemiApply` operator.
This makes `AntiSemiApply` a filtering operator, used for pattern predicates in queries.

.AntiSemiApply
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MATCH
  (me:Person {name: 'me'}),
  (other:Person)
WHERE NOT (me)-[:FRIENDS_WITH]->(other)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-------------------+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| Operator          | Details                                                | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses |
+-------------------+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| +ProduceResults   | `other.name`                                           |              4 |   12 |       0 |                |                    0/0 |
| |                 +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| +Projection       | other.name AS `other.name`                             |              4 |   12 |      12 |                |                    1/0 |
| |                 +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| +AntiSemiApply    |                                                        |              4 |   12 |       0 |                |                    0/0 |
| |\                +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| | +Expand(Into)   | (me)-[anon_2:FRIENDS_WITH]->(other)                    |              1 |    0 |      81 |            896 |                   28/0 |
| | |               +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| | +Argument       | me, other                                              |             14 |   14 |       0 |                |                    0/0 |
| |                 +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| +CartesianProduct |                                                        |             14 |   14 |       0 |                |                    0/0 |
| |\                +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| | +NodeByLabelScan| other:Person                                           |             14 |   14 |      35 |                |                    1/0 |
| |                 +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+
| +NodeIndexSeek    | RANGE INDEX me:Person(name) WHERE name = $autostring_0 |              1 |    1 |       2 |                |                    0/1 |
+-------------------+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+

Total database accesses: 166, total allocated memory: 976
----

======


[[query-plan-anti]]
== Anti
// Anti

The `Anti` operator tests for the absence of a pattern.
If there are incoming rows, the `Anti` operator will yield no rows.
If there are no incoming rows, the `Anti` operator will yield a single row.


.Anti
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=pipelined
MATCH
  (me:Person {name: 'me'}),
  (other:Person)
WHERE NOT (me)-[:FRIENDS_WITH]->(other)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator          | Details                                                | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-------------------+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults   | `other.name`                                           |              4 |   12 |       0 |                |                    0/0 |     0.068 |                     |
| |                 +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +Projection       | other.name AS `other.name`                             |              4 |   12 |      24 |                |                    2/0 |     0.111 | In Pipeline 4       |
| |                 +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Apply            |                                                        |              4 |   12 |       0 |                |                    0/0 |           |                     |
| |\                +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +Anti           |                                                        |              4 |   12 |       0 |           1256 |                    0/0 |     0.084 | In Pipeline 4       |
| | |               +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +Limit          | 1                                                      |             11 |    2 |       0 |            752 |                        |           |                     |
| | |               +--------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Expand(Into)   | (me)-[anon_2:FRIENDS_WITH]->(other)                    |              1 |    2 |      81 |           2632 |                        |           |                     |
| | |               +--------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument       | me, other                                              |             14 |   14 |       0 |           3192 |                    1/0 |     0.904 | Fused in Pipeline 3 |
| |                 +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +CartesianProduct |                                                        |             14 |   14 |       0 |           3672 |                        |     1.466 | In Pipeline 2       |
| |\                +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +NodeByLabelScan| other:Person                                           |             14 |   14 |      35 |                |                        |           |                     |
| |                 +--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeIndexSeek    | RANGE INDEX me:Person(name) WHERE name = $autostring_0 |              1 |    1 |       2 |            120 |                    0/1 |     0.493 | In Pipeline 0       |
+-------------------+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 178, total allocated memory: 6744
----

======


[[query-plan-let-semi-apply]]
== Let Semi Apply
// LetSemiApply

The `LetSemiApply` operator tests for the presence of a pattern predicate, and is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.
When a query contains multiple pattern predicates separated with `OR`, `LetSemiApply` will be used to evaluate the first of these.
It will record the result of evaluating the predicate but will leave any filtering to another operator.
In the example, `LetSemiApply` will be used to check for the presence of the `FRIENDS_WITH` relationship from each person.


.LetSemiApply
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MATCH (other:Person)
WHERE (other)-[:FRIENDS_WITH]->(:Person) OR (other)-[:WORKS_IN]->(:Location)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+--------------------+-----------------------------------------+----------------+------+---------+------------------------+
| Operator           | Details                                 | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+--------------------+-----------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults    | `other.name`                            |             13 |   14 |       0 |                    0/0 |
| |                  +-----------------------------------------+----------------+------+---------+------------------------+
| +Projection        | other.name AS `other.name`              |             13 |   14 |      14 |                    1/0 |
| |                  +-----------------------------------------+----------------+------+---------+------------------------+
| +SelectOrSemiApply | anon_9                                  |             14 |   14 |       0 |                    0/0 |
| |\                 +-----------------------------------------+----------------+------+---------+------------------------+
| | +Filter          | anon_7:Location                         |             14 |    0 |       4 |                    0/0 |
| | |                +-----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)     | (other)-[anon_6:WORKS_IN]->(anon_7)     |             14 |    4 |      15 |                    8/0 |
| | |                +-----------------------------------------+----------------+------+---------+------------------------+
| | +Argument        | other                                   |             14 |    4 |       0 |                    0/0 |
| |                  +-----------------------------------------+----------------+------+---------+------------------------+
| +LetSemiApply      |                                         |             14 |   14 |       0 |                    0/0 |
| |\                 +-----------------------------------------+----------------+------+---------+------------------------+
| | +Filter          | anon_5:Person                           |             12 |    0 |      10 |                    0/0 |
| | |                +-----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)     | (other)-[anon_4:FRIENDS_WITH]->(anon_5) |             12 |   10 |      51 |                   28/0 |
| | |                +-----------------------------------------+----------------+------+---------+------------------------+
| | +Argument        | other                                   |             14 |   14 |       0 |                    0/0 |
| |                  +-----------------------------------------+----------------+------+---------+------------------------+
| +NodeByLabelScan   | other:Person                            |             14 |   14 |      35 |                    1/0 |
+--------------------+-----------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 165, total allocated memory: 64
----

======


[[query-plan-let-anti-semi-apply]]
== Let Anti Semi Apply
// LetAntiSemiApply

The `LetAntiSemiApply` operator tests for the absence of a pattern, and is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.
When a query contains multiple negated pattern predicates -- i.e. predicates separated with `OR`, where at least one predicate contains `NOT` -- `LetAntiSemiApply` will be used to evaluate the first of these.
It will record the result of evaluating the predicate but will leave any filtering to another operator.
In the example, `LetAntiSemiApply` will be used to check for the absence of the `FRIENDS_WITH` relationship from each person.


.LetAntiSemiApply
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MATCH (other:Person)
WHERE NOT ((other)-[:FRIENDS_WITH]->(:Person)) OR (other)-[:WORKS_IN]->(:Location)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}
+--------------------+-----------------------------------------+----------------+------+---------+------------------------+
| Operator           | Details                                 | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+--------------------+-----------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults    | `other.name`                            |             11 |   14 |       0 |                    0/0 |
| |                  +-----------------------------------------+----------------+------+---------+------------------------+
| +Projection        | other.name AS `other.name`              |             11 |   14 |      14 |                    1/0 |
| |                  +-----------------------------------------+----------------+------+---------+------------------------+
| +SelectOrSemiApply | anon_9                                  |             14 |   14 |       0 |                    0/0 |
| |\                 +-----------------------------------------+----------------+------+---------+------------------------+
| | +Filter          | anon_7:Location                         |             14 |    0 |      10 |                    0/0 |
| | |                +-----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)     | (other)-[anon_6:WORKS_IN]->(anon_7)     |             14 |   10 |      38 |                   20/0 |
| | |                +-----------------------------------------+----------------+------+---------+------------------------+
| | +Argument        | other                                   |             14 |   10 |       0 |                    0/0 |
| |                  +-----------------------------------------+----------------+------+---------+------------------------+
| +LetAntiSemiApply  |                                         |             14 |   14 |       0 |                    0/0 |
| |\                 +-----------------------------------------+----------------+------+---------+------------------------+
| | +Filter          | anon_5:Person                           |             12 |    0 |      10 |                    0/0 |
| | |                +-----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)     | (other)-[anon_4:FRIENDS_WITH]->(anon_5) |             12 |   10 |      51 |                   28/0 |
| | |                +-----------------------------------------+----------------+------+---------+------------------------+
| | +Argument        | other                                   |             14 |   14 |       0 |                    0/0 |
| |                  +-----------------------------------------+----------------+------+---------+------------------------+
| +NodeByLabelScan   | p:Person                                |             14 |   14 |      35 |                    1/0 |
+--------------------+-----------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 142, total allocated memory: 64
----

======


[[query-plan-select-or-semi-apply]]
== Select Or Semi Apply
// SelectOrSemiApply

The `SelectOrSemiApply` operator tests for the presence of a pattern predicate and evaluates a predicate,
and is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.
This operator allows for the mixing of normal predicates and pattern predicates that check for the presence of a pattern.
First, the normal expression predicate is evaluated, and, only if it returns `false`, is the costly pattern predicate evaluated.


.SelectOrSemiApply
======

.Query
[source, cypher]
----
PROFILE
MATCH (other:Person)
WHERE other.age > 25 OR (other)-[:FRIENDS_WITH]->(:Person)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+--------------------+-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator           | Details                                 | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+--------------------+-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults    | `other.name`                            |             11 |   10 |       0 |                |                        |           |                     |
| |                  +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Projection        | other.name AS `other.name`              |             11 |   10 |      20 |                |                        |           |                     |
| |                  +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +SelectOrSemiApply | other.age > $autoint_0                  |             14 |   10 |       0 |            392 |                    0/0 |     0.190 | Fused in Pipeline 2 |
| |\                 +-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +Limit           | 1                                       |             14 |   10 |       0 |            752 |                        |           |                     |
| | |                +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Filter          | anon_3:Person                           |             12 |   10 |      20 |                |                        |           |                     |
| | |                +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Expand(All)     | (other)-[anon_2:FRIENDS_WITH]->(anon_3) |             12 |   10 |      37 |                |                        |           |                     |
| | |                +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument        | other                                   |             14 |   14 |       0 |           2168 |                    2/0 |     0.435 | Fused in Pipeline 1 |
| |                  +-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeByLabelScan   | other:Person                            |             14 |   14 |      35 |                |                        |           | Fused in Pipeline 0 |
+--------------------+-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 148, total allocated memory: 2952
----

======


[[query-plan-select-or-anti-semi-apply]]
== Select Or Anti Semi Apply
// SelectOrAntiSemiApply

The `SelectOrAntiSemiApply` operator is used to evaluate `OR` between a predicate and a negative pattern predicate (i.e. a pattern predicate preceded with `NOT`), and is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.
If the predicate returns `true`, the pattern predicate is not tested.
If the predicate returns `false` or `null`, `SelectOrAntiSemiApply` will instead test the pattern predicate.


.SelectOrAntiSemiApply
======

.Query
[source, cypher]
----
PROFILE
MATCH (other:Person)
WHERE other.age > 25 OR NOT (other)-[:FRIENDS_WITH]->(:Person)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------+-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator               | Details                                 | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------------+-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults        | `other.name`                            |              4 |    4 |       0 |                |                        |           |                     |
| |                      +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Projection            | other.name AS `other.name`              |              4 |    4 |       8 |                |                        |           |                     |
| |                      +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +SelectOrAntiSemiApply | other.age > $autoint_0                  |             14 |    4 |       0 |            200 |                    0/0 |     0.155 | Fused in Pipeline 3 |
| |\                     +-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +Anti                |                                         |             14 |    4 |       0 |           1256 |                    0/0 |     0.170 | In Pipeline 2       |
| | |                    +-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +Limit               | 1                                       |              0 |   10 |       0 |            752 |                        |           |                     |
| | |                    +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Filter              | anon_3:Person                           |             12 |   10 |      20 |                |                        |           |                     |
| | |                    +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Expand(All)         | (other)-[anon_2:FRIENDS_WITH]->(anon_3) |             12 |   10 |      37 |                |                        |           |                     |
| | |                    +-----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument            | other                                   |             14 |   14 |       0 |           2168 |                    2/0 |     0.449 | Fused in Pipeline 1 |
| |                      +-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeByLabelScan       | other:Person                            |             14 |   14 |      35 |                |                        |           | Fused in Pipeline 0 |
+------------------------+-----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 136, total allocated memory: 4208
----

======


[[query-plan-let-select-or-semi-apply]]
== Let Select Or Semi Apply
// LetSelectOrSemiApply

The `LetSelectOrSemiApply` operator is planned for pattern predicates that are combined with other predicates using `OR`.
This is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.


.LetSelectOrSemiApply
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MATCH (other:Person)
WHERE (other)-[:FRIENDS_WITH]->(:Person) OR (other)-[:WORKS_IN]->(:Location) OR other.age = 5
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------------+-----------------------------------------+----------------+------+---------+------------------------+
| Operator              | Details                                 | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-----------------------+-----------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults       | `other.name`                            |             13 |   14 |       0 |                    0/0 |
| |                     +-----------------------------------------+----------------+------+---------+------------------------+
| +Projection           | other.name AS `other.name`              |             13 |   14 |      14 |                    1/0 |
| |                     +-----------------------------------------+----------------+------+---------+------------------------+
| +SelectOrSemiApply    | anon_9                                  |             14 |   14 |       0 |                    0/0 |
| |\                    +-----------------------------------------+----------------+------+---------+------------------------+
| | +Filter             | anon_7:Location                         |             14 |    0 |       4 |                    0/0 |
| | |                   +-----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)        | (other)-[anon_6:WORKS_IN]->(anon_7)     |             14 |    4 |      15 |                    8/0 |
| | |                   +-----------------------------------------+----------------+------+---------+------------------------+
| | +Argument           | other                                   |             14 |    4 |       0 |                    0/0 |
| |                     +-----------------------------------------+----------------+------+---------+------------------------+
| +LetSelectOrSemiApply | other.age = $autoint_0                  |             14 |   14 |      14 |                    0/0 |
| |\                    +-----------------------------------------+----------------+------+---------+------------------------+
| | +Filter             | anon_5:Person                           |             12 |    0 |      10 |                    0/0 |
| | |                   +-----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)        | (other)-[anon_4:FRIENDS_WITH]->(anon_5) |             12 |   10 |      51 |                   28/0 |
| | |                   +-----------------------------------------+----------------+------+---------+------------------------+
| | +Argument           | other                                   |             14 |   14 |       0 |                    0/0 |
| |                     +-----------------------------------------+----------------+------+---------+------------------------+
| +NodeByLabelScan      | other:Person                            |             14 |   14 |      35 |                    1/0 |
+-----------------------+-----------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 179, total allocated memory: 64
----

======


[[query-plan-let-select-or-anti-semi-apply]]
== Let Select Or Anti Semi Apply
// LetSelectOrAntiSemiApply

The `LetSelectOrAntiSemiApply` operator is planned for negated pattern predicates -- i.e. pattern predicates preceded with `NOT` -- that are combined with other predicates using `OR`.
This operator is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.


.LetSelectOrAntiSemiApply
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MATCH (other:Person)
WHERE NOT (other)-[:FRIENDS_WITH]->(:Person) OR (other)-[:WORKS_IN]->(:Location) OR other.age = 5
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+---------------------------+-----------------------------------------+----------------+------+---------+------------------------+
| Operator                  | Details                                 | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+---------------------------+-----------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults           | `other.name`                            |             12 |   14 |       0 |                    0/0 |
| |                         +-----------------------------------------+----------------+------+---------+------------------------+
| +Projection               | other.name AS `other.name`              |             12 |   14 |      14 |                    1/0 |
| |                         +-----------------------------------------+----------------+------+---------+------------------------+
| +SelectOrSemiApply        | anon_9                                  |             14 |   14 |       0 |                    0/0 |
| |\                        +-----------------------------------------+----------------+------+---------+------------------------+
| | +Filter                 | anon_7:Location                         |             14 |    0 |      10 |                    0/0 |
| | |                       +-----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)            | (other)-[anon_6:WORKS_IN]->(anon_7)     |             14 |   10 |      38 |                   20/0 |
| | |                       +-----------------------------------------+----------------+------+---------+------------------------+
| | +Argument               | other                                   |             14 |   10 |       0 |                    0/0 |
| |                         +-----------------------------------------+----------------+------+---------+------------------------+
| +LetSelectOrAntiSemiApply | other.age = $autoint_0                  |             14 |   14 |      14 |                    0/0 |
| |\                        +-----------------------------------------+----------------+------+---------+------------------------+
| | +Filter                 | anon_5:Person                           |             12 |    0 |      10 |                    0/0 |
| | |                       +-----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)            | (other)-[anon_4:FRIENDS_WITH]->(anon_5) |             12 |   10 |      51 |                   28/0 |
| | |                       +-----------------------------------------+----------------+------+---------+------------------------+
| | +Argument               | other                                   |             14 |   14 |       0 |                    0/0 |
| |                         +-----------------------------------------+----------------+------+---------+------------------------+
| +NodeByLabelScan          | other:Person                            |             14 |   14 |      35 |                    1/0 |
+---------------------------+-----------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 208, total allocated memory: 64
----

======


[[query-plan-merge]]
== Merge
// ConditionalApply -- changed in 4.3 to Merge.
// AntiConditionalApply -- removed in 4.3 (by Merge).
// Merge

The `Merge` operator will either read or create nodes and/or relationships.

If matches are found it will execute the provided `ON MATCH` operations foreach incoming row.
If no matches are found instead nodes and relationships are created and all `ON CREATE` operations are run.


.Merge
======

.Query
[source, cypher]
----
PROFILE
MERGE (p:Person {name: 'Andy'})
ON MATCH SET p.existed = true
ON CREATE SET p.existed = false
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                                 | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults |                                                                         |              1 |    0 |       0 |                |                        |           |                     |
| |               +-------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult    |                                                                         |              1 |    0 |       0 |                |                        |           |                     |
| |               +-------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Merge          | CREATE (p:Person {name: $autostring_0}), ON MATCH SET p.existed = true, |              1 |    1 |       2 |                |                        |           |                     |
| |               | ON CREATE SET p.existed = false                                         |                |      |         |                |                        |           |                     |
| |               +-------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexSeek  | RANGE INDEX p:Person(name) WHERE name = $autostring_0                   |              1 |    1 |       2 |            120 |                    2/1 |     0.749 | Fused in Pipeline 0 |
+-----------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 4, total allocated memory: 184
----

======


[[query-plan-locking-merge]]
== Locking Merge
// LockingMerge

The `LockingMerge` operator is just like a normal `Merge` but will lock the start and end node when creating a relationship if necessary.


.LockingMerge
======

.Query
[source, cypher]
----
PROFILE
MATCH (s:Person {name: 'me'})
MERGE (s)-[:FRIENDS_WITH]->(s)
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Id | Details                                               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults |  0 |                                                       |              1 |    0 |       0 |                |                        |           |                     |
| |               +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult    |  1 |                                                       |              1 |    0 |       0 |                |                        |           |                     |
| |               +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Apply          |  2 |                                                       |              1 |    1 |       0 |                |                        |           |                     |
| |\              +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +LockingMerge |  3 | CREATE (s)-[anon_0:FRIENDS_WITH]->(s), LOCK(s)        |              1 |    1 |       1 |                |                        |           |                     |
| | |             +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Expand(Into) |  4 | (s)-[anon_0:FRIENDS_WITH]->(s)                        |              0 |    0 |      10 |            904 |                        |           |                     |
| | |             +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument     |  5 | s                                                     |              1 |    3 |       0 |           2280 |                    2/0 |     0.460 | Fused in Pipeline 1 |
| |               +----+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeIndexSeek  |  6 | RANGE INDEX s:Person(name) WHERE name = $autostring_0 |              1 |    1 |       2 |            376 |                    1/0 |     0.211 | In Pipeline 0       |
+-----------------+----+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 15, total allocated memory: 2232
----

======


[[query-plan-roll-up-apply]]
== Roll Up Apply
// RollUpApply

The `RollUpApply` operator is used to execute an expression which takes as input a pattern, and returns a list with content from the matched pattern; for example, when using a pattern expression or pattern comprehension in a query.
This operator is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.


.RollUpApply
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MATCH (p:Person)
RETURN p.name, [(p)-[:WORKS_IN]->(location) | location.name] AS cities
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------+-----------------------------------+----------------+------+---------+------------------------+
| Operator        | Details                           | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-----------------+-----------------------------------+----------------+------+---------+------------------------+
| +ProduceResults | `p.name`, cities                  |             14 |   14 |       0 |                    0/0 |
| |               +-----------------------------------+----------------+------+---------+------------------------+
| +Projection     | p.name AS `p.name`                |             14 |   14 |      14 |                    0/0 |
| |               +-----------------------------------+----------------+------+---------+------------------------+
| +RollUpApply    | cities, anon_0                    |             14 |   14 |       0 |                    0/0 |
| |\              +-----------------------------------+----------------+------+---------+------------------------+
| | +Projection   | location.name AS anon_0           |             15 |   15 |      15 |                    1/0 |
| | |             +-----------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)  | (p)-[anon_2:WORKS_IN]->(location) |             15 |   15 |      53 |                   28/0 |
| | |             +-----------------------------------+----------------+------+---------+------------------------+
| | +Argument     | p                                 |             14 |   14 |       0 |                    0/0 |
| |               +-----------------------------------+----------------+------+---------+------------------------+
| +NodeByLabelScan| p:Person                          |             14 |   14 |      35 |                    1/0 |
+-----------------+-----------------------------------+----------------+------+---------+------------------------+

Total database accesses: 153, total allocated memory: 64
----

======


[[query-plan-argument]]
== Argument
// Argument

The `Argument` operator indicates the variable to be used as an argument to the right-hand side of an xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator.


.Argument
======

.Query
[source, cypher]
----
PROFILE
MATCH (s:Person {name: 'me'})
MERGE (s)-[:FRIENDS_WITH]->(s)
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Id | Details                                               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults |  0 |                                                       |              1 |    0 |       0 |                |                        |           |                     |
| |               +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult    |  1 |                                                       |              1 |    0 |       0 |                |                        |           |                     |
| |               +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Apply          |  2 |                                                       |              1 |    1 |       0 |                |                        |           |                     |
| |\              +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +LockingMerge |  3 | CREATE (s)-[anon_0:FRIENDS_WITH]->(s), LOCK(s)        |              1 |    1 |       1 |                |                        |           |                     |
| | |             +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Expand(Into) |  4 | (s)-[anon_0:FRIENDS_WITH]->(s)                        |              0 |    0 |      10 |            904 |                        |           |                     |
| | |             +----+-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument     |  5 | s                                                     |              1 |    3 |       0 |           2280 |                    2/0 |     0.460 | Fused in Pipeline 1 |
| |               +----+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeIndexSeek  |  6 | RANGE INDEX s:Person(name) WHERE name = $autostring_0 |              1 |    1 |       2 |            376 |                    1/0 |     0.211 | In Pipeline 0       |
+-----------------+----+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 15, total allocated memory: 2232
----

======



// --- expand operators ---

[[query-plan-expand-all]]
== Expand All
// Expand(All)

Given a start node, and depending on the pattern relationship, the `Expand(All)` operator will traverse incoming or outgoing relationships.


.Expand(All)
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person {name: 'me'})-[:FRIENDS_WITH]->(fof)
RETURN fof
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | fof                                                   |              1 |    2 |       0 |                |                        |           |                     |
| |               +-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Expand(All)    | (p)-[anon_0:FRIENDS_WITH]->(fof)                      |              1 |    2 |       5 |                |                        |           |                     |
| |               +-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexSeek  | RANGE INDEX p:Person(name) WHERE name = $autostring_0 |              1 |    1 |       2 |            120 |                    4/1 |     1.137 | Fused in Pipeline 0 |
+-----------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 7, total allocated memory: 184
----

======


[[query-plan-expand-into]]
== Expand Into
// Expand(Into)

When both the start and end node have already been found, the `Expand(Into)` operator is used to find all relationships connecting the two nodes.
As both the start and end node of the relationship are already in scope, the node with the smallest degree will be used.
This can make a noticeable difference when dense nodes appear as end points.


.Expand(Into)
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person {name: 'me'})-[:FRIENDS_WITH]->(fof)-->(p)
RETURN fof
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | fof                                                   |              0 |    0 |       0 |                |                        |           |                     |
| |               +-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter         | not anon_1 = anon_0                                   |              0 |    0 |       0 |                |                        |           |                     |
| |               +-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Expand(Into)   | (p)-[anon_0:FRIENDS_WITH]->(fof)                      |              0 |    0 |       6 |            896 |                        |           |                     |
| |               +-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Expand(All)    | (p)<-[anon_1]-(fof)                                   |              1 |    1 |       5 |                |                        |           |                     |
| |               +-------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexSeek  | RANGE INDEX p:Person(name) WHERE name = $autostring_0 |              1 |    1 |       2 |            120 |                    4/1 |     0.546 | Fused in Pipeline 0 |
+-----------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 13, total allocated memory: 976
----

======


[[query-plan-optional-expand-all]]
== Optional Expand All
// OptionalExpand(All)

The `OptionalExpand(All)` operator is analogous to xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-expand-all[Expand(All)], apart from when no relationships match the direction, type and property predicates.
In this situation, `OptionalExpand(all)` will return a single row with the relationship and end node set to `null`.


.OptionalExpand(All)
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
OPTIONAL MATCH (p)-[works_in:WORKS_IN]->(l)
  WHERE works_in.duration > 180
RETURN p, l
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+----------------------+-------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator             | Details                                                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+----------------------+-------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults      | p, l                                                              |             14 |   15 |       1 |                |                        |           |                     |
| |                    +-------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +OptionalExpand(All) | (p)-[works_in:WORKS_IN]->(l) WHERE works_in.duration > $autoint_0 |             14 |   15 |      53 |                |                        |           |                     |
| |                    +-------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan     | p:Person                                                          |             14 |   14 |      15 |            120 |                    5/0 |     1,233 | Fused in Pipeline 0 |
+----------------------+-------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 125, total allocated memory: 184
----

======


[[query-plan-optional-expand-into]]
== Optional Expand Into
// OptionalExpand(Into)

The `OptionalExpand(Into)` operator is analogous to xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-expand-into[Expand(Into)], apart from when no matching relationships are found.
In this situation, `OptionalExpand(Into)` will return a single row with the relationship and end node set to `null`.
As both the start and end node of the relationship are already in scope, the node with the smallest degree will be used.
This can make a noticeable difference when dense nodes appear as end points.


.OptionalExpand(Into)
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)-[works_in:WORKS_IN]->(l)
OPTIONAL MATCH (l)-->(p)
RETURN p
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator              | Details                      | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------------+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults       | p                            |             15 |   15 |       0 |                |                        |           |                     |
| |                     +------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +OptionalExpand(Into) | (l)-[anon_0]->(p)            |             15 |   15 |     105 |           3360 |                        |           |                     |
| |                     +------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Expand(All)          | (p)-[works_in:WORKS_IN]->(l) |             15 |   15 |      39 |                |                        |           |                     |
| |                     +------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan      | p:Person                     |             14 |   14 |      15 |            120 |                    7/0 |     3,925 | Fused in Pipeline 0 |
+-----------------------+--- --------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 215, total allocated memory: 3440
----

======


[[query-plan-varlength-expand-all]]
== VarLength Expand All
// VarLengthExpand(All)

Given a start node, the `VarLengthExpand(All)` operator will traverse variable-length and quantified relationships.


.VarLengthExpand(All)
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)-[:FRIENDS_WITH *1..2]-(q:Person)
RETURN p, q
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator              | Details                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults       | p, q                              |             40 |   48 |       0 |                |                        |           |                     |
| |                     +-----------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter               | q:Person                          |             40 |   48 |      96 |                |                        |           |                     |
| |                     +-----------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +VarLengthExpand(All) | (p)-[anon_0:FRIENDS_WITH*..2]-(q) |             40 |   48 |     151 |            128 |                        |           |                     |
| |                     +-----------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan      | p:Person                          |             14 |   14 |      15 |            120 |                    6/0 |    10,457 | Fused in Pipeline 0 |
+-----------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 318, total allocated memory: 208
----

======


[[query-plan-varlength-expand-into]]
== VarLength Expand Into
// VarLengthExpand(Into)

When both the start and end node have already been found, the `VarLengthExpand(Into)` operator is used to find all variable-length and quantified relationships connecting the two nodes.


.VarLengthExpand(Into)
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)-[:FRIENDS_WITH *1..2]-(p:Person)
RETURN p
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator               | Details                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults        | p                                 |              3 |    4 |       0 |                |                        |           |                     |
| |                      +-----------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +VarLengthExpand(Into) | (p)-[anon_0:FRIENDS_WITH*..2]-(p) |              3 |    4 |     151 |            128 |                        |           |                     |
| |                      +-----------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan       | p:Person                          |             14 |   14 |      15 |            120 |                    6/0 |     0,797 | Fused in Pipeline 0 |
+------------------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+


Total database accesses: 222, total allocated memory: 192
----

======


[[query-plan-varlength-expand-pruning]]
== VarLength Expand Pruning
// VarLengthExpand(Pruning)

Given a start node, the `VarLengthExpand(Pruning)` operator will traverse variable-length and quantified relationships much like the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-varlength-expand-all[`VarLengthExpand(All)`] operator.
However, as an optimization, some paths will not be explored if they are guaranteed to produce an end node that has already been found (by means of a previous path traversal).

This kind of expand is only planned when:

* The individual paths are not of interest.
* The relationships have an upper bound.

The `VarLengthExpand(Pruning)` operator guarantees that all the end nodes produced will be unique.


.VarLengthExpand(Pruning)
======
.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)-[:FRIENDS_WITH *3..4]-(q:Person)
RETURN DISTINCT p, q
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------------+----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------+
| Operator                  | Id | Details                      | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by | Pipeline      |
+---------------------------+----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------+
| +ProduceResults           |  0 | p, q                         |              0 |    0 |       0 |                |                    0/0 |     0.005 |            |               |
| |                         +----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+            |               |
| +OrderedDistinct          |  1 | p, q                         |              0 |    0 |       0 |             40 |                    0/0 |     0.014 |            |               |
| |                         +----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+            |               |
| +Filter                   |  2 | q:Person                     |              0 |    0 |       0 |                |                    0/0 |     0.014 |            |               |
| |                         +----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+            |               |
| +VarLengthExpand(Pruning) |  3 | (p)-[:FRIENDS_WITH*3..4]-(q) |              1 |    0 |      15 |            400 |                        |           |            | In Pipeline 1 |
| |                         +----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+            +---------------+
| +NodeByLabelScan          |  4 | p:Person                     |             14 |   14 |      15 |            120 |                    1/0 |     0.020 | p ASC      | In Pipeline 0 |
+---------------------------+----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------+

Total database accesses: 30, total allocated memory: 480
----

======


[[query-plan-breadth-first-varlength-expand-pruning-bfs]]
== Breadth First VarLength Expand Pruning
// VarLengthExpand(Pruning,BFS)
// New in 5.0

Given a start node, the `VarLengthExpand(Pruning,BFS)` operator traverses variable-length and quantified relationships much like the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-varlength-expand-all[`VarLengthExpand(All)`] operator.
However, as an optimization, it instead performs a breadth-first search (BFS) and while expanding, some paths are not explored if they are guaranteed to produce an end node that has already been found (by means of a previous path traversal).
This is only used in cases where the individual paths are not of interest.

This kind of expand is only planned when:

* The individual paths are not of interest.
* The lower bound is either `0` or `1` (default).

This operator guarantees that all the end nodes produced are unique.

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)-[:FRIENDS_WITH *..4]-(q:Person)
RETURN DISTINCT p, q
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------------------+----+-----------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| Operator                      | Id | Details                     | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by | Pipeline            |
+-------------------------------+----+-----------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +ProduceResults               |  0 | p, q                        |             12 |    0 |       0 |                |                    0/0 |     0.019 |            |                     |
| |                             +----+-----------------------------+----------------+------+---------+----------------+------------------------+-----------+            |                     |
| +OrderedDistinct              |  1 | p, q                        |             12 |    0 |       0 |             40 |                    0/0 |     0.558 |            | In Pipeline 0       |
| |                             +----+-----------------------------+----------------+------+---------+----------------+------------------------+-----------+            +---------------------+
| +Filter                       |  2 | q:Person                    |             13 |    0 |       0 |                |                        |           |            |                     |
| |                             +----+-----------------------------+----------------+------+---------+----------------+                        |           |            |                     |
| +VarLengthExpand(Pruning,BFS) |  3 | (p)-[:FRIENDS_WITH*..4]-(q) |             13 |    0 |       0 |              0 |                        |           |            |                     |
| |                             +----+-----------------------------+----------------+------+---------+----------------+                        |           |            |                     |
| +NodeByLabelScan              |  4 | p:Person                    |             10 |    0 |       1 |            120 |                    1/0 |     0.155 | p ASC      | Fused in Pipeline 0 |
+-------------------------------+----+-----------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+

Total database accesses: 1, total allocated memory: 200
----

[[query-plan-repeat]]
== Repeat (Trail)
// Repeat(Trail)
_This feature was introduced in Neo4j 5.9._

Given a start node, the `Repeat(Trail)` operator will traverse xref::patterns/concepts.adoc#quantified-path-patterns[quantified path patterns] that cannot be solved with the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-varlength-expand-all[`VarLengthExpand(All)`] operator.
Similar to an xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[`Apply`] operator, it takes a single row from the left-hand side and applies the operators on the right-hand side.
In contrast to `Apply`, however, it repeatedly applies these operators in accordance with the quantifiers on the quantified path pattern.
In the following example, the operator will repeat twice and produce rows for both repetitions.

.Repeat(Trail)
======

.Query
[source, cypher]
----
PROFILE
MATCH (me:Person) ((a)-[:FRIENDS_WITH]-(b) WHERE a.name <> b.name){1,2} (friend:Person)
RETURN me, friend
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+----+-----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Id | Details                                             | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+----+-----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  |  0 | me, friend                                          |             15 |   48 |       0 |                |                        |           |                     |
| |                +----+-----------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter          |  1 | friend:Person                                       |             15 |   48 |      96 |                |                        |           |                     |
| |                +----+-----------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NullifyMetadata |  7 |                                                     |             15 |   48 |       0 |                |                        |           |                     |
| |                +----+-----------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Repeat(Trail)   |  2 | (me) (...){1, 2} (friend)                           |             15 |   48 |       0 |          16784 |                    0/0 |     1.146 | Fused in Pipeline 2 |
| |\               +----+-----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +Filter        |  3 | not a.name = b.name AND isRepeatTrailUnique(anon_2) |              5 |   48 |     216 |                |                        |           |                     |
| | |              +----+-----------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Expand(All)   |  4 | (a)-[anon_2:FRIENDS_WITH]-(b)                       |             10 |   72 |     151 |                |                        |           |                     |
| | |              +----+-----------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument      |  5 | a                                                   |             14 |   38 |       0 |           3112 |                    3/0 |     6.279 | Fused in Pipeline 1 |
| |                +----+-----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeByLabelScan |  6 | me:Person                                           |             14 |   14 |      15 |            376 |                    1/0 |     3.970 | In Pipeline 0       |
+------------------+----+-----------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 318, total allocated memory: 208
----

======

[[query-plan-assert-same-node]]
== Assert Same Node
// AssertSameNode

The `AssertSameNode` operator is used to ensure that no node property uniqueness constraints are violated in the slotted and interpreted runtime.
The example looks for the presence of a team node with the supplied name and id, and if one does not exist, it will be created.
Owing to the existence of two node property uniqueness constraints on `:Team(name)` and `:Team(id)`, any node that would be found by the `UniqueIndexSeek` operator must be the very same node or the constraints would be violated.


.AssertSameNode
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MERGE (t:Team {name: 'Engineering', id: 42})
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+---------------------------------+-------------------------------------------------------+----------------+------+---------+------------------------+
| Operator                        | Details                                               | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+---------------------------------+-------------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults                 |                                                       |              1 |    0 |       0 |                    0/0 |
| |                               +-------------------------------------------------------+----------------+------+---------+------------------------+
| +EmptyResult                    |                                                       |              1 |    0 |       0 |                    0/0 |
| |                               +-------------------------------------------------------+----------------+------+---------+------------------------+
| +Merge                          | CREATE (t:Team {name: $autostring_0, id: $autoint_1}) |              1 |    1 |       0 |                    0/0 |
| |                               +-------------------------------------------------------+----------------+------+---------+------------------------+
| +AssertSameNode                 | t                                                     |              0 |    1 |       0 |                    0/0 |
| |\                              +-------------------------------------------------------+----------------+------+---------+------------------------+
| | +NodeUniqueIndexSeek(Locking) | UNIQUE t:Team(id) WHERE id = $autoint_1               |              1 |    1 |       1 |                    0/1 |
| |                               +-------------------------------------------------------+----------------+------+---------+------------------------+
| +NodeUniqueIndexSeek(Locking)   | UNIQUE t:Team(name) WHERE name = $autostring_0        |              1 |    1 |       1 |                    0/1 |
+---------------------------------+-------------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 2, total allocated memory: 64
----

======


[[query-plan-assert-same-relationship]]
== Assert Same Relationship
// AssertSameRelationship

_This feature was introduced in Neo4j 5.8._

The `AssertSameRelationship` operator is used to ensure that no relationship property uniqueness constraints are violated in the slotted and interpreted runtime.
The example looks for the presence of a `WORKS_IN` relationship with the supplied  `id` and `badgeNumber`.
If it can't be found, then it will be created.
Owing to the existence of two property uniqueness constraints on `:WORKS_IN(id)` and `:WORKS_IN(badgeNumber)`, any relationship that would be found by the `DirectedRelationshipUniqueIndexSeek` operator must be the very same relationship or the constraints would be violated.


.AssertSameRelationship
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MERGE (person)-[work:WORKS_IN {id: 0, badgeNumber: 4332}]->(location)
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-------------------------------------------------+----+------------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| Operator                                        | Id | Details                                                                                              | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-------------------------------------------------+----+------------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults                                 |  0 |                                                                                                      |              1 |    0 |       0 |                    0/0 |
| |                                               +----+------------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +EmptyResult                                    |  1 |                                                                                                      |              1 |    0 |       0 |                    0/0 |
| |                                               +----+------------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +Merge                                          |  2 | CREATE (person), (location), (person)-[work:WORKS_IN {id: $autoint_0, badgeNumber: $autoint_1}]->(lo |              1 |    1 |       0 |                    0/0 |
| |                                               |    | cation)                                                                                              |                |      |         |                        |
| |                                               +----+------------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +AssertSameRelationship                         |  3 | work                                                                                                 |              0 |    1 |       0 |                    0/0 |
| |\                                              +----+------------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| | +DirectedRelationshipUniqueIndexSeek(Locking) |  4 | RANGE INDEX (person)-[work:WORKS_IN(badgeNumber)]->(location) WHERE badgeNumber = $autoint_1         |              1 |    1 |       1 |                    0/1 |
| |                                               +----+------------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +DirectedRelationshipUniqueIndexSeek(Locking)   |  5 | RANGE INDEX (person)-[work:WORKS_IN(id)]->(location) WHERE id = $autoint_0                           |              1 |    1 |       1 |                    1/1 |
+-------------------------------------------------+----+------------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 2, total allocated memory: 64
----

======


// DropResult -- removed in 4.3


[[query-plan-empty-result]]
== Empty Result
// EmptyResult

The `EmptyResult` operator eagerly loads all incoming data and discards it.


.EmptyResult
======

.Query
[source, cypher]
----
PROFILE
CREATE (:Person)
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+-----------------+----------------+------+---------+------------------------+-----------+---------------------+
| Operator        | Details         | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+-----------------+----------------+------+---------+------------------------+-----------+---------------------+
| +ProduceResults |                 |              1 |    0 |       0 |                        |           |                     |
| |               +-----------------+----------------+------+---------+                        |           |                     |
| +EmptyResult    |                 |              1 |    0 |       0 |                        |           |                     |
| |               +-----------------+----------------+------+---------+                        |           |                     |
| +Create         | (anon_0:Person) |              1 |    1 |       1 |                    0/0 |     0.000 | Fused in Pipeline 0 |
+-----------------+-----------------+----------------+------+---------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 184
----

======


[[query-plan-produce-results]]
== Produce Results
// ProduceResults

The `ProduceResults` operator prepares the result so that it is consumable by the user, such as transforming internal values to user values.
It is present in every single query that returns data to the user, and has little bearing on performance optimisation.


.ProduceResults
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
RETURN n
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | n       |             35 |   35 |       0 |                |                        |           |                     |
| |               +---------+----------------+------+---------+----------------+                        |           |                     |
| +AllNodesScan   | n       |             35 |   35 |      36 |            120 |                    3/0 |     0.508 | Fused in Pipeline 0 |
+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 36, total allocated memory: 184
----

======


[[query-plan-load-csv]]
== Load CSV
// LoadCSV

The `LoadCSV` operator loads data from a CSV source into the query.
It is used whenever the xref::clauses/load-csv.adoc[LOAD CSV] clause is used in a query.


.LoadCSV
======

.Query
[source, cypher]
----
PROFILE
LOAD CSV FROM 'https://neo4j.com/docs/cypher-refcard/3.3/csv/artists.csv' AS line
RETURN line
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| Operator        | Details | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline      |
+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +ProduceResults | line    |             10 |    4 |       0 |                |                    0/0 |     0.210 |               |
| |               +---------+----------------+------+---------+----------------+------------------------+-----------+               |
| +LoadCSV        | line    |             10 |    4 |       0 |             72 |                        |           | In Pipeline 1 |
+-----------------+---------+----------------+------+---------+----------------+------------------------+-----------+---------------+

Total database accesses: 0, total allocated memory: 184
----

======


[[execution-plans-operators-hash-join-general]]
== Hash joins in general

Hash joins have two inputs: the build input and probe input.
The query planner assigns these roles so that the smaller of the two inputs is the build input.
The build input is pulled in eagerly, and is used to build a probe table.
Once this is complete, the probe table is checked for each row coming from the probe input side.

In query plans, the build input is always the left operator, and the probe input the right operator.

There are four hash join operators:

* xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-node-hash-join[NodeHashJoin]
* xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-value-hash-join[ValueHashJoin]
* xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-node-left-right-outer-hash-join[NodeLeftOuterHashJoin]
* xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-node-left-right-outer-hash-join[NodeRightOuterHashJoin]


[[query-plan-node-hash-join]]
== Node Hash Join
// NodeHashJoin

The `NodeHashJoin` operator is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#execution-plans-operators-hash-join-general[hash join].
`NodeHashJoin` executes the hash join on node ids.
As primitive types and arrays can be used, it can be done very efficiently.


.NodeHashJoin
======
.Query
[source, cypher]
----
PROFILE
MATCH (bob:Person {name: 'Bob'})-[:WORKS_IN]->(loc)<-[:WORKS_IN]-(matt:Person {name: 'Mattias'})
USING JOIN ON loc
RETURN loc.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Details                                                  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  | `loc.name`                                               |             10 |    0 |       0 |                |                    0/0 |     0.000 |                     |
| |                +----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +Projection      | loc.name AS `loc.name`                                   |             10 |    0 |       0 |                |                    0/0 |     0.000 |                     |
| |                +----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +Filter          | not anon_0 = anon_1                                      |             10 |    0 |       0 |                |                    0/0 |     0.000 |                     |
| |                +----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +NodeHashJoin    | loc                                                      |             10 |    0 |       0 |           3688 |                        |     0.053 | In Pipeline 2       |
| |\               +----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +Expand(All)   | (matt)-[anon_1:WORKS_IN]->(loc)                          |             19 |    0 |       0 |                |                        |           |                     |
| | |              +----------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +NodeIndexSeek | RANGE INDEX matt:Person(name) WHERE name = $autostring_1 |              1 |    0 |       1 |            120 |                    1/0 |     0.288 | Fused in Pipeline 1 |
| |                +----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Expand(All)     | (bob)-[anon_0:WORKS_IN]->(loc)                           |             19 |    1 |       4 |                |                        |           |                     |
| |                +----------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexSeek   | RANGE INDEX bob:Person(name) WHERE name = $autostring_0  |              1 |    1 |       2 |            120 |                    3/0 |     0.556 | Fused in Pipeline 0 |
+------------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 7, total allocated memory: 3888
----

======


[[query-plan-value-hash-join]]
== Value Hash Join
// ValueHashJoin

The `ValueHashJoin` operator is a variation of the xref::planning-and-tuning/operators/operators-detail.adoc#execution-plans-operators-hash-join-general[hash join].
This operator allows for arbitrary values to be used as the join key.
It is most frequently used to solve predicates of the form: `n.prop1 = m.prop2` (i.e. equality predicates between two property columns).


.ValueHashJoin
======

.Query
[source, cypher]
----
PROFILE
MATCH
  (p:Person),
  (q:Person)
WHERE p.age = q.age
RETURN p, q
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator          | Details       | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-------------------+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults    | p, q         |             10 |    0 |       0 |                |                    0/0 |     0.000 |                     |
| |                 +---------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +ValueHashJoin     | p.age = q.age|             10 |    0 |       0 |            344 |                        |           | In Pipeline 2       |
| |\                +---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +NodeByLabelScan| q:Person      |             15 |    0 |       0 |            120 |                    0/0 |     0,000 | In Pipeline 1       |
| |                 +---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeByLabelScan  | p:Person      |             15 |   15 |      16 |            120 |                    1/0 |     0,211 | In Pipeline 0       |
+-------------------+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 71, total allocated memory: 664
----

======


[[query-plan-node-left-right-outer-hash-join]]
== Node Left/Right Outer Hash Join
// NodeLeftOuterHashJoin
// NodeRightOuterHashJoin

The `NodeLeftOuterHashJoin` and `NodeRightOuterHashJoin` operators are variations of the xref::planning-and-tuning/operators/operators-detail.adoc#execution-plans-operators-hash-join-general[hash join].
The query below can be planned with either a left or a right outer join.
The decision depends on the cardinalities of the left-hand and right-hand sides; i.e. how many rows would be returned, respectively, for `(a:Person)` and `(a)-->(b:Person)`.
If `(a:Person)` returns fewer results than `(a)-->(b:Person)`, a left outer join -- indicated by `NodeLeftOuterHashJoin` -- is planned.
On the other hand, if `(a:Person)` returns more results than `(a)-->(b:Person)`, a right outer join -- indicated by `NodeRightOuterHashJoin` -- is planned instead.


.NodeRightOuterHashJoin
======

.Query
[source, cypher]
----
PROFILE
MATCH (a:Person)
OPTIONAL MATCH (a)-->(b:Person)
USING JOIN ON a
RETURN a.name, b.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------------+------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                | Details                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-------------------------+------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults         | `a.name`, `b.name`                                   |             14 |   16 |       0 |                |                    0/0 |     0.102 |                     |
| |                       +------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +Projection             | cache[a.name] AS `a.name`, cache[b.name] AS `b.name` |             14 |   16 |       8 |                |                    0/0 |     0.055 |                     |
| |                       +------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +NodeRightOuterHashJoin | a                                                    |             14 |   16 |       0 |           4232 |                        |     0.269 | In Pipeline 2       |
| |\                      +------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +NodeByLabelScan      | a:Person                                             |             15 |   15 |      16 |            120 |                    1/0 |     0,049 | In Pipeline 1       |
| |                       +------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +CacheProperties        | cache[b.name], cache[a.name]                         |             13 |   13 |      39 |                |                        |           |                     |
| |                       +------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Expand(All)            | (b)<-[anon_0]-(a)                                    |             13 |   13 |      55 |                |                        |           |                     |
| |                       +------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan        | b:Person                                             |             15 |   15 |      16 |            120 |                    5/0 |     1,150 | Fused in Pipeline 0 |
+-------------------------+------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 211, total allocated memory: 4312
----

======


[[query-plan-triadic-selection]]
== Triadic Selection
// TriadicSelection

The `TriadicSelection` operator is used to solve triangular queries, such as the very common 'find my friend-of-friends that are not already my friend'.
It does so by putting all the friends into a set, and uses the set to check if the friend-of-friends are already connected to me.
The example finds the names of all friends of my friends that are not already my friends.


.TriadicSelection
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
MATCH (me:Person)-[:FRIENDS_WITH]-()-[:FRIENDS_WITH]-(other)
WHERE NOT (me)-[:FRIENDS_WITH]-(other)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-------------------+----------------------------------------+----------------+------+---------+------------------------+
| Operator          | Details                                | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-------------------+----------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults   | `other.name`                           |              4 |   24 |       0 |                    0/0 |
| |                 +----------------------------------------+----------------+------+---------+------------------------+
| +Projection       | other.name AS `other.name`             |              4 |   24 |      24 |                    1/0 |
| |                 +----------------------------------------+----------------+------+---------+------------------------+
| +Filter           | not anon_2 = anon_4                    |             16 |   24 |       0 |                    0/0 |
| |                 +----------------------------------------+----------------+------+---------+------------------------+
| +TriadicSelection | WHERE NOT (me)--(other)                |              4 |   24 |       0 |                    0/0 |
| |\                +----------------------------------------+----------------+------+---------+------------------------+
| | |               +----------------------------------------+----------------+------+---------+------------------------+
| | +Expand(All)    | (anon_3)-[anon_4:FRIENDS_WITH]-(other) |             16 |   48 |      98 |                   48/0 |
| | |               +----------------------------------------+----------------+------+---------+------------------------+
| | +Argument       | anon_3, anon_2                         |             24 |   24 |       0 |                    0/0 |
| |                 +----------------------------------------+----------------+------+---------+------------------------+
| +Expand(All)      | (me)-[anon_2:FRIENDS_WITH]-(anon_3)    |             24 |   24 |      53 |                   28/0 |
| |                 +----------------------------------------+----------------+------+---------+------------------------+
| +NodeByLabelScan  | me:Person                              |             15 |   15 |      16 |                    1/0 |
+-------------------+----------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 246, total allocated memory: 64
----

======


[[query-plan-triadic-build]]
== Triadic Build
// TriadicBuild

The `TriadicBuild` operator is used in conjunction with `TriadicFilter` to solve triangular queries, such as the very common 'find my friend-of-friends that are not already my friend'.
These two operators are specific to Pipelined runtime and together perform the same logic as `TriadicSelection` does for other runtimes.
`TriadicBuild` builds a set of all friends, which is later used by `TriadicFilter`.
The example finds the names of all friends of my friends that are not already my friends.


.TriadicBuild
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=pipelined
MATCH (me:Person)-[:FRIENDS_WITH]-()-[:FRIENDS_WITH]-(other)
WHERE NOT (me)-[:FRIENDS_WITH]-(other)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | `other.name`                           |              4 |   24 |       0 |                |                    0/0 |     0.133 |                     |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +Projection     | other.name AS `other.name`             |              4 |   24 |      48 |                |                    2/0 |     0.056 |                     |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Filter         | not anon_2 = anon_4                    |             16 |   24 |       0 |                |                        |           |                     |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +TriadicFilter  | WHERE NOT (me)--(other)                |              4 |   24 |       0 |           4136 |                    0/0 |     0.195 | In Pipeline 3       |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Apply          |                                        |             16 |   24 |       0 |                |                    0/0 |           |                     |
| |\              +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | |             +----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Expand(All)  | (anon_3)-[anon_4:FRIENDS_WITH]-(other) |             16 |   48 |      98 |                |                        |           |                     |
| | |             +----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument     | anon_3, anon_2                         |             24 |   24 |       0 |           4200 |                    0/0 |     0.397 | Fused in Pipeline 2 |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +TriadicBuild   | (me)--(anon_3)                         |             24 |   24 |       0 |            888 |                    0/0 |     1.427 | In Pipeline 1       |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Expand(All)    | (me)-[anon_2:FRIENDS_WITH]-(anon_3)    |             24 |   24 |      39 |                |                        |           |                     |
| |               +----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan| me:Person                               |             15 |   15 |      16 |            120 |                    3/0 |     0,200 | Fused in Pipeline 0 |
+-----------------+----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 256, total allocated memory: 7376
----

======


[[query-plan-triadic-filter]]
== Triadic Filter
// TriadicFilter

The `TriadicFilter` operator is used in conjunction with `TriadicBuild` to solve triangular queries, such as the very common 'find my friend-of-friends that are not already my friend'.
These two operators are specific to Pipelined runtime and together perform the same logic as `TriadicSelection` does for other runtimes.
`TriadicFilter` uses a set of friends previously built by `TriadicBuild` to check if the friend-of-friends are already connected to me.
The example finds the names of all friends of my friends that are not already my friends.


.TriadicFilter
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=pipelined
MATCH (me:Person)-[:FRIENDS_WITH]-()-[:FRIENDS_WITH]-(other)
WHERE NOT (me)-[:FRIENDS_WITH]-(other)
RETURN other.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | `other.name`                           |              4 |   24 |       0 |                |                    0/0 |     0.189 |                     |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +Projection     | other.name AS `other.name`             |              4 |   24 |      48 |                |                    2/0 |     0.381 |                     |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Filter         | not anon_2 = anon_4                    |             16 |   24 |       0 |                |                        |           |                     |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +TriadicFilter  | WHERE NOT (me)--(other)                |              4 |   24 |       0 |           4136 |                    0/0 |     0.685 | In Pipeline 3       |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Apply          |                                        |             16 |   24 |       0 |                |                    0/0 |           |                     |
| |\              +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | |             +----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Expand(All)  | (anon_3)-[anon_4:FRIENDS_WITH]-(other) |             16 |   48 |      98 |                |                        |           |                     |
| | |             +----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument     | anon_3, anon_2                         |             24 |   24 |       0 |           4200 |                    0/0 |     0.496 | Fused in Pipeline 2 |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +TriadicBuild   | (me)--(anon_3)                         |             24 |   24 |       0 |            888 |                    0/0 |     3.268 | In Pipeline 1       |
| |               +----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Expand(All)    | (me)-[anon_2:FRIENDS_WITH]-(anon_3)    |             24 |   24 |      39 |                |                        |           |                     |
| |               +----------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan| me:Person                              |             15 |   15 |      16 |            120 |                    3/0 |     0,481 | Fused in Pipeline 0 |
+-----------------+----------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 256, total allocated memory: 7376
----

======


[[query-plan-cartesian-product]]
== Cartesian Product
// CartesianProduct

The `CartesianProduct` operator produces a cartesian product of the two inputs -- each row coming from the left child operator will be combined with all the rows from the right child operator.
`CartesianProduct` generally exhibits bad performance and ought to be avoided if possible.


.CartesianProduct
======

.Query
[source, cypher]
----
PROFILE
MATCH
  (p:Person),
  (t:Team)
RETURN p, t
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+--------------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator           | Details  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+--------------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults    | p, t     |            140 |  140 |       0 |                |                    2/0 |     1.917 |                     |
| |                  +----------+----------------+------+---------+----------------+------------------------+-----------+                     |
| +CartesianProduct  |          |            140 |  140 |       0 |           1736 |                        |     1.209 | In Pipeline 2       |
| |\                 +----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +NodeByLabelScan | t:Team   |             10 |   10 |      11 |            136 |                    1/0 |     1,145 | In Pipeline 1       |
| |                  +----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +NodeByLabelScan   | p:Person |             15 |   15 |      16 |            120 |                    1/0 |     0,409 | In Pipeline 0       |
+--------------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 142, total allocated memory: 1816
----

======


[[query-plan-foreach]]
== Foreach
// Foreach

The `Foreach` operator executes a nested loop between the left child operator and the right child operator.
In an analogous manner to the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-apply[Apply] operator, it takes a row from the left-hand side and, using the xref::planning-and-tuning/operators/operators-detail.adoc#query-plan-argument[Argument] operator, provides it to the operator tree on the right-hand side.
`Foreach` will yield all the rows coming in from the left-hand side; all results from the right-hand side are pulled in and discarded.


.Foreach
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
FOREACH (value IN [1,2,3] | CREATE (:Person {age: value}))
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------+---------------------------------------------------------+----------------+------+---------+------------------------+
| Operator        | Details                                                 | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-----------------+---------------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults |                                                         |              1 |    0 |       0 |                    0/0 |
| |               +---------------------------------------------------------+----------------+------+---------+------------------------+
| +EmptyResult    |                                                         |              1 |    0 |       0 |                    0/0 |
| |               +---------------------------------------------------------+----------------+------+---------+------------------------+
| +Foreach        | value IN [1, 2, 3], CREATE (anon_0:Person {age: value}) |              1 |    1 |       9 |                    0/0 |
+-----------------+---------------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 9, total allocated memory: 64
----

======


[[query-plan-eager]]
== Eager
// Eager

The `Eager` operator causes all preceding operators to execute fully, for the whole dataset, before continuing execution.
This is done to ensure isolation between parts of the query plan that might otherwise affect each other.

Values from the graph are fetched in a lazy manner; i.e. a pattern matching might not be fully exhausted before updates are applied.
To maintain correct semantics, the query planner will insert `Eager` operators into the query plan to prevent updates from influencing pattern matching, or other read operations.
This scenario is exemplified by the query below, where the `DELETE` clause would otherwise influence both the `MATCH` clause and the `MERGE` clause.
For more information on how the `Eager` operator can ensure correct semantics, see the section on xref::clauses/clause_composition.adoc[Clause composition].

The `Eager` operator can cause high memory usage when importing data or migrating graph structures.
In such cases, the operations should be split into simpler steps; e.g. importing nodes and relationships separately.
Alternatively, the records to be updated can be returned, followed by an update statement.


.Eager
======

.Query
[source, cypher]
----
PROFILE
MATCH (a:Person {name: 'me'}), (b:Person {name: 'Bob'})
DETACH DELETE a, b
MERGE (:Person {name: 'me'})
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------+----+------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator            | Id | Details                                                    | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------+----+------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults     |  0 |                                                            |              1 |    0 |       0 |                |                        |           |                     |
| |                   +----+------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult        |  1 |                                                            |              1 |    0 |       0 |                |                        |           |                     |
| |                   +----+------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Apply              |  2 |                                                            |              1 |    1 |       0 |                |                        |           |                     |
| |\                  +----+------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Merge            |  3 | CREATE (anon_0:Person {name: $autostring_2})               |              1 |    1 |       3 |                |                        |           |                     |
| | |                 +----+------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +NodeIndexSeek    |  4 | RANGE INDEX anon_0:Person(name) WHERE name = $autostring_2 |              1 |    0 |       1 |           3176 |                    1/0 |     0.407 | Fused in Pipeline 3 |
| |                   +----+------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Eager              |  5 | read/delete conflict for variable: anon_0                  |              1 |    1 |       0 |            104 |                    0/0 |     0.020 | In Pipeline 2       |
| |                   +----+------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +DetachDelete       |  6 | b                                                          |              1 |    1 |       4 |                |                        |           |                     |
| |                   +----+------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DetachDelete       |  7 | a                                                          |              1 |    1 |       5 |                |                        |           |                     |
| |                   +----+------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Eager              |  8 | read/delete conflict for variable: b                       |              1 |    1 |       0 |            104 |                    1/0 |     0.183 | Fused in Pipeline 1 |
| |                   +----+------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +MultiNodeIndexSeek |  9 | RANGE INDEX a:Person(name) WHERE name = $autostring_0,     |              1 |    1 |       4 |            120 |                    1/1 |     0.224 | In Pipeline 0       |
|                     |    | RANGE INDEX b:Person(name) WHERE name = $autostring_1      |                |      |         |                |                        |           |                     |
+---------------------+----+------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 17, total allocated memory: 3320
----

======


[[query-plan-eager-aggregation]]
== Eager Aggregation
// EagerAggregation

The `EagerAggregation` operator evaluates a grouping expression and uses the result to group rows into different groupings.
For each of these groupings, `EagerAggregation` will then evaluate all aggregation functions and return the result.
To do this, `EagerAggregation`, as the name implies, needs to pull in all data eagerly from its source and build up state, which leads to increased memory pressure in the system.


.EagerAggregation
======
.Query
[source, cypher]
----
PROFILE
MATCH (l:Location)<-[:WORKS_IN]-(p:Person)
RETURN
  l.name AS location,
  collect(p.name) AS people
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-------------------+----+------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator          | Id | Details                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-------------------+----+------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults   |  0 | location, people                                     |              4 |    6 |       0 |                |                    0/0 |     0.022 | In Pipeline 1       |
| |                 +----+------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +EagerAggregation |  1 | cache[l.name] AS location, collect(p.name) AS people |              4 |    6 |      30 |           2584 |                        |           |                     |
| |                 +----+------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter           |  2 | p:Person                                             |             15 |   15 |      30 |                |                        |           |                     |
| |                 +----+------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Expand(All)      |  3 | (l)<-[anon_0:WORKS_IN]-(p)                           |             15 |   15 |      26 |                |                        |           |                     |
| |                 +----+------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +CacheProperties  |  4 | cache[l.name]                                        |             10 |   10 |      20 |                |                        |           |                     |
| |                 +----+------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan  |  5 | l:Location                                           |             10 |   10 |      11 |            120 |                    4/0 |     0.813 | Fused in Pipeline 0 |
+-------------------+----+------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 117, total allocated memory: 2664
----

======


[[query-plan-ordered-aggregation]]
== Ordered Aggregation
// OrderedAggregation

The `OrderedAggregation` operator is an optimization of the `EagerAggregation` operator that takes advantage of the ordering of the incoming rows.
This operator uses lazy evaluation and has a lower memory pressure in the system than the `EagerAggregation` operator.


.OrderedAggregation
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
WHERE p.name STARTS WITH 'P'
RETURN p.name, count(*) AS count
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+--------------+---------------+
| Operator              | Details                                                                        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by   | Pipeline      |
+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+--------------+---------------+
| +ProduceResults       | `p.name`, count                                                                |              0 |    2 |       0 |                |                    0/0 |     0.045 |              |               |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+              |               |
| +OrderedAggregation   | cache[p.name] AS `p.name`, count(*) AS count                                   |              0 |    2 |       0 |            288 |                    0/0 |     0.175 | `p.name` ASC | In Pipeline 1 |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+--------------+---------------+
| +NodeIndexSeekByRange | RANGE INDEX p:Person(name) WHERE name STARTS WITH $autostring_0, cache[p.name] |              0 |    2 |       3 |            120 |                    0/1 |     0.529 | p.name ASC   | In Pipeline 0 |
+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+--------------+---------------+

Total database accesses: 3, total allocated memory: 352
----

======


[[query-plan-node-count-from-count-store]]
== Node Count From Count Store
// NodeCountFromCountStore

The `NodeCountFromCountStore` operator uses the count store to answer questions about node counts.
This is much faster than the `EagerAggregation` operator which achieves the same result by actually counting.
However, as the count store only stores a limited range of combinations, `EagerAggregation` will still be used for more complex queries.
For example, we can get counts for all nodes, and nodes with a label, but not nodes with more than one label.


.NodeCountFromCountStore
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
RETURN count(p) AS people
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+--------------------------+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                 | Details                      | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+--------------------------+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults          | people                       |              1 |    1 |       0 |                |                        |           |                     |
| |                        +------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeCountFromCountStore | count( (:Person) ) AS people |              1 |    1 |       1 |            120 |                    0/0 |     0.169 | Fused in Pipeline 0 |
+--------------------------+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 184
----

======


[[query-plan-relationship-count-from-count-store]]
== Relationship Count From Count Store ==
// RelationshipCountFromCountStore

The `RelationshipCountFromCountStore` operator uses the count store to answer questions about relationship counts.
This is much faster than the `EagerAggregation` operator which achieves the same result by actually counting.
However, as the count store only stores a limited range of combinations, `EagerAggregation` will still be used for more complex queries.
For example, we can get counts for all relationships, relationships with a type, relationships with a label on one end, but not relationships with labels on both end nodes.


.RelationshipCountFromCountStore
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)-[r:WORKS_IN]->()
RETURN count(r) AS jobs
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+----------------------------------+--------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                         | Details                                    | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+----------------------------------+--------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                  | jobs                                       |              1 |    1 |       0 |                |                        |           |                     |
| |                                +--------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +RelationshipCountFromCountStore | count( (:Person)-[:WORKS_IN]->() ) AS jobs |              1 |    1 |       1 |            120 |                    0/0 |     0.625 | Fused in Pipeline 0 |
+----------------------------------+--------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 184
----

======


[[query-plan-distinct]]
== Distinct
// Distinct

The `Distinct` operator removes duplicate rows from the incoming stream of rows.
To ensure only distinct elements are returned, `Distinct` will pull in data lazily from its source and build up state.
This may lead to increased memory pressure in the system.


.Distinct
======
.Query
[source, cypher]
----
PROFILE
MATCH (l:Location)<-[:WORKS_IN]-(p:Person)
RETURN DISTINCT p
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+----+-----------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Id | Details               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+----+-----------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  |  0 | p                     |             14 |   14 |      28 |                |                        |           |                     |
| |                +----+-----------------------+----------------+------+---------+----------------+                        |           |                     |
| +Distinct        |  1 | p                     |             14 |   14 |       0 |            352 |                        |           |                     |
| |                +----+-----------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter          |  2 | p:Person              |             15 |   15 |      30 |                |                        |           |                     |
| |                +----+-----------------------+----------------+------+---------+----------------+                        |           |                     |
| +Expand(All)     |  3 | (l)<-[r:WORKS_IN]-(p) |             15 |   15 |      26 |                |                        |           |                     |
| |                +----+-----------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan |  4 | l:Location            |             10 |   10 |      11 |            120 |                    4/0 |     0.287 | Fused in Pipeline 0 |
+------------------+----+-----------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 95, total allocated memory: 432
----

======

[[query-plan-ordered-distinct]]
== Ordered Distinct
// OrderedDistinct

The `OrderedDistinct` operator is an optimization of the `Distinct` operator that takes advantage of the ordering of the incoming rows.
This operator has a lower memory pressure in the system than the `Distinct` operator.


.OrderedDistinct
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
WHERE p.name STARTS WITH 'P'
RETURN DISTINCT p.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+--------------+---------------+
| Operator              | Details                                                                        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by   | Pipeline      |
+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+--------------+---------------+
| +ProduceResults       | `p.name`                                                                       |              0 |    2 |       0 |                |                    0/0 |     0.046 |              |               |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+              |               |
| +OrderedDistinct      | cache[p.name] AS `p.name`                                                      |              0 |    2 |       0 |             32 |                    0/0 |     0.090 | `p.name` ASC |               |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+--------------+               |
| +NodeIndexSeekByRange | RANGE INDEX p:Person(name) WHERE name STARTS WITH $autostring_0, cache[p.name] |              0 |    2 |       3 |            120 |                    0/1 |     0.493 | p.name ASC   | In Pipeline 0 |
+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+--------------+---------------+

Total database accesses: 3, total allocated memory: 184
----

======


[[query-plan-filter]]
== Filter
// Filter

The `Filter` operator filters each row coming from the child operator, only passing through rows that evaluate the predicates to `true`.


.Filter
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
WHERE p.name =~ '^a.*'
RETURN p
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                          | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | p                                                                |             14 |    0 |       0 |                |                        |           |                     |
| |               +------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter         | cache[p.name] =~ $autostring_0                                   |             14 |    0 |       0 |                |                        |           |                     |
| |               +------------------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexScan  | RANGE INDEX p:Person(name) WHERE name IS NOT NULL, cache[p.name] |             14 |   14 |      15 |            120 |                    0/1 |     0.763 | Fused in Pipeline 0 |
+-----------------+------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 15, total allocated memory: 184
----

======


[[query-plan-limit]]
== Limit
// Limit

The `Limit` operator returns the first `+n+` rows from the incoming input.


.Limit
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
RETURN p
LIMIT 3
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | p        |              3 |    3 |       0 |                |                        |           |                     |
| |               +----------+----------------+------+---------+----------------+                        |           |                     |
| +Limit          | 3        |              3 |    3 |       0 |             32 |                        |           |                     |
| |               +----------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan| p:Person |              3 |    4 |       5 |            120 |                    3/0 |     0,540 | Fused in Pipeline 0 |
+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 8, total allocated memory: 184
----

======


[[query-plan-skip]]
== Skip
// Skip

The `Skip` operator skips `+n+` rows from the incoming rows.


.Skip
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
RETURN p
ORDER BY p.id
SKIP 1
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+----------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| Operator         | Details        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by | Pipeline            |
+------------------+----------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +ProduceResults  | p              |             13 |   13 |       0 |                |                    2/0 |     0.165 |            |                     |
| |                +----------------+----------------+------+---------+----------------+------------------------+-----------+            |                     |
| +Skip            | $autoint_0     |             13 |   13 |       0 |             32 |                    0/0 |     0.043 |            |                     |
| |                +----------------+----------------+------+---------+----------------+------------------------+-----------+            |                     |
| +Sort            | `p.id` ASC     |             14 |   14 |       0 |            400 |                    0/0 |     0.155 | p.id ASC   | In Pipeline 1       |
| |                +----------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +Projection      | p.id AS `p.id` |             14 |   14 |       0 |                |                        |           |            |                     |
| |                +----------------+----------------+------+---------+----------------+                        |           +------------+                     |
| +NodeByLabelScan | p:Person       |             18 |   18 |      19 |            120 |                    3/0 |     0,157 |            | Fused in Pipeline 0 |
+------------------+----------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+

Total database accesses: 71, total allocated memory: 512
----

======


[[query-plan-sort]]
== Sort
// Sort

The `Sort` operator sorts rows by a provided key.
In order to sort the data, all data from the source operator needs to be pulled in eagerly and kept in the query state, which will lead to increased memory pressure in the system.


.Sort
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
RETURN p
ORDER BY p.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+--------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| Operator         | Details            | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by | Pipeline            |
+------------------+--------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +ProduceResults  | p                  |             14 |   14 |       0 |                |                    2/0 |     0.178 |            |                     |
| |                +--------------------+----------------+------+---------+----------------+------------------------+-----------+            |                     |
| +Sort            | `p.name` ASC       |             14 |   14 |       0 |           1192 |                    0/0 |     0.107 | p.name ASC | In Pipeline 1       |
| |                +--------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +Projection      | p.name AS `p.name` |             14 |   14 |      14 |                |                        |           |            |                     |
| |                +--------------------+----------------+------+---------+----------------+                        |           +------------+                     |
| +NodeByLabelScan |p:Person            |             14 |   14 |      35 |            120 |                    3/0 |     0,221 |            | Fused in Pipeline 0 |
+------------------+--------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+

Total database accesses: 85, total allocated memory: 1272
----

======


[[query-plan-partial-sort]]
== Partial Sort
// PartialSort

The `PartialSort` operator is an optimization of the `Sort` operator that takes advantage of the ordering of the incoming rows.
This operator uses lazy evaluation and has a lower memory pressure in the system than the `Sort` operator.
Partial sort is only applicable when sorting on multiple columns.


.PartialSort
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
WHERE p.name STARTS WITH 'P'
RETURN p
ORDER BY p.name, p.age
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+
| Operator              | Details                                                                        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by            | Pipeline            |
+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+
| +ProduceResults       | p                                                                              |              0 |    2 |       0 |                |                    2/0 |     0.087 |                       |                     |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                       |                     |
| +PartialSort          | `p.name` ASC, `p.age` ASC                                                      |              0 |    2 |       0 |            544 |                    0/0 |     0.184 | p.name ASC, p.age ASC | In Pipeline 1       |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+
| +Projection           | cache[p.name] AS `p.name`, p.age AS `p.age`                                    |              0 |    2 |       0 |                |                        |           | `p.name` ASC          |                     |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +-----------------------+                     |
| +NodeIndexSeekByRange | RANGE INDEX p:Person(name) WHERE name STARTS WITH $autostring_0, cache[p.name] |              0 |    2 |       3 |            120 |                    0/1 |     0.362 | p.name ASC            | Fused in Pipeline 0 |
+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+

Total database accesses: 3, total allocated memory: 608
----

======


[[query-plan-top]]
== Top
// Top

The `Top` operator returns the first `+n+` rows sorted by a provided key.
Instead of sorting the entire input, only the top `+n+` rows are retained.


.Top
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
RETURN p
ORDER BY p.name
LIMIT 2
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+----------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| Operator         | Details              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by | Pipeline            |
+------------------+----------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +ProduceResults  | p                    |              2 |    2 |       0 |                |                    2/0 |     0.093 |            |                     |
| |                +----------------------+----------------+------+---------+----------------+------------------------+-----------+            |                     |
| +Top             | `p.name` ASC LIMIT 2 |              2 |    2 |       0 |           1184 |                    0/0 |     0.295 | p.name ASC | In Pipeline 1       |
| |                +----------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +Projection      | p.name AS `p.name`   |             14 |   14 |      14 |                |                        |           |            |                     |
| |                +----------------------+----------------+------+---------+----------------+                        |           +------------+                     |
| +NodeByLabelScan | p:Person             |             14 |   14 |      35 |            120 |                    3/0 |     0,166 |            | Fused in Pipeline 0 |
+------------------+----------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+

Total database accesses: 85, total allocated memory: 1264
----

======


[[query-plan-partial-top]]
== Partial Top
// PartialTop

The `PartialTop` operator is an optimization of the `Top` operator that takes advantage of the ordering of the incoming rows.
This operator uses lazy evaluation and has a lower memory pressure in the system than the `Top` operator.
Partial top is only applicable when sorting on multiple columns.


.PartialTop
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
WHERE p.name STARTS WITH 'P'
RETURN p
ORDER BY p.name, p.age
LIMIT 2
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+
| Operator              | Details                                                                        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by            | Pipeline            |
+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+
| +ProduceResults       | p                                                                              |              0 |    2 |       0 |                |                    2/0 |     0.093 |                       |                     |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+                       |                     |
| +PartialTop           | `p.name` ASC, `p.age` ASC LIMIT 2                                              |              0 |    2 |       0 |            640 |                    0/0 |     0.870 | p.name ASC, p.age ASC | In Pipeline 1       |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+
| +Projection           | cache[p.name] AS `p.name`, p.age AS `p.age`                                    |              0 |    2 |       0 |                |                        |           | `p.name` ASC          |                     |
| |                     +--------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +-----------------------+                     |
| +NodeIndexSeekByRange | RANGE INDEX p:Person(name) WHERE name STARTS WITH $autostring_0, cache[p.name] |              0 |    2 |       3 |            120 |                    0/1 |     0.556 | p.name ASC            | Fused in Pipeline 0 |
+-----------------------+--------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+-----------------------+---------------------+

Total database accesses: 3, total allocated memory: 704
----

======


[[query-plan-union]]
== Union
// Union

The `Union` operator concatenates the results from the right child operator with the results from the left child operator.


.Union
======
.Query
[source, cypher]
----
PROFILE
MATCH (p:Location)
  RETURN p.name
UNION ALL
MATCH (p:Country)
  RETURN p.name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+--------------------+----+--------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator           | Id | Details            | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+--------------------+----+--------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults    |  0 | `p.name`           |             20 |    0 |       0 |                |                        |           |                     |
| |                  +----+--------------------+----------------+------+---------+----------------+                        |           |                     |
| +Union             |  1 |                    |             20 |    0 |       0 |              0 |                    0/0 |     0.000 | Fused in Pipeline 2 |
| |\                 +----+--------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| | +Projection      |  2 | `p.name`           |             10 |    0 |       0 |                |                        |           |                     |
| | |                +----+--------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Projection      |  3 | p.name AS `p.name` |             10 |    0 |       0 |                |                        |           |                     |
| | |                +----+--------------------+----------------+------+---------+----------------+                        |           |                     |
| | +NodeByLabelScan |  4 | p:Country          |             10 |    0 |       0 |            120 |                    0/0 |     0.049 | Fused in Pipeline 1 |
| |                  +----+--------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Projection        |  5 | `p.name`           |             10 |    0 |       0 |                |                        |           |                     |
| |                  +----+--------------------+----------------+------+---------+----------------+                        |           |                     |
| +Projection        |  6 | p.name AS `p.name` |             10 |    0 |       0 |                |                        |           |                     |
| |                  +----+--------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan   |  7 | p:Location         |             10 |    0 |       0 |            120 |                    0/0 |     0.077 | Fused in Pipeline 0 |
+--------------------+----+--------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 0, total allocated memory: 320
----

======


[[query-plan-unwind]]
== Unwind
// Unwind

The `Unwind` operator returns one row per item in a list.


.Unwind
======

.Query
[source, cypher]
----
PROFILE
UNWIND range(1, 5) AS value
RETURN value
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----------------------------------------+----------------+------+---------+------------------------+-----------+---------------------+
| Operator        | Details                                | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----------------------------------------+----------------+------+---------+------------------------+-----------+---------------------+
| +ProduceResults | value                                  |             10 |    5 |       0 |                        |           |                     |
| |               +----------------------------------------+----------------+------+---------+                        |           |                     |
| +Unwind         | range($autoint_0, $autoint_1) AS value |             10 |    5 |       0 |                    0/0 |     0.000 | Fused in Pipeline 0 |
+-----------------+----------------------------------------+----------------+------+---------+------------------------+-----------+---------------------+

Total database accesses: 0, total allocated memory: 184
----

======


[[query-plan-exhaustive-limit]]
== Exhaustive Limit
// LockNodes - changed in 4.3
// ExhaustiveLimit

The `ExhaustiveLimit` operator is just like a normal `Limit` but will always exhaust the input.
Used when combining `LIMIT` and updates


.ExhaustiveLimit
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
SET p.seen = true
RETURN p
LIMIT 3
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+----+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Id | Details       | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+----+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  |  0 | p             |              3 |    0 |       0 |                |                        |           |                     |
| |                +----+---------------+----------------+------+---------+----------------+                        |           |                     |
| +Eager           |  1 |               |             10 |    0 |       0 |             16 |                    0/0 |     0.000 | Fused in Pipeline 1 |
| |                +----+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ExhaustiveLimit |  2 | 3             |              3 |    0 |       0 |             32 |                        |           |                     |
| |                +----+---------------+----------------+------+---------+----------------+                        |           |                     |
| +SetProperty     |  3 | p.seen = true |             10 |    0 |       0 |                |                        |           |                     |
| |                +----+---------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan |  4 | p:Person      |             10 |    0 |       1 |            120 |                    1/0 |     0.337 | Fused in Pipeline 0 |
+------------------+----+---------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 1, total allocated memory: 216
----

======


[[query-plan-optional]]
== Optional
// Optional

The `Optional` operator is used to solve some xref::clauses/optional-match.adoc[OPTIONAL MATCH] queries.
It will pull data from its source, simply passing it through if any data exists.
However, if no data is returned by its source, `Optional` will yield a single row with all columns set to `null`.


.Optional
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person {name: 'me'})
OPTIONAL MATCH (q:Person {name: 'Lulu'})
RETURN p, q
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| Operator         | Details                                               | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline      |
+------------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +ProduceResults  | p, q                                                  |              1 |    1 |       0 |                |                    2/0 |     0.079 | In Pipeline 2 |
| |                +-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +Apply           |                                                       |              1 |    1 |       0 |                |                    0/0 |     0.096 |               |
| |\               +-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| | +Optional      | p                                                     |              1 |    1 |       0 |            768 |                    0/0 |     0.043 | In Pipeline 2 |
| | |              +-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| | +NodeIndexSeek | RANGE INDEX q:Person(name) WHERE name = $autostring_1 |              1 |    0 |       1 |           2152 |                    1/0 |     0.098 | In Pipeline 1 |
| |                +-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +NodeIndexSeek   | RANGE INDEX p:Person(name) WHERE name = $autostring_0 |              1 |    1 |       2 |            120 |                    0/1 |     0.364 | In Pipeline 0 |
+------------------+-------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+

Total database accesses: 3, total allocated memory: 3000
----

======


[[query-plan-project-endpoints]]
== Project Endpoints
// ProjectEndpoints

The `ProjectEndpoints` operator projects the start and end node of a relationship.


.ProjectEndpoints
======

.Query
[source, cypher]
----
PROFILE
CREATE (n)-[p:KNOWS]->(m)
WITH p AS r
MATCH (u)-[r]->(v)
RETURN u, v
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------+----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator            | Id | Details                      | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------+----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults     |  0 | u, v                         |              1 |    1 |       2 |                |                        |           |                     |
| |                   +----+------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Apply              |  1 |                              |              1 |    1 |       0 |                |                        |           |                     |
| |\                  +----+------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +ProjectEndpoints |  2 | (u)-[r]->(v)                 |              1 |    1 |       0 |                |                        |           |                     |
| | |                 +----+------------------------------+----------------+------+---------+----------------+                        |           |                     |
| | +Argument         |  3 | r                            |              1 |    1 |       0 |           4328 |                    0/0 |     0.922 | Fused in Pipeline 2 |
| |                   +----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Projection         |  4 | p AS r                       |              1 |    1 |       0 |                |                        |           |                     |
| |                   +----+------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Eager              |  5 |                              |              1 |    1 |       0 |            368 |                    0/0 |     0.043 | Fused in Pipeline 1 |
| |                   +----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +Create             |  6 | (n), (m), (n)-[p:KNOWS]->(m) |              1 |    1 |       3 |                |                        |           | Fused in Pipeline 0 |
+---------------------+----+------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
Total database accesses: 5, total allocated memory: 4936
----

======


[[query-plan-projection]]
== Projection
// Projection

For each incoming row, the `Projection` operator evaluates a set of expressions and produces a row with the results of the expressions.


.Projection
======

.Query
[source, cypher]
----
PROFILE
RETURN 'hello' AS greeting
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+---------------------------+----------------+------+---------+------------------------+-----------+---------------------+
| Operator        | Details                   | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+---------------------------+----------------+------+---------+------------------------+-----------+---------------------+
| +ProduceResults | greeting                  |              1 |    1 |       0 |                        |           |                     |
| |               +---------------------------+----------------+------+---------+                        |           |                     |
| +Projection     | $autostring_0 AS greeting |              1 |    1 |       0 |                    0/0 |     0.000 | Fused in Pipeline 0 |
+-----------------+---------------------------+----------------+------+---------+------------------------+-----------+---------------------+

Total database accesses: 0, total allocated memory: 184
----

======


[[query-plan-shortest-path]]
== Shortest path
// ShortestPath

The `ShortestPath` operator finds one or all shortest paths between two previously matches node variables.


.ShortestPath
======

.Query
[source, cypher]
----
PROFILE
MATCH
  (andy:Person {name: 'Andy'}),
  (mattias:Person {name: 'Mattias'}),
  p = shortestPath((andy)-[*]-(mattias))
RETURN p
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------+-------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| Operator            | Details                                                     | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline      |
+---------------------+-------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +ProduceResults     | p                                                           |              1 |    1 |       0 |                |                    1/0 |     0.241 |               |
| |                   +-------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+               |
| +ShortestPath       | p = (andy)-[anon_0*]-(mattias)                              |              1 |    1 |       1 |           1424 |                        |           | In Pipeline 1 |
| |                   +-------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +MultiNodeIndexSeek | RANGE INDEX andy:Person(name) WHERE name = $autostring_0,   |              1 |    1 |       4 |            120 |                    1/1 |     0.308 | In Pipeline 0 |
|                     | RANGE INDEX mattias:Person(name) WHERE name = $autostring_1 |                |      |         |                |                        |           |               |
+---------------------+-------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+

Total database accesses: 5, total allocated memory: 1488
----

======


[[query-plan-empty-row]]
== Empty Row
// EmptyRow

The `EmptyRow` operator returns a single row with no columns.


.EmptyRow
======

.Query
[source, cypher]
----
PROFILE
CYPHER runtime=slotted
FOREACH (value IN [1,2,3] | MERGE (:Person {age: value}))
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------+--------------------------------------+----------------+------+---------+------------------------+
| Operator        | Details                              | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+--------------------+--------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults    |                                      |              1 |    0 |       0 |                    0/0 |
| |                  +--------------------------------------+----------------+------+---------+------------------------+
| +EmptyResult       |                                      |              1 |    0 |       0 |                    0/0 |
| |                  +--------------------------------------+----------------+------+---------+------------------------+
| +Foreach           | value IN [1, 2, 3]                   |              1 |    1 |       0 |                    0/0 |
| |\                 +--------------------------------------+----------------+------+---------+------------------------+
| | +Merge           | CREATE (anon_0:Person {age: value})  |              1 |    3 |       9 |                    0/0 |
| | |                +--------------------------------------+----------------+------+---------+------------------------+
| | +Filter          | anon_0.age = value                   |              1 |    0 |     184 |                    2/0 |
| | |                +--------------------------------------+----------------+------+---------+------------------------+
| | +NodeByLabelScan | anon_0:Person                        |             35 |  108 |     111 |                    3/0 |
| |                  +--------------------------------------+----------------+------+---------+------------------------+
| +EmptyRow          |                                      |              1 |    1 |       0 |                    0/0 |
+--------------------+--------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 304, total allocated memory: 64
----

======


[[query-plan-procedure-call]]
== Procedure Call
// ProcedureCall

The `ProcedureCall` operator indicates an invocation to a procedure.


.ProcedureCall
======

.Query
[source, cypher]
----
PROFILE
CALL db.labels() YIELD label
RETURN *
ORDER BY label
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| Operator        | Details                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Ordered by | Pipeline            |
+-----------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +ProduceResults | label                             |             10 |    4 |       0 |                |                    0/0 |     0.091 |            |                     |
| |               +-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+            |                     |
| +Sort           | label ASC                         |             10 |    4 |       0 |            536 |                    0/0 |     0.178 | label ASC  | In Pipeline 1       |
| |               +-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+
| +ProcedureCall  | db.labels() :: (label :: STRING)  |             10 |    4 |         |                |                        |           |            | Fused in Pipeline 0 |
+-----------------+-----------------------------------+----------------+------+---------+----------------+------------------------+-----------+------------+---------------------+

Total database accesses: ?, total allocated memory: 600
----

======


[[query-plan-cache-properties]]
== Cache Properties
// CacheProperties

The `CacheProperties` operator reads nodes and relationship properties and caches them in the current row.
Future accesses to these properties can avoid reading from the store which will speed up the query.
In the plan below we will cache `l.name` before `Expand(All)` where there are fewer rows.


.CacheProperties
======
.Query
[source, cypher]
----
PROFILE
MATCH (l:Location)<-[:WORKS_IN]-(p:Person)
RETURN
  l.name AS location,
  p.name AS name
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+----+-------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Id | Details                                   | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+----+-------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  |  0 | location, name                            |             13 |   13 |       0 |                |                        |           |                     |
| |                +----+-------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Projection      |  1 | cache[l.name] AS location, p.name AS name |             13 |   13 |      26 |                |                        |           |                     |
| |                +----+-------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Filter          |  2 | p:Person                                  |             13 |   13 |      26 |                |                        |           |                     |
| |                +----+-------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Expand(All)     |  3 | (l)<-[anon_0:WORKS_IN]-(p)                |             13 |   13 |      24 |                |                        |           |                     |
| |                +----+-------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +CacheProperties |  4 | cache[l.name]                             |             10 |   10 |      20 |                |                        |           |                     |
| |                +----+-------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan |  5 | l:Location                                |             10 |   10 |      11 |            120 |                    4/0 |     0.344 | Fused in Pipeline 0 |
+------------------+----+-------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 107, total allocated memory: 200
----

======


[[query-plan-create]]
== Create (nodes and relationships)
// Create

The `Create` operator is used to create nodes and relationships.


.Create
======

.Query
[source, cypher]
----
PROFILE
CREATE
  (max:Person {name: 'Max'}),
  (chris:Person {name: 'Chris'})
CREATE (max)-[:FRIENDS_WITH]->(chris)
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+---------------------------------------------------------------------------+----------------+------+---------+------------------------+-----------+---------------------+
| Operator        | Details                                                                   | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+---------------------------------------------------------------------------+----------------+------+---------+------------------------+-----------+---------------------+
| +ProduceResults |                                                                           |              1 |    0 |       0 |                        |           |                     |
| |               +---------------------------------------------------------------------------+----------------+------+---------+                        |           |                     |
| +EmptyResult    |                                                                           |              1 |    0 |       0 |                        |           |                     |
| |               +---------------------------------------------------------------------------+----------------+------+---------+                        |           |                     |
| +Create         | (max:Person {name: $autostring_0}), (chris:Person {name: $autostring_1}), |              1 |    1 |       7 |                    0/0 |     0.000 | Fused in Pipeline 0 |
|                 | (max)-[anon_0:FRIENDS_WITH]->(chris)                                      |                |      |         |                        |           |                     |
+-----------------+---------------------------------------------------------------------------+----------------+------+---------+------------------------+-----------+---------------------+

Total database accesses: 7, total allocated memory: 184
----

======


[[query-plan-delete]]
== Delete (nodes and relationships)
// Delete

The `Delete` operator is used to delete a node or a relationship.


.Delete
======

.Query
[source, cypher]
----
PROFILE
MATCH (you:Person {name: 'you'})
DELETE you
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Id | Details                                                | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults |  0 |                                                        |              0 |    0 |       0 |                |                        |           |                     |
| |               +----+--------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult    |  1 |                                                        |              0 |    0 |       0 |                |                        |           |                     |
| |               +----+--------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +Delete         |  2 | you                                                     |              0 |    0 |       0 |                |                        |           |                     |
| |               +----+--------------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +NodeIndexSeek  |  3 | RANGE INDEX you:Person(name) WHERE name = $autostring_0 |              0 |    0 |       1 |            120 |                    1/0 |     0.330 | Fused in Pipeline 0 |
+-----------------+----+--------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 13, total allocated memory: 216
----

======


[[query-plan-detach-delete]]
== Detach Delete
// DetachDelete

The `DetachDelete` operator is used in all queries containing the xref::clauses/delete.adoc[DETACH DELETE] clause, when deleting nodes and their relationships.


.DetachDelete
======

.Query
[source, cypher]
----
PROFILE
MATCH (p:Person)
DETACH DELETE p
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+------------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator         | Details  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+------------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults  |          |             14 |    0 |       0 |                |                        |           |                     |
| |                +----------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult     |          |             14 |    0 |       0 |                |                        |           |                     |
| |                +----------+----------------+------+---------+----------------+                        |           |                     |
| +DetachDelete    | p        |             14 |   14 |      41 |                |                        |           |                     |
| |                +----------+----------------+------+---------+----------------+                        |           |                     |
| +NodeByLabelScan | p:Person |             14 |   14 |      35 |            120 |                   21/0 |    12,439 | Fused in Pipeline 0 |
+------------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 112, total allocated memory: 200
----

======


// MergeCreateNode -- removed in 4.3

// MergeCreateRelationship -- removed in 4.3


[[query-plan-set-labels]]
== Set Labels
// SetLabels

The `SetLabels` operator is used when setting labels on a node.


.SetLabels
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
SET n:Person
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults |          |             35 |    0 |       0 |                |                        |           |                     |
| |               +----------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult    |          |             35 |    0 |       0 |                |                        |           |                     |
| |               +----------+----------------+------+---------+----------------+                        |           |                     |
| +SetLabels      | n:Person |             35 |   35 |      22 |                |                        |           |                     |
| |               +----------+----------------+------+---------+----------------+                        |           |                     |
| +AllNodesScan   | n        |             35 |   35 |      36 |            120 |                    3/0 |     0.873 | Fused in Pipeline 0 |
+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 58, total allocated memory: 184
----

======


[[query-plan-remove-labels]]
== Remove Labels
// RemoveLabels

The `RemoveLabels` operator is used when deleting labels from a node.


.RemoveLabels
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
REMOVE n:Person
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults |          |             35 |    0 |       0 |                |                        |           |                     |
| |               +----------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult    |          |             35 |    0 |       0 |                |                        |           |                     |
| |               +----------+----------------+------+---------+----------------+                        |           |                     |
| +RemoveLabels   | n:Person |             35 |   35 |      15 |                |                        |           |                     |
| |               +----------+----------------+------+---------+----------------+                        |           |                     |
| +AllNodesScan   | n        |             35 |   35 |      36 |            120 |                    3/0 |     0.765 | Fused in Pipeline 0 |
+-----------------+----------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 51, total allocated memory: 184
----

======


[[query-plan-set-node-properties-from-map]]
== Set Node Properties From Map
// SetNodePropertiesFromMap

The `SetNodePropertiesFromMap` operator is used when setting properties from a map on a node.


.SetNodePropertiesFromMap
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
SET n = {weekday: 'Monday', meal: 'Lunch'}
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+---------------------------+---------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                  | Details                                           | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+---------------------------+---------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults           |                                                   |             35 |    0 |       0 |                |                        |           |                     |
| |                         +---------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult              |                                                   |             35 |    0 |       0 |                |                        |           |                     |
| |                         +---------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +SetNodePropertiesFromMap | n = {weekday: $autostring_0, meal: $autostring_1} |             35 |   35 |     105 |                |                        |           |                     |
| |                         +---------------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +AllNodesScan             | n                                                 |             35 |   35 |      36 |            120 |                    5/0 |     3.954 | Fused in Pipeline 0 |
+---------------------------+---------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 141, total allocated memory: 184
----

======


[[query-plan-set-relationship-properties-from-map]]
== Set Relationship Properties From Map
// SetRelationshipPropertiesFromMap

The `SetRelationshipPropertiesFromMap` operator is used when setting properties from a map on a relationship.


.SetRelationshipPropertiesFromMap
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)-[r]->(m)
SET r = {weight: 5, unit: 'kg'}
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------------------------+-----------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                          | Details                                       | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------------------------+-----------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                   |                                               |             28 |    0 |       0 |                |                        |           |                     |
| |                                 +-----------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult                      |                                               |             28 |    0 |       0 |                |                        |           |                     |
| |                                 +-----------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +SetRelationshipPropertiesFromMap | r = {weight: $autoint_0, unit: $autostring_1} |             28 |   28 |      84 |                |                        |           |                     |
| |                                 +-----------------------------------------------+----------------+------+---------+----------------+                        |           |                     |
| +DirectedAllRelationshipsScan     | (n)-[r]->(m)                                  |             28 |   28 |      28 |            120 |                    5/0 |    15.278 | Fused in Pipeline 0 |
+-----------------------------------+-----------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 112, total allocated memory: 184
----

======


[[query-plan-set-property]]
== Set Property
// SetProperty

The `SetProperty` operator is used when setting a property on a node or relationship.


.SetProperty
======

.Query
[source, cypher]
----
PROFILE
MATCH (n)
SET n.checked = true
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime PIPELINED

Runtime version {neo4j-version-minor}

Batch size 128

+-----------------+------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details          | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline            |
+-----------------+------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults |                  |             35 |    0 |       0 |                |                        |           |                     |
| |               +------------------+----------------+------+---------+----------------+                        |           |                     |
| +EmptyResult    |                  |             35 |    0 |       0 |                |                        |           |                     |
| |               +------------------+----------------+------+---------+----------------+                        |           |                     |
| +SetProperty    | n.checked = true |             35 |   35 |      70 |                |                        |           |                     |
| |               +------------------+----------------+------+---------+----------------+                        |           |                     |
| +AllNodesScan   | n                |             35 |   35 |      36 |            120 |                    3/0 |     0.753 | Fused in Pipeline 0 |
+-----------------+------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 106, total allocated memory: 184
----

======


[[query-plan-create-constraint]]
== Create Constraint
// CreateConstraint


The `CreateConstraint` operator creates a constraint.

This constraint can have any of the available constraint types:

* Property uniqueness constraints
* Property existence constraints label:enterprise-edition[]
* Property type constraints label:enterprise-edition[]
* Node or relationship key constraints label:enterprise-edition[]

The following query will create a property uniqueness constraint with the name `uniqueness` on the `name` property of nodes with the `Country` label.


.CreateConstraint
======

.Query
[source, cypher]
----
PROFILE
CREATE CONSTRAINT uniqueness
FOR (c:Country) REQUIRE c.name is UNIQUE
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner ADMINISTRATION

Runtime SCHEMA

Runtime version {neo4j-version-minor}

+-------------------+------------------------------------------------------------------+
| Operator          | Details                                                          |
+-------------------+------------------------------------------------------------------+
| +CreateConstraint | CONSTRAINT uniqueness FOR (c:Country) REQUIRE (c.name) IS UNIQUE |
+-------------------+------------------------------------------------------------------+

Total database accesses: ?
----

======


[[query-plan-do-nothing-if-exists-constraint]]
== Do Nothing If Exists (constraint)
// DoNothingIfExists(CONSTRAINT)

To not get an error creating the same constraint twice, we use the `DoNothingIfExists` operator for constraints.
This will make sure no other constraint with the given name or another constraint of the same type and schema already exists before the specific `CreateConstraint` operator creates the constraint.
If it finds a constraint with the given name or with the same type and schema it will stop the execution and no new constraint is created.
The following query will create a property uniqueness constraint with the name `uniqueness` on the `name` property of nodes with the `Country` label only if no constraint named `uniqueness` or property uniqueness constraint on `+(:Country {name})+` already exists.


.DoNothingIfExists(CONSTRAINT)
======

.Query
[source, cypher]
----
PROFILE
CREATE CONSTRAINT uniqueness IF NOT EXISTS
FOR (c:Country) REQUIRE c.name is UNIQUE
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner ADMINISTRATION

Runtime SCHEMA

Runtime version {neo4j-version-minor}

+--------------------------------+------------------------------------------------------------------+
| Operator                       | Details                                                          |
+--------------------------------+------------------------------------------------------------------+
| +CreateConstraint              | CONSTRAINT uniqueness FOR (c:Country) REQUIRE (c.name) IS UNIQUE |
| |                              +------------------------------------------------------------------+
| +DoNothingIfExists(CONSTRAINT) | CONSTRAINT uniqueness FOR (c:Country) REQUIRE (c.name) IS UNIQUE |
+--------------------------------+------------------------------------------------------------------+

Total database accesses: ?
----



======

[[query-plan-drop-constraint]]
== Drop Constraint
// DropConstraint

The `DropConstraint` operator removes a constraint using the name of the constraint, no matter the type.



.DropConstraint
======

.Query
[source, cypher]
----
PROFILE
DROP CONSTRAINT uniqueness IF EXISTS
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner ADMINISTRATION

Runtime SCHEMA

Runtime version {neo4j-version-minor}

+-----------------+---------------------------------+
| Operator        | Details                         |
+-----------------+---------------------------------+
| +DropConstraint | CONSTRAINT uniqueness IF EXISTS |
+-----------------+---------------------------------+

Total database accesses: ?
----

======


[[query-plan-show-constraints]]
== Show Constraints
// ShowConstraints

The `ShowConstraints` operator lists constraints.
It may include filtering on constraint type and can have either default or full output.


.ShowConstraints
======

.Query
[source, cypher]
----
PROFILE
SHOW CONSTRAINTS
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+------------------+-------------------------------------------------------------------+----------------+------+---------+------------------------+
| Operator         | Details                                                           | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+------------------+-------------------------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults  | id, name, type, entityType, labelsOrTypes, properties, ownedIndex |             10 |    3 |       0 |                    0/0 |
| |                +-------------------------------------------------------------------+----------------+------+---------+------------------------+
| +ShowConstraints | allConstraints, defaultColumns                                    |             10 |    3 |       2 |                    0/0 |
+------------------+-------------------------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 2, total allocated memory: 64
----

======


[[query-plan-create-index]]
== Create Index
// CreateIndex

The `CreateIndex` operator creates an index.

This index can either be a fulltext, point, range, text, vector, or lookup index.

.CreateIndex
======

The following query will create an index with the name `my_index` on the `name` property of nodes with the `Country` label.

.Query
[source, cypher]
----
PROFILE
CREATE INDEX my_index
FOR (c:Country) ON (c.name)
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner ADMINISTRATION

Runtime SCHEMA

Runtime version {neo4j-version-minor}

+--------------+-----------------------------------------------+
| Operator     | Details                                       |
+--------------+-----------------------------------------------+
| +CreateIndex | RANGE INDEX my_index FOR (:Country) ON (name) |
+--------------+-----------------------------------------------+

Total database accesses: ?
----

======


[[query-plan-do-nothing-if-exists-index]]
== Do Nothing If Exits (index)
// DoNothingIfExists(INDEX)

To not get an error creating the same index twice, we use the `DoNothingIfExists` operator for indexes.
This will make sure no other index with the given name or schema already exists before the `CreateIndex` operator creates an index.
If it finds an index with the given name or schema it will stop the execution and no new index is created.
The following query will create an index with the name `my_index` on the `since` property of relationships with the `KNOWS` relationship type only if no such index already exists.


.DoNothingIfExists(INDEX)
======

.Query
[source, cypher]
----
PROFILE
CREATE INDEX my_index IF NOT EXISTS
FOR ()-[k:KNOWS]-() ON (k.since)
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner ADMINISTRATION

Runtime SCHEMA

Runtime version {neo4j-version-minor}

+---------------------------+----------------------------------------------------+
| Operator                  | Details                                            |
+---------------------------+----------------------------------------------------+
| +CreateIndex              | RANGE INDEX my_index FOR ()-[:KNOWS]-() ON (since) |
| |                         +----------------------------------------------------+
| +DoNothingIfExists(INDEX) | RANGE INDEX my_index FOR ()-[:KNOWS]-() ON (since) |
+---------------------------+----------------------------------------------------+

Total database accesses: ?
----

======


[[query-plan-drop-index]]
== Drop Index
// DropIndex

The `DropIndex` operator removes an index using the name of the index.


.DropIndex
======

.Query
[source, cypher]
----
PROFILE
DROP INDEX my_index
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner ADMINISTRATION

Runtime SCHEMA

Runtime version {neo4j-version-minor}

+------------+---------------+
| Operator   | Details       |
+------------+---------------+
| +DropIndex | INDEX my_index|
+------------+---------------+

Total database accesses: ?
----

======


[[query-plan-show-indexes]]
== Show Indexes
// ShowIndexes

The `ShowIndexes` operator lists indexes.
It may include filtering on index type and can have either default or full output.


.ShowIndexes
======

.Query
[source, cypher]
----
PROFILE
SHOW INDEXES
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------+-------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| Operator        | Details                                                                                         | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-----------------+-------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults | id, name, state, populationPercent, type, entityType, labelsOrTypes, properties, indexProvider, |             10 |    9 |       0 |                    0/0 |
| |               | owningConstraint                                                                                |                |      |         |                        |
| |               +-------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +ShowIndexes    | allIndexes, defaultColumns                                                                      |             10 |    9 |       2 |                    0/0 |
+-----------------+-------------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 2, total allocated memory: 64
----

======


[[query-plan-show-functions]]
== Show Functions
// ShowFunctions

The `ShowFunctions` operator lists functions.
It may include filtering on built-in vs user-defined functions as well as if a given user can execute the function.
The output can either be default or full output.


.ShowFunctions
======

.Query
[source, cypher]
----
PROFILE
SHOW FUNCTIONS
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------+-----------------------------------------------------+----------------+------+---------+------------------------+
| Operator        | Details                                             | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-----------------+-----------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults | name, category, description                         |             10 |  147 |       0 |                    0/0 |
| |               +-----------------------------------------------------+----------------+------+---------+------------------------+
| +ShowFunctions  | allFunctions, functionsForUser(all), defaultColumns |             10 |  147 |       0 |                    0/0 |
+-----------------+-----------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 0, total allocated memory: 64
----

======


[[query-plan-show-procedures]]
== Show Procedures
// ShowProcedures

The `ShowProcedures` operator lists procedures.
It may include filtering on whether a given user can execute the procedure and can have either default or full output.


.ShowProcedures
======

.Query
[source, cypher]
----
PROFILE
SHOW PROCEDURES
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------+----------------------------------------+----------------+------+---------+------------------------+
| Operator        | Details                                | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-----------------+----------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults | name, description, mode, worksOnSystem |             10 |   55 |       0 |                    0/0 |
| |               +----------------------------------------+----------------+------+---------+------------------------+
| +ShowProcedures | proceduresForUser(all), defaultColumns |             10 |   55 |       0 |                    0/0 |
+-----------------+----------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 0, total allocated memory: 64
----

======

[[query-plan-show-settings]]
== Show Settings
// ShowSettings

The `ShowSettings` operator lists configuration settings.

.ShowSettings
======

.Query
[source, cypher]
----
PROFILE
SHOW SETTINGS
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-----------------+---------------------------------------------------+----------------+------+---------+------------------------+
| Operator        | Details                                           | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-----------------+---------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults | name, value, isDynamic, defaultValue, description |             10 |  264 |       0 |                    0/0 |
| |               +---------------------------------------------------+----------------+------+---------+------------------------+
| +ShowSettings   | allSettings, defaultColumns                       |             10 |  264 |       0 |                    0/0 |
+-----------------+---------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 0, total allocated memory: 64
----

======

[[query-plan-show-transactions]]
== Show Transactions
// ShowTransactions

The `ShowTransactions` operator lists transactions.
It may include filtering on given ids and can have either default or full output.


.ShowTransactions
======

.Query
[source, cypher]
----
PROFILE
SHOW TRANSACTIONS
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+-------------------+-----------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| Operator          | Details                                                                                       | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+-------------------+-----------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults   | database, transactionId, currentQueryId, connectionId, clientAddress, username, currentQuery, |             10 |    1 |       0 |                    0/0 |
| |                 | startTime, status, elapsedTime                                                                |                |      |         |                        |
| |                 +-----------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+
| +ShowTransactions | defaultColumns, allTransactions                                                               |             10 |    1 |       0 |                    0/0 |
+-------------------+-----------------------------------------------------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 0, total allocated memory: 64
----

======


[[query-plan-terminate-transactions]]
== Terminate Transactions
// TerminateTransactions

The `TerminateTransactions` operator terminates transactions by ID.


.TerminateTransactions
======

.Query
[source, cypher]
----
PROFILE
TERMINATE TRANSACTIONS 'database-transaction-123'
----

.Query Plan
[role="queryplan", subs="attributes+"]
----
Planner COST

Runtime SLOTTED

Runtime version {neo4j-version-minor}

+------------------------+--------------------------------------------------------+----------------+------+---------+------------------------+
| Operator               | Details                                                | Estimated Rows | Rows | DB Hits | Page Cache Hits/Misses |
+------------------------+--------------------------------------------------------+----------------+------+---------+------------------------+
| +ProduceResults        | transactionId, username, message                       |             10 |    1 |       0 |                    0/0 |
| |                      +--------------------------------------------------------+----------------+------+---------+------------------------+
| +TerminateTransactions | defaultColumns, transactions(database-transaction-123) |             10 |    1 |       0 |                    0/0 |
+------------------------+--------------------------------------------------------+----------------+------+---------+------------------------+

Total database accesses: 0, total allocated memory: 64
----

======

