:description: Cypher provides functions allowing for the creation and manipulation of values for each temporal type -- `DATE`, `ZONED TIME`, `LOCAL TIME`, `ZONED DATETIME`, and `LOCAL DATETIME`.
:table-caption!:

[[query-functions-temporal-instant-types]]
= Temporal functions - instant types

Temporal functions allow for the creation and manipulation of values for each temporal type -- `DATE`, `ZONED TIME`, `LOCAL TIME`, `ZONED DATETIME`, and `LOCAL DATETIME`.

The following functions are included on this page:

[options="header"]
|===
| `DATE` | `ZONED DATETIME` | `LOCAL DATETIME` | `LOCAL TIME` | `ZONED TIME`

| xref::functions/temporal/index.adoc#functions-date[date()]
| xref::functions/temporal/index.adoc#functions-datetime[datetime()]
| xref::functions/temporal/index.adoc#functions-localdatetime[localdatetime()]
| xref::functions/temporal/index.adoc#functions-localtime[localtime()]
| xref::functions/temporal/index.adoc#functions-time[time()]

|
| xref::functions/temporal/index.adoc#functions-datetime-fromepoch[datetime.fromEpoch()]
|
|
|

|
| xref::functions/temporal/index.adoc#functions-datetime-fromepochmillis[datetime.fromEpochMillis()]
|
|
|

| xref::functions/temporal/index.adoc#functions-date-realtime[date.realtime()]
| xref::functions/temporal/index.adoc#functions-datetime-realtime[datetime.realtime()]
| xref::functions/temporal/index.adoc#functions-localdatetime-realtime[localdatetime.realtime()]
| xref::functions/temporal/index.adoc#functions-localtime-realtime[localtime.realtime()]
| xref::functions/temporal/index.adoc#functions-time-realtime[time.realtime()]

| xref::functions/temporal/index.adoc#functions-date-statement[date.statement()]
| xref::functions/temporal/index.adoc#functions-datetime-statement[datetime.statement()]
| xref::functions/temporal/index.adoc#functions-localdatetime-statement[localdatetime.statement()]
| xref::functions/temporal/index.adoc#functions-localtime-statement[localtime.statement()]
| xref::functions/temporal/index.adoc#functions-time-statement[time.statement()]

| xref::functions/temporal/index.adoc#functions-date-transaction[date.transaction()]
| xref::functions/temporal/index.adoc#functions-datetime-transaction[datetime.transaction()]
| xref::functions/temporal/index.adoc#functions-localdatetime-transaction[localdatetime.transaction()]
| xref::functions/temporal/index.adoc#functions-localtime-transaction[localtime.transaction()]
| xref::functions/temporal/index.adoc#functions-time-transaction[time.transaction()]


|===


[NOTE]
====
See also xref::values-and-types/temporal.adoc[Temporal (Date/Time) values] and xref::syntax/operators.adoc#query-operators-temporal[Temporal operators].
====


[[functions-temporal-instant-type]]
== Temporal instant types

[[functions-temporal-create-overview]]
=== An overview of temporal instant type creation

Each function bears the same name as the type, and construct the type they correspond to in one of four ways:

* Capturing the current time.
* Composing the components of the type.
* Parsing a `STRING` representation of the temporal value.
* Selecting and composing components from another temporal value by
 ** either combining temporal values (such as combining a `DATE` with a `ZONED TIME` to create a `ZONED DATETIME`), or
 ** selecting parts from a temporal value (such as selecting the `DATE` from a `ZONED DATETIME`); the _extractors_ -- groups of components which can be selected -- are:
  *** `date` -- contains all components for a `DATE` (conceptually _year_, _month_ and _day_).
  *** `time` -- contains all components for a `ZONED TIME` (_hour_, _minute_, _second_, and sub-seconds; namely _millisecond_, _microsecond_ and _nanosecond_).
  If the type being created and the type from which the time component is being selected both contain `timezone` (and a `timezone` is not explicitly specified) the `timezone` is also selected.
  *** `datetime` -- selects all components, and is useful for overriding specific components.
  Analogously to `time`, if the type being created and the type from which the time component is being selected both contain `timezone` (and a `timezone` is not explicitly specified) the `timezone` is also selected.
 ** In effect, this allows for the _conversion_ between different temporal types, and allowing for 'missing' components to be specified.


.Temporal instant type creation functions
[options="header"]
|===
| Function | `DATE` | `ZONED TIME` | `LOCAL TIME` | `ZONED DATETIME` | `LOCAL DATETIME`

| Getting the current value.
| icon:check[]
| icon:check[]
| icon:check[]
| icon:check[]
| icon:check[]

| Creating a calendar-based (Year-Month-Day) value.
| icon:check[]
|
|
| icon:check[]
| icon:check[]

| Creating a week-based (Year-Week-Day) value.
| icon:check[]
|
|
| icon:check[]
| icon:check[]

| Creating a quarter-based (Year-Quarter-Day) value.
| icon:check[]
|
|
| icon:check[]
| icon:check[]

| Creating an ordinal (Year-Day) value.
| icon:check[]
|
|
| icon:check[]
| icon:check[]

| Creating a value from time components.
|
| icon:check[]
| icon:check[]
|
|

| Creating a value from other temporal values using extractors (i.e. converting between different types).
| icon:check[]
| icon:check[]
| icon:check[]
| icon:check[]
| icon:check[]

| Creating a value from a `STRING`.
| icon:check[]
| icon:check[]
| icon:check[]
| icon:check[]
| icon:check[]

| Creating a value from a timestamp.
|
|
|
| icon:check[]
|

|===


[NOTE]
====
All the temporal instant types -- including those that do not contain timezone information support such as `DATE`, `LOCAL TIME` and `ZONED DATETIME` -- allow for a timezone to specified for the functions that retrieve the current instant.
This allows for the retrieval of the current instant in the specified timezone.
====


[[functions-temporal-clock-overview]]
=== Controlling which clock to use

The functions which create temporal instant values based on the current instant use the `statement` clock as default.
However, there are three different clocks available for more fine-grained control:

* `transaction`: The same instant is produced for each invocation within the same transaction.
A different time may be produced for different transactions.
* `statement`: The same instant is produced for each invocation within the same statement.
A different time may be produced for different statements within the same transaction.
* `realtime`: The instant produced will be the live clock of the system.

The following table lists the different sub-functions for specifying the clock to be used when creating the current temporal instant value:

[options="header"]
|===
| Type | default | transaction | statement | realtime

| Date
| xref::functions/temporal/index.adoc#functions-date[date()]
| xref::functions/temporal/index.adoc#functions-date-transaction[date.transaction()]
| xref::functions/temporal/index.adoc#functions-date-statement[date.statement()]
| xref::functions/temporal/index.adoc#functions-date-realtime[date.realtime()]

| Time
| xref::functions/temporal/index.adoc#functions-time[time()]
| xref::functions/temporal/index.adoc#functions-time-transaction[time.transaction()]
| xref::functions/temporal/index.adoc#functions-time-statement[time.statement()]
| xref::functions/temporal/index.adoc#functions-time-realtime[time.realtime()]

| LocalTime
| xref::functions/temporal/index.adoc#functions-localtime[localtime()]
| xref::functions/temporal/index.adoc#functions-localtime-transaction[localtime.transaction()]
| xref::functions/temporal/index.adoc#functions-localtime-statement[localtime.statement()]
| xref::functions/temporal/index.adoc#functions-localtime-realtime[localtime.realtime()]

| DateTime
| xref::functions/temporal/index.adoc#functions-datetime[datetime()]
| xref::functions/temporal/index.adoc#functions-datetime-transaction[datetime.transaction()]
| xref::functions/temporal/index.adoc#functions-datetime-statement[datetime.statement()]
| xref::functions/temporal/index.adoc#functions-datetime-realtime[datetime.realtime()]

| LocalDateTime
| xref::functions/temporal/index.adoc#functions-localdatetime[localdatetime()]
| xref::functions/temporal/index.adoc#functions-localdatetime-transaction[localdatetime.transaction()]
| xref::functions/temporal/index.adoc#functions-localdatetime-statement[localdatetime.statement()]
| xref::functions/temporal/index.adoc#functions-localdatetime-realtime[localdatetime.realtime()]

|===


[[functions-temporal-truncate-overview]]
[discrete]
=== Truncating temporal values

A temporal instant value can be created by truncating another temporal instant value at the nearest preceding point in time at a specified component boundary (namely, a _truncation unit_).
A temporal instant value created in this way will have all components which are smaller than the specified truncation unit set to their default values.
// what about these?

It is possible to supplement the truncated value by providing a map containing components which are smaller than the truncation unit.
This will have the effect of overriding the default values which would otherwise have been set for these smaller components.

The following table lists the supported truncation units and the corresponding sub-functions:

[options="header"]
|===
| Truncation unit | `DATE` | `ZONED TIME` | `LOCAL TIME` | `ZONED DATETIME` | `LOCAL DATETIME`

| `millennium`
| xref:functions-date-truncate[date.truncate('millennium', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('millennium', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('millennium', input)]

| `century`
| xref:functions-date-truncate[date.truncate('century', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('century', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('century', input)]

| `decade`
| xref:functions-date-truncate[date.truncate('decade', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('decade', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('decade', input)]

| `year`
| xref:functions-date-truncate[date.truncate('year', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('year', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('year', input)]

| `weekYear`
| xref:functions-date-truncate[date.truncate('weekYear', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('weekYear', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('weekYear', input)]

| `quarter`
| xref:functions-date-truncate[date.truncate('quarter', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('quarter', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('quarter', input)]

| `month`
| xref:functions-date-truncate[date.truncate('month', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('month', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('month', input)]

| `week`
| xref:functions-date-truncate[date.truncate('week', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('week', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('week', input)]

| `day`
| xref:functions-date-truncate[date.truncate('day', input)]
| xref:functions-time-truncate[time.truncate('day', input)]
| xref:functions-localtime-truncate[localtime.truncate('day', input)]
| xref:functions-datetime-truncate[datetime.truncate('day', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('day', input)]

| `hour`
|
| xref:functions-time-truncate[time.truncate('hour', input)]
| xref:functions-localtime-truncate[localtime.truncate('hour', input)]
| xref:functions-datetime-truncate[datetime.truncate('hour', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('hour',input)]

| `minute`
|
| xref:functions-time-truncate[time.truncate('minute', input)]
| xref:functions-localtime-truncate[localtime.truncate('minute', input)]
| xref:functions-datetime-truncate[datetime.truncate('minute', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('minute', input)]

| `second`
|
| xref:functions-time-truncate[time.truncate('second', input)]
| xref:functions-localtime-truncate[localtime.truncate('second', input)]
| xref:functions-datetime-truncate[datetime.truncate('second', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('second', input)]

| `millisecond`
|
| xref:functions-time-truncate[time.truncate('millisecond', input)]
| xref:functions-localtime-truncate[localtime.truncate('millisecond', input)]
| xref:functions-datetime-truncate[datetime.truncate('millisecond', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('millisecond', input)]

| `microsecond`
|
| xref:functions-time-truncate[time.truncate('microsecond', input)]
| xref:functions-localtime-truncate[localtime.truncate('microsecond', input)]
| xref:functions-datetime-truncate[datetime.truncate('microsecond', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('microsecond', input)]

|===


[[functions-date]]
== +date()+

.Details
|===
| *Syntax* 3+| `date( [input] )`
| *Description* 3+| Creates a `DATE` instant.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `input` | `ANY` | Either a string representation of a temporal value, a map containing the single key 'timezone', or a map containing temporal values ('date', 'year', 'month', 'day', 'week', 'dayOfWeek', 'quarter', 'dayOfQuarter', 'ordinalDay') as components.
| *Returns* 3+| `DATE`
|===

.Temporal components
[options="header"]
|===
| Name | Description

| `date`
| A `DATE` value.

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

| `week`
| An integer between `1` and `53` that specifies the week.

| `dayOfWeek`
| An integer between `1` and `7` that specifies the day of the week.

| `quarter`
| An integer between `1` and `4` that specifies the quarter.

| `dayOfQuarter`
| An integer between `1` and `92` that specifies the day of the quarter.

| `ordinalDay`
| An integer between `1` and `366` that specifies the ordinal day of the year.

|===

.Considerations
|===

| If no parameters are provided, `date()` must be invoked (`+date({})+` is invalid).
| If no timezone is specified, the local timezone will be used.
| The _day of the month_ component will default to `1` if `day` is omitted.
| The _month_ component will default to `1` if `month` is omitted.
| If `month` is omitted, `day` must also be omitted.
| The _day of the week_ component will default to `1` if `dayOfWeek` is omitted.
| The _week_ component will default to `1` if `week` is omitted.
| If `week` is omitted, `dayOfWeek` must also be omitted.
| The _day of the quarter_ component will default to `1` if `dayOfQuarter` is omitted.
| The _quarter_ component will default to `1` if `quarter` is omitted.
| If `quarter` is omitted, `dayOfQuarter` must also be omitted.
| The _ordinal day of the year_ component will default to `1` if `ordinalDay` is omitted.
| String representations of temporal values must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-date[dates].
| String representations of temporal values must denote a valid date; i.e. a temporal value denoting `30 February 2001` is invalid.
| `date(null)` returns `null`.
| If any of the optional parameters are provided, these will override the corresponding components of `date`.
| `date(dd)` may be written instead of `+date({date: dd})+`.

|===


.+date()+ to get the current time (no parameters provided)
======

.Query
// tag::functions_temporal_date[]
[source, cypher]
----
RETURN date() AS currentDate
----
// end::functions_temporal_date[]

The current date is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDate
| 2022-06-14
1+d|Rows: 1

|===

======


.+date()+ with provided timezone
======

.Query
[source, cypher, role=test-result-skip]
----
RETURN date({timezone: 'America/Los Angeles'}) AS currentDateInLA
----

The current date in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDateInLA
| 2022-06-14
1+d|Rows: 1

|===

======

[[functions-create-date-values]]
=== Creating `DATE` values

.+date()+ - Creating a calendar (Yeay-Month-Day) `DATE`
======

.Query
[source, cypher]
----
UNWIND [
date({year: 1984, month: 10, day: 11}),
date({year: 1984, month: 10}),
date({year: 1984})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-10-11
| 1984-10-01
| 1984-01-01
1+d|Rows: 3

|===

======


.+date()+ - Creating a week (Year-Week-Day) `DATE`
======

.Query
// tag::functions_temporal_date_transaction[]
[source, cypher]
----
UNWIND [
date({year: 1984, week: 10, dayOfWeek: 3}),
date({year: 1984, week: 10}),
date({year: 1984})
] AS theDate
RETURN theDate
----
// end::functions_temporal_date_transaction[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-03-07
| 1984-03-05
| 1984-01-01
1+d|Rows: 3

|===

======

.+date()+ - Creating a quarter (Year-Quarter-Day) `DATE`
======

.Query
[source, cypher]
----
UNWIND [
date({year: 1984, quarter: 3, dayOfQuarter: 45}),
date({year: 1984, quarter: 3}),
date({year: 1984})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-08-14
| 1984-07-01
| 1984-01-01
1+d|Rows: 3

|===

======


.+date()+ - Creating an ordinal (Year-Day) `DATE`
======

.Query
[source, cypher]
----
UNWIND [
date({year: 1984, ordinalDay: 202}),
date({year: 1984})
] AS theDate
RETURN theDate
----

The date corresponding to `11 February 1984` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-07-20
| 1984-01-01
1+d|Rows: 2

|===

======

.+date()+ -  Creating a `DATE` using other temporal values as components
======

.Query
// tag::functions_temporal_date_statement[]
[source, cypher]
----
UNWIND [
date({year: 1984, month: 11, day: 11}),
localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14}),
datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'})
] AS dd
RETURN date({date: dd}) AS dateOnly, date({date: dd, day: 28}) AS dateDay
----
// end::functions_temporal_date_statement[]

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| dateOnly | +dateDay
| 1984-11-11 | 1984-11-28
| 1984-11-11 | 1984-11-28
| 1984-11-11 | 1984-11-28
2+d|Rows: 3

|===

======


.+date()+ - Creating a `DATE` from a `STRING`
======

.Query
[source, cypher]
----
UNWIND [
date('2015-07-21'),
date('2015-07'),
date('201507'),
date('2015-W30-2'),
date('2015202'),
date('2015')
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 2015-07-21
| 2015-07-01
| 2015-07-01
| 2015-07-21
| 2015-07-21
| 2015-01-01
1+d|Rows: 6

|===

======


[[functions-date-realtime]]
== date.realtime()

.Details
|===
| *Syntax* 3+| `date.realtime([ timezone ])`
| *Description* 3+| Returns the current `DATE` instant using the realtime clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `DATE`
|===

This returned `DATE` will be the live clock of the system.

.+date.realtime()+
======

.Query
// tag::functions_temporal_date_realtime[]
[source, cypher]
----
RETURN date.realtime() AS currentDate
----
// end::functions_temporal_date_realtime[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDate
| 2022-06-14
1+d|Rows: 1

|===

======

.+date.realtime()+
======

.Query
[source, cypher]
----
RETURN date.realtime('America/Los Angeles') AS currentDateInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDateInLA
| 2022-06-14
1+d|Rows: 1

|===

======

[[functions-date-statement]]
== date.statement()

.Details
|===
| *Syntax* 3+| `date.statement([ timezone ])`
| *Description* 3+| Returns the current `DATE` instant using the statement clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `DATE`
|===

This returned `DATE` will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.


.+date.statement()+
======

.Query
[source, cypher]
----
RETURN date.statement() AS currentDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDate
| 2022-06-14
1+d|Rows: 1

|===

======

[[functions-date-transaction]]
== date.transaction()

.Details
|===
| *Syntax* 3+| `date.transaction([ timezone ])`
| *Description* 3+| Returns the current `DATE` instant using the transaction clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `DATE`
|===

The returned `DATE` will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

.+date.transaction()+
======

.Query
[source, cypher]
----
RETURN date.transaction() AS currentDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDate+
| +2022-06-14+
1+d|Rows: 1

|===

======


[[functions-date-truncate]]
== date.truncate()

.Details
|===
| *Syntax* 3+| `date.truncate(unit [, input, fields])`
| *Description* 3+| Truncates the given temporal value to a `DATE` instant using the specified unit.
.4+| *Arguments* | *Name* | *Type* | *Description*
| `unit` | `STRING` | A string representing one of the following: 'day', 'week', 'month', 'weekYear', 'quarter', 'year', 'decade', 'century', 'millennium'.
| `input` | `ANY` | The date to be truncated using either `ZONED DATETIME`, `LOCAL DATETIME`, or `DATE`.
| `fields` | `MAP` | A list of time components smaller than those specified in `unit` to preserve during truncation.
| *Returns* 3+| `DATE`
|===

`date.truncate()` returns the `DATE` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `DATE` returned will have all components that are smaller than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are smaller than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these smaller components.
For example, `day` -- with some value `x` -- may be provided when the truncation unit `STRING` is `'year'` in order to ensure the returned value has the _day_ set to `x` instead of the default _day_ (which is `1`).


.Considerations
|===

| Any component that is provided in `fields` must be smaller than `unit`; i.e. if `unit` `STRING` is `'day'`, `fields` cannot contain information pertaining to a _month_.
| Any component that is not contained in `fields` and which is smaller than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `fields` is not provided, all components of the returned value which are smaller than `unit` will be set to their default values.
| If `input` is not provided, it will be set to the current date, i.e. `date.truncate(unit)` is equivalent of `date.truncate(unit, date())`.

|===


.+date.truncate()+
======

.Query
[source, cypher]
----
WITH
  datetime({
    year: 2017, month: 11, day: 11,
    hour: 12, minute: 31, second: 14, nanosecond: 645876123,
    timezone: '+01:00'
  }) AS d
RETURN
  date.truncate('millennium', d) AS truncMillenium,
  date.truncate('century', d) AS truncCentury,
  date.truncate('decade', d) AS truncDecade,
  date.truncate('year', d, {day: 5}) AS truncYear,
  date.truncate('weekYear', d) AS truncWeekYear,
  date.truncate('quarter', d) AS truncQuarter,
  date.truncate('month', d) AS truncMonth,
  date.truncate('week', d, {dayOfWeek: 2}) AS truncWeek,
  date.truncate('day', d) AS truncDay
----

.Result
[role="queryresult",options="header,footer",cols="9*<m"]
|===

| +truncMillenium+ | +truncCentury+ | +truncDecade+ | +truncYear+ | +truncWeekYear+ | +truncQuarter+ | +truncMonth+ | +truncWeek+ | +truncDay+
| +2000-01-01+ | +2000-01-01+ | +2010-01-01+ | +2017-01-05+ | +2017-01-02+ | +2017-10-01+ | +2017-11-01+ | +2017-11-07+ | +2017-11-11+
9+d|Rows: 1

|===

======

[[functions-datetime]]
== datetime()

.Details
|===
| *Syntax* 3+| `datetime([ input ])`
| *Description* 3+| Creates a `ZONED DATETIME` instant.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `input` | `ANY` | Either a string representation of a temporal value, a map containing the single key 'timezone', or a map containing temporal values ('year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'timezone') as components.
| *Returns* 3+| `ZONED DATETIME`
|===

.Temporal components
[options="header"]
|===
| Name | Description

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the timezone.

| `epochSeconds`
| A numeric value representing the number of seconds from the UNIX epoch in the UTC timezone.

| `epochMillis`
| A numeric value representing the number of milliseconds from the UNIX epoch in the UTC timezone.

|===

.Considerations
|===

| If no parameters are provided, `datetime()` must be invoked (`datetime({})` is invalid).
| The _month_ component will default to `1` if `month` is omitted.
| The _day of the month_ component will default to `1` if `day` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| The _timezone_ component will default to the configured default timezone if `timezone` is omitted.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The smallest components in the set `year`, `month`, `day`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year`, `month` and `day`, but specifying `year`, `month`, `day` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.
| String representations of temporal values must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-date[dates], xref::values-and-types/temporal.adoc#cypher-temporal-specify-time[times] and xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zones].
| String representations of temporal values must denote a valid date; i.e. a temporal value denoting `30 February 2001` is invalid.
| If any of the optional parameters are provided, these will override the corresponding components of `datetime`, `date` and/or `time`.
| `datetime(dd)` may be written instead of `+datetime({datetime: dd})+`.
| Selecting a `ZONED TIME` or `ZONED DATETIME` value as the `time` component also selects its timezone. If a `LOCAL TIME` or `LOCAL DATETIME` is selected instead, the default timezone is used. In any case, the timezone can be overridden explicitly.
| Selecting a `ZONED DATETIME` as the `datetime` component and overwriting the timezone will adjust the local time to keep the same point in time.
| Selecting a `ZONED DATETIME` or `ZONED TIME` as the `time` component and overwriting the timezone will adjust the local time to keep the same point in time.
| `epochSeconds`/`epochMillis` may be used in conjunction with `nanosecond`.
| `datetime(null)` returns null.

|===

.+.datetime()+ to get the current datetime (no parameters provided)
======

.Query
[source, cypher]
----
RETURN datetime() AS currentDateTime
----

The current date and time using the local timezone is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDateTime
| 2022-06-14T10:02:28.192Z
1+d|Rows: 1

|===

======

.+datetime()+ with provided timezone
======

.Query
[source, cypher]
----
RETURN datetime({timezone: 'America/Los Angeles'}) AS currentDateTimeInLA
----

The current date and time of day in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDateTimeInLA
| 2022-06-14T03:02:28.238-07:00[America/Los_Angeles]
1+d|Rows: 1

|===

======

[[functions-create-zoned-datetime-values]]
=== Creating `ZONED DATETIME` values

.+datetime()+ - Creating a calendar (Year-Month-Day) `ZONED DATETIME`
======

.Query
[source, cypher]
----
UNWIND [
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 123, microsecond: 456, nanosecond: 789}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: '+01:00'}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, timezone: '+01:00'}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}),
datetime({year: 1984, month: 10, day: 11, timezone: 'Europe/Stockholm'})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-10-11T12:31:14.123456789Z
| 1984-10-11T12:31:14.645+01:00
| 1984-10-11T12:31:14.645876123+01:00[Europe/Stockholm]
| 1984-10-11T12:31:14+01:00
| 1984-10-11T12:31:14Z
| 1984-10-11T12:31+01:00[Europe/Stockholm]
| 1984-10-11T12:00+01:00
| 1984-10-11T00:00+01:00[Europe/Stockholm]
1+d|Rows: 8

|===

======

.+datetime()+ - Creating a week (Year-Week-Day) `ZONED DATETIME`
======

.Query
[source, cypher]
----
UNWIND [
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, timezone: '+01:00'}),
datetime({year: 1984, week: 10, dayOfWeek: 3, timezone: 'Europe/Stockholm'})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-03-07T12:31:14.645Z
| 1984-03-07T12:31:14.645876+01:00
| 1984-03-07T12:31:14.645876123+01:00[Europe/Stockholm]
| 1984-03-07T12:31:14+01:00[Europe/Stockholm]
| 1984-03-07T12:31:14Z
| 1984-03-07T12:00+01:00
| 1984-03-07T00:00+01:00[Europe/Stockholm]
1+d|Rows: 7

|===

======


.+datetime()+ - Creating a quarter (Year-Quarter-Day) `ZONED DATETIME`
======

.Query
[source, cypher]
----
UNWIND [
datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, microsecond: 645876}),
datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, timezone: '+01:00'}),
datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, quarter: 3, dayOfQuarter: 45})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-08-14T12:31:14.645876Z
| 1984-08-14T12:31:14+01:00
| 1984-08-14T12:00+02:00[Europe/Stockholm]
| 1984-08-14T00:00Z
1+d|Rows: 4

|===

======

.+datetime()+ - Creating an ordinal (Year-Day) `ZONED DATETIME`
======

.Query
[source, cypher]
----
UNWIND [
datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, millisecond: 645}),
datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, timezone: '+01:00'}),
datetime({year: 1984, ordinalDay: 202, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, ordinalDay: 202})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-07-20T12:31:14.645Z
| 1984-07-20T12:31:14+01:00
| 1984-07-20T00:00+02:00[Europe/Stockholm]
| 1984-07-20T00:00Z
1+d|Rows: 4

|===

======


.+datetime()+ - Creating a `ZONED DATETIME` from a `STRING`
======

.Query
[source, cypher]
----
UNWIND [
datetime('2015-07-21T21:40:32.142+0100'),
datetime('2015-W30-2T214032.142Z'),
datetime('2015T214032-0100'),
datetime('20150721T21:40-01:30'),
datetime('2015-W30T2140-02'),
datetime('2015202T21+18:00'),
datetime('2015-07-21T21:40:32.142[Europe/London]'),
datetime('2015-07-21T21:40:32.142-04[America/New_York]')
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 2015-07-21T21:40:32.142+01:00
| 2015-07-21T21:40:32.142Z
| 2015-01-01T21:40:32-01:00
| 2015-07-21T21:40-01:30
| 2015-07-20T21:40-02:00
| 2015-07-21T21:00+18:00
| 2015-07-21T21:40:32.142+01:00[Europe/London]
| 2015-07-21T21:40:32.142-04:00[America/New_York]
1+d|Rows: 8

|===

======


.+datetime()+ - Creating a `ZONED DATETIME` using other temporal values as components
======

The following query shows the various usages of `+datetime({date [, year, ..., timezone]})+`.

.Query
[source, cypher]
----
WITH date({year: 1984, month: 10, day: 11}) AS dd
RETURN
  datetime({date: dd, hour: 10, minute: 10, second: 10}) AS dateHHMMSS,
  datetime({date: dd, hour: 10, minute: 10, second: 10, timezone:'+05:00'}) AS dateHHMMSSTimezone,
  datetime({date: dd, day: 28, hour: 10, minute: 10, second: 10}) AS dateDDHHMMSS,
  datetime({date: dd, day: 28, hour: 10, minute: 10, second: 10, timezone:'Pacific/Honolulu'}) AS dateDDHHMMSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| dateHHMMSS | dateHHMMSSTimezone | dateDDHHMMSS | dateDDHHMMSSTimezone
| 1984-10-11T10:10:10Z | 1984-10-11T10:10:10+05:00 | 1984-10-28T10:10:10Z | 1984-10-28T10:10:10-10:00[Pacific/Honolulu]
4+d|Rows: 1

|===

======


.+datetime()+ - Creating a `ZONED DATETIME` using other temporal values as components
======

The following query shows the various usages of `datetime({time [, year, ..., timezone]})`.

.Query
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS tt
RETURN
  datetime({year: 1984, month: 10, day: 11, time: tt}) AS YYYYMMDDTime,
  datetime({year: 1984, month: 10, day: 11, time: tt, timezone:'+05:00'}) AS YYYYMMDDTimeTimezone,
  datetime({year: 1984, month: 10, day: 11, time: tt, second: 42}) AS YYYYMMDDTimeSS,
  datetime({year: 1984, month: 10, day: 11, time: tt, second: 42, timezone: 'Pacific/Honolulu'}) AS YYYYMMDDTimeSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| YYYYMMDDTime | +YYYYMMDDTimeTimezone | YYYYMMDDTimeSS | YYYYMMDDTimeSSTimezone
| 1984-10-11T12:31:14.645876+01:00 | 1984-10-11T16:31:14.645876+05:00 | 1984-10-11T12:31:42.645876+01:00 | 1984-10-11T01:31:42.645876-10:00[Pacific/Honolulu]
4+d|Rows: 1

|===

======


.+datetime()+ - Creating a `ZONED DATETIME` using other temporal values as components
======

The following query shows the various usages of `+datetime({date, time [, year, ..., timezone]})+`; i.e. combining a `DATE` and a `ZONED TIME` value to create a single `ZONED DATETIME` value.

.Query
[source, cypher]
----
WITH
  date({year: 1984, month: 10, day: 11}) AS dd,
  localtime({hour: 12, minute: 31, second: 14, millisecond: 645}) AS tt
RETURN
  datetime({date: dd, time: tt}) AS dateTime,
  datetime({date: dd, time: tt, timezone: '+05:00'}) AS dateTimeTimezone,
  datetime({date: dd, time: tt, day: 28, second: 42}) AS dateTimeDDSS,
  datetime({date: dd, time: tt, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS dateTimeDDSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| dateTime | dateTimeTimezone | dateTimeDDSS | dateTimeDDSSTimezone
| 1984-10-11T12:31:14.645Z | 1984-10-11T12:31:14.645+05:00 | 1984-10-28T12:31:42.645Z | 1984-10-28T12:31:42.645-10:00[Pacific/Honolulu]
4+d|Rows: 1

|===

======


.+datetime()+ - Creating a `ZONED DATETIME` using other temporal values as components
======

The following query shows the various usages of `+datetime({datetime [, year, ..., timezone]})+`.

.Query
// tag::functions_temporal_datetime[]
[source, cypher]
----
WITH
  datetime({
    year: 1984, month: 10, day: 11,
    hour: 12,
    timezone: 'Europe/Stockholm'
  }) AS dd
RETURN
  datetime({datetime: dd}) AS dateTime,
  datetime({datetime: dd, timezone: '+05:00'}) AS dateTimeTimezone,
  datetime({datetime: dd, day: 28, second: 42}) AS dateTimeDDSS,
  datetime({datetime: dd, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS dateTimeDDSSTimezone
----
// end::functions_temporal_datetime[]

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| dateTime | dateTimeTimezone | dateTimeDDSS | dateTimeDDSSTimezone
| 1984-10-11T12:00+01:00[Europe/Stockholm] | 1984-10-11T16:00+05:00 | 1984-10-28T12:00:42+01:00[Europe/Stockholm] | 1984-10-28T01:00:42-10:00[Pacific/Honolulu]
4+d|Rows: 1

|===

======

.+datetime()+ - Creating a `ZONED DATETIME` from UNIX epoch (`epocSeconds`)
======

`datetime()` returns the `ZONED DATETIME` value at the specified number of _seconds_ or _milliseconds_ from the UNIX epoch in the UTC timezone.

Conversions to other temporal instant types from UNIX epoch representations can be achieved by transforming a `ZONED DATETIME` value to one of these types.

.Query
[source, cypher]
----
RETURN datetime({epochSeconds: timestamp() / 1000, nanosecond: 23}) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 2022-06-14T10:02:30.000000023Z
1+d|Rows: 1

|===

======


.+datetime()+ - Creating a `ZONED DATETIME` from UNIX epoch (`epocMillis`)
======

.Query
[source, cypher]
----
RETURN datetime({epochMillis: 424797300000}) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1983-06-18T15:15Z
1+d|Rows: 1

|===

======


[[functions-datetime-fromepoch]]
== datetime.fromEpoch()

.Details
|===
| *Syntax* 3+| `datetime.fromepoch(seconds, nanoseconds)`
| *Description* 3+| Creates a `ZONED DATETIME` given the seconds and nanoseconds since the start of the epoch.
.3+| *Arguments* | *Name* | *Type* | *Description*
| `seconds` | `INTEGER \| FLOAT` | The number of seconds from the UNIX epoch in the UTC timezone.
| `nanoseconds` | `INTEGER \| FLOAT` | The number of nanoseconds from the UNIX epoch in the UTC timezone. This can be added to seconds.
| *Returns* 3+| `ZONED DATETIME`
|===

.+datetime.fromEpoch()+
======

.Query
[source, cypher]
----
WITH datetime.fromepoch(1683000000, 123456789) AS dateTimeFromEpoch
RETURN dateTimeFromEpoch
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| dateTimeFromEpoch
| 2023-05-02T04:00:00.123456789Z
1+d|Rows: 1

|===
======

[[functions-datetime-fromepochmillis]]
== datetime.fromEpochMillis()

.Details
|===
| *Syntax* 3+| `datetime.fromepochmillis(milliseconds)`
| *Description* 3+| Creates a `ZONED DATETIME` given the milliseconds since the start of the epoch.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `milliseconds` | `INTEGER \| FLOAT` | The number of milliseconds from the UNIX epoch in the UTC timezone.
| *Returns* 3+| `ZONED DATETIME`
|===

.+datetime.fromEpochMillis()+
======

.Query
[source, cypher]
----
WITH datetime.fromepochmillis(1724198400000) AS dateTimeFromMillis
RETURN dateTimeFromMillis
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| dateTimeFromMillis
| 2024-08-21T00:00Z
1+d|Rows: 1

|===
======

[[functions-datetime-realtime]]
== datetime.realtime()

.Details
|===
| *Syntax* 3+| `datetime.realtime([ timezone ])`
| *Description* 3+| Returns the current `ZONED DATETIME` instant using the realtime clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `ZONED DATETIME`
|===

The returned `ZONED DATETIME` will be the live clock of the system.

.+datetime.realtime()+
======

.Query
// tag::functions_temporal_datetime_realtime[]
[source, cypher]
----
RETURN datetime.realtime() AS currentDateTime
----
// end::functions_temporal_datetime_realtime[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDateTime
| 2022-06-14T10:02:28.494444Z
1+d|Rows: 1

|===

======

[[functions-datetime-statement]]
== datetime.statement()

.Details
|===
| *Syntax* 3+| `datetime.statement([ timezone ])`
| *Description* 3+| Returns the current `ZONED DATETIME` instant using the statement clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `ZONED DATETIME`
|===

This returned `ZONED DATETIME` will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.

.+datetime.statement()+
======

.Query
// tag::functions_temporal_datetime_statement[]
[source, cypher]
----
RETURN datetime.statement() AS currentDateTime
----
// end::functions_temporal_datetime_statement[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDateTime
| 2022-06-14T10:02:28.395Z
1+d|Rows: 1

|===

======

[[functions-datetime-transaction]]
== datetime.transaction()

.Details
|===
| *Syntax* 3+| `datetime.transaction([ timezone ])`
| *Description* 3+| Returns the current `ZONED DATETIME` instant using the transaction clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `ZONED DATETIME`
|===

The returned `ZONED DATETIME` value will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

.+datetime.transaction()+
======

.Query
// tag::functions_temporal_datetime_transaction[]
[source, cypher]
----
RETURN datetime.transaction() AS currentDateTime
----
// end::functions_temporal_datetime_transaction[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDateTime
| 2022-06-14T10:02:28.290Z
1+d|Rows: 1

|===

======


.+datetime.transaction()+
======

.Query
[source, cypher]
----
RETURN datetime.transaction('America/Los Angeles') AS currentDateTimeInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentDateTimeInLA
| 2022-06-14T03:02:28.338-07:00[America/Los_Angeles]
1+d|Rows: 1

|===

======


[[functions-datetime-truncate]]
== datetime.truncate()

.Details
|===
| *Syntax* 3+| `datetime.truncate(unit [, input, fields])`
| *Description* 3+| Truncates the given temporal value to a `ZONED DATETIME` instant using the specified unit.
.4+| *Arguments* | *Name* | *Type* | *Description*
| `unit` | `STRING` | A string representing one of the following: 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'weekYear', 'quarter', 'year', 'decade', 'century', 'millennium'.
| `input` | `ANY` | The date to be truncated using either `ZONED DATETIME`, `LOCAL DATETIME`, or `DATE`.
| `fields` | `MAP` | A list of time components smaller than those specified in `unit` to preserve during truncation.
| *Returns* 3+| `ZONED DATETIME`
|===


`datetime.truncate()` returns the `ZONED DATETIME` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `ZONED DATETIME` returned will have all components that are smaller than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are smaller than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these smaller components.
For example, `day` -- with some value `x` -- may be provided when the truncation unit `STRING` is `'year'` in order to ensure the returned value has the _day_ set to `x` instead of the default _day_ (which is `1`).


.Considerations
|===

| `input` cannot be a `DATE` value if `unit` is one of: `'hour'`, `'minute'`, `'second'`, `'millisecond'`, `'microsecond'`.
| The timezone of `input` may be overridden; for example, `+datetime.truncate('minute', input, {timezone: '+0200'})+`.
| If `input` is one of `ZONED TIME`, `ZONED DATETIME` -- a value with a timezone -- and the timezone is overridden, no time conversion occurs.
| If `input` is one of `LOCAL DATETIME`, `DATE` -- a value without a timezone -- and the timezone is not overridden, the configured default timezone will be used.
| Any component that is provided in `fields` must be smaller than `unit`; i.e. if `unit` is `'day'`, `fields` cannot contain information pertaining to a _month_.
| Any component that is not contained in `fields` and which is smaller than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `fields` is not provided, all components of the returned value which are smaller than `unit` will be set to their default values.
| If `input` is not provided, it will be set to the current date, time and timezone, i.e. `datetime.truncate(unit)` is equivalent of `datetime.truncate(unit, datetime())`.

|===


.+datetime.truncate()+
======

.Query
[source, cypher]
----
WITH
  datetime({
    year:2017, month:11, day:11,
    hour:12, minute:31, second:14, nanosecond: 645876123,
    timezone: '+03:00'
  }) AS d
RETURN
  datetime.truncate('millennium', d, {timezone: 'Europe/Stockholm'}) AS truncMillenium,
  datetime.truncate('year', d, {day: 5}) AS truncYear,
  datetime.truncate('month', d) AS truncMonth,
  datetime.truncate('day', d, {millisecond: 2}) AS truncDay,
  datetime.truncate('hour', d) AS truncHour,
  datetime.truncate('second', d) AS truncSecond
----

.Result
[role="queryresult",options="header,footer",cols="6*<m"]
|===

| truncMillenium | truncYear | truncMonth | truncDay | truncHour | truncSecond
| 2000-01-01T00:00+01:00[Europe/Stockholm] | 2017-01-05T00:00+03:00 | 2017-11-01T00:00+03:00 | 2017-11-11T00:00:00.002+03:00 | 2017-11-11T12:00+03:00 | 2017-11-11T12:31:14+03:00
6+d|Rows: 1

|===

======


[[functions-localdatetime]]
== localdatetime()

.Details
|===
| *Syntax* 3+| `localdatetime([ input ])`
| *Description* 3+| Creates a `LOCAL DATETIME` instant.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `input` | `ANY` | Either a string representation of a temporal value, a map containing the single key 'timezone', or a map containing temporal values ('year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond') as components.
| *Returns* 3+| `LOCAL DATETIME`
|===

.Temporal components
[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

.Considerations
|===

| If no parameters are provided, `localdatetime()` must be invoked (+localdatetime({})+ is invalid).
| The _month_ component will default to `1` if `month` is omitted.
| The _day of the month_ component will default to `1` if `day` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The smallest components in the set `year`, `month`, `day`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year`, `month` and `day`, but specifying `year`, `month`, `day` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.
| String representations of temporal values must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-date[dates] and xref::values-and-types/temporal.adoc#cypher-temporal-specify-time[times].
|  String representations of temporal values must denote a valid date; i.e. a temporal value denoting `30 February 2001` is invalid.
| `localdatetime(null)` returns null.
| If any of the optional parameters are provided, these will override the corresponding components of `datetime`, `date` and/or `time`.
| `localdatetime(dd)` may be written instead of `+localdatetime({datetime: dd})+`.

|===


.+localdatetime()+ - to get current local date and time (no parameters)
======

.Query
// tag::functions_temporal_localtime[]
[source, cypher]
----
RETURN localdatetime() AS now
----
// end::functions_temporal_localtime[]

The current local date and time (i.e. in the local timezone) is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| now
| 2022-06-14T10:02:30.447
1+d|Rows: 1

|===

======


.+localdatetime()+ with timezone
======

.Query
[source, cypher]
----
RETURN localdatetime({timezone: 'America/Los Angeles'}) AS now
----

The current local date and time in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| now
| 2022-06-14T03:02:30.482
1+d|Rows: 1

|===

======

[[functions-locadateltime-create]]
=== Creating `LOCAL DATETIME` values

.+localdatetime()+ - Creating a calendar (Year-Month-Day) `LOCAL DATETIME`
======

.Query
// tag::functions_temporal_localtime_transaction[]
[source, cypher]
----
RETURN
  localdatetime({
    year: 1984, month: 10, day: 11,
    hour: 12, minute: 31, second: 14, millisecond: 123, microsecond: 456, nanosecond: 789
  }) AS theDate
----
// end::functions_temporal_localtime_transaction[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-10-11T12:31:14.123456789
1+d|Rows: 1

|===

======


.+localdatetime()+ - Creating a week (Year-Week-Day) `LOCAL DATETIME`
======

.Query
[source, cypher]
----
RETURN
  localdatetime({
    year: 1984, week: 10, dayOfWeek: 3,
    hour: 12, minute: 31, second: 14, millisecond: 645
  }) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-03-07T12:31:14.645
1+d|Rows: 1

|===

======

.+localdatetime()+ - Creating a quarter (Year-Quarter-Day) `ZONED DATETIME`
======

.Query
// tag::functions_temporal_localtime_statement[]
[source, cypher]
----
RETURN
  localdatetime({
    year: 1984, quarter: 3, dayOfQuarter: 45,
    hour: 12, minute: 31, second: 14, nanosecond: 645876123
  }) AS theDate
----
// end::functions_temporal_localtime_statement[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-08-14T12:31:14.645876123
1+d|Rows: 1

|===

======


.+localdatetime()+ - Creating an ordinal (Year-Day) `LOCAL DATETIME`
======

.Query
[source, cypher]
----
RETURN
  localdatetime({
    year: 1984, ordinalDay: 202,
    hour: 12, minute: 31, second: 14, microsecond: 645876
  }) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 1984-07-20T12:31:14.645876
1+d|Rows: 1

|===

======

.+localdatetime()+ - Creating a `LOCAL DATETIME` from a `STRING`
======

.Query
[source, cypher]
----
UNWIND [
localdatetime('2015-07-21T21:40:32.142'),
localdatetime('2015-W30-2T214032.142'),
localdatetime('2015-202T21:40:32'),
localdatetime('2015202T21')
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theDate
| 2015-07-21T21:40:32.142
| 2015-07-21T21:40:32.142
| 2015-07-21T21:40:32
| 2015-07-21T21:00
1+d|Rows: 4

|===

======


.+localdatetime()+ - Creating a `LOCAL DATETIME` using other temporal values as components
======

The following query shows the various usages of `+localdatetime({date [, year, ..., nanosecond]})+`.

.Query
// tag::functions_temporal_localtime_realtime[]
[source, cypher]
----
WITH date({year: 1984, month: 10, day: 11}) AS dd
RETURN
  localdatetime({date: dd, hour: 10, minute: 10, second: 10}) AS dateHHMMSS,
  localdatetime({date: dd, day: 28, hour: 10, minute: 10, second: 10}) AS dateDDHHMMSS
----
// end::functions_temporal_localtime_realtime[]

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| dateHHMMSS | dateDDHHMMSS
| 1984-10-11T10:10:10 | 1984-10-28T10:10:10
2+d|Rows: 1

|===

======


.+localdatetime()+ - Creating a `LOCAL DATETIME` using other temporal values as components
======

The following query shows the various usages of `+localdatetime({time [, year, ..., nanosecond]})+`.

.Query
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS tt
RETURN
  localdatetime({year: 1984, month: 10, day: 11, time: tt}) AS YYYYMMDDTime,
  localdatetime({year: 1984, month: 10, day: 11, time: tt, second: 42}) AS YYYYMMDDTimeSS
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| YYYYMMDDTime | YYYYMMDDTimeSS
| 1984-10-11T12:31:14.645876 | 1984-10-11T12:31:42.645876
2+d|Rows: 1

|===

======


.+localdatetime()+ - Creating a `LOCAL DATETIME` using other temporal values as components
======

The following query shows the various usages of `+localdatetime({date, time [, year, ..., nanosecond]})+`; i.e. combining a `DATE` and a `ZONED TIME` value to create a single `LOCAL DATETIME` value.

.Query
[source, cypher]
----
WITH
  date({year: 1984, month: 10, day: 11}) AS dd,
  time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS tt
RETURN
  localdatetime({date: dd, time: tt}) AS dateTime,
  localdatetime({date: dd, time: tt, day: 28, second: 42}) AS dateTimeDDSS
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| dateTime | dateTimeDDSS
| 1984-10-11T12:31:14.645876 | 1984-10-28T12:31:42.645876
2+d|Rows: 1

|===

======


.+localdatetime()+ - Creating a `LOCAL DATETIME` using other temporal values as components
======

The following query shows the various usages of `+localdatetime({datetime [, year, ..., nanosecond]})+`.

.Query
[source, cypher]
----
WITH
  datetime({
    year: 1984, month: 10, day: 11,
    hour: 12,
    timezone: '+01:00'
  }) AS dd
RETURN
  localdatetime({datetime: dd}) AS dateTime,
  localdatetime({datetime: dd, day: 28, second: 42}) AS dateTimeDDSS
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| dateTime | dateTimeDDSS
| 1984-10-11T12:00 | 1984-10-28T12:00:42
2+d|Rows: 1

|===

======


[[functions-localdatetime-realtime]]
== localdatetime.realtime()

.Details
|===
| *Syntax* 3+| `localdatetime.realtime([ timezone ])`
| *Description* 3+| Returns the current `LOCAL DATETIME` instant using the realtime clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `LOCAL DATETIME`
|===


The returned `LOCAL DATETIME` will be the live clock of the system.


.+localdatetime.realtime()+
======

.Query
// tag::functions_temporal_localdatetime_realtime[]
[source, cypher]
----
RETURN localdatetime.realtime() AS now
----
// end::functions_temporal_localdatetime_realtime[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +2022-06-14T10:02:30.647817+
1+d|Rows: 1

|===

======


.+localdatetime.realtime()+
======

.Query
[source, cypher]
----
RETURN localdatetime.realtime('America/Los Angeles') AS nowInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +nowInLA+
| +2022-06-14T03:02:30.691099+
1+d|Rows: 1

|===

======


[[functions-localdatetime-statement]]
== localdatetime.statement()

.Details
|===
| *Syntax* 3+| `localdatetime.statement([ timezone ])`
| *Description* 3+| Returns the current `LOCAL DATETIME` instant using the statement clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `LOCAL DATETIME`
|===

The returned `LOCAL DATETIME` will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.


.+localdatetime.statement()+
======

.Query
// tag::functions_temporal_localdatetime_statement[]
[source, cypher]
----
RETURN localdatetime.statement() AS now
----
// end::functions_temporal_localdatetime_statement[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| now
| 2022-06-14T10:02:30.570
1+d|Rows: 1

|===

======

[[functions-localdatetime-transaction]]
== localdatetime.transaction()

.Details
|===
| *Syntax* 3+| `localdatetime.transaction([ timezone ])`
| *Description* 3+| Returns the current `LOCAL DATETIME` instant using the transaction clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `LOCAL DATETIME`
|===

The returned `LOCAL DATETIME` will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

.+localdatetime.transaction()+
======

.Query
// tag::functions_temporal_localdatetime_transaction[]
[source, cypher]
----
RETURN localdatetime.transaction() AS now
----
// end::functions_temporal_localdatetime_transaction[]


.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +2022-06-14T10:02:30.532+
1+d|Rows: 1

|===

======


[[functions-localdatetime-truncate]]
== localdatetime.truncate()

.Details
|===
| *Syntax* 3+| `localdatetime.truncate(unit [, input, fields])`
| *Description* 3+| Truncates the given temporal value to a `LOCAL DATETIME` instant using the specified unit.
.4+| *Arguments* | *Name* | *Type* | *Description*
| `unit` | `STRING` | A string representing one of the following: 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'weekYear', 'quarter', 'year', 'decade', 'century', 'millennium'.
| `input` | `ANY` | The date to be truncated using either `ZONED DATETIME`, `LOCAL DATETIME`, or `DATE`.
| `fields` | `MAP` | A list of time components smaller than those specified in `unit` to preserve during truncation.
| *Returns* 3+| `LOCAL DATETIME`
|===

`localdatetime.truncate()` returns the `LOCAL DATETIME` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `LOCAL DATETIME` returned will have all components that are smaller than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are smaller than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these smaller components.
For example, `day` -- with some value `x` -- may be provided when the truncation unit `STRING` is `'year'` in order to ensure the returned value has the _day_ set to `x` instead of the default _day_ (which is `1`).

.Considerations
|===

| `input` cannot be a `DATE` value if `unit` is one of: `'hour'`, `'minute'`, `'second'`, `'millisecond'`, `'microsecond'`.
| Any component that is provided in `fields` must be smaller than `input`; i.e. if `input` is `'day'`, `fields` cannot contain information pertaining to a _month_.
| Any component that is not contained in `fields` and which is smaller than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `fields` is not provided, all components of the returned value which are smaller than `unit` will be set to their default values.
| If `input` is not provided, it will be set to the current date and time, i.e. `localdatetime.truncate(unit)` is equivalent of `localdatetime.truncate(unit, localdatetime())`.

|===


.+localdatetime.truncate()+
======

.Query
[source, cypher]
----
WITH
  localdatetime({
    year: 2017, month: 11, day: 11,
    hour: 12, minute: 31, second: 14, nanosecond: 645876123
  }) AS d
RETURN
  localdatetime.truncate('millennium', d) AS truncMillenium,
  localdatetime.truncate('year', d, {day: 2}) AS truncYear,
  localdatetime.truncate('month', d) AS truncMonth,
  localdatetime.truncate('day', d) AS truncDay,
  localdatetime.truncate('hour', d, {nanosecond: 2}) AS truncHour,
  localdatetime.truncate('second', d) AS truncSecond
----

.Result
[role="queryresult",options="header,footer",cols="6*<m"]
|===

| truncMillenium | truncYear | truncMonth | truncDay | truncHour | truncSecond
| 2000-01-01T00:00 | 2017-01-02T00:00 | 2017-11-01T00:00 | 2017-11-11T00:00 | 2017-11-11T12:00:00.000000002 | 2017-11-11T12:31:14
6+d|Rows: 1

|===

======


[[functions-localtime]]
== localtime()

.Details
|===
| *Syntax* 3+| `localtime([ input ])`
| *Description* 3+| Creates a `LOCAL TIME` instant.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `input` | `ANY` | Either a string representation of a temporal value, a map containing the single key 'timezone', or a map containing temporal values ('hour, 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond' as components.
| *Returns* 3+| `LOCAL TIME`
|===

.Temporal components
[options="header"]
|===
| Name | Description

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

.Considerations
|===

| If no parameters are provided, `localtime()` must be invoked (`+localtime({})+` is invalid).
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The smallest components in the set `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `hour` and `minute`, but specifying `hour` and `second` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.
|  String representations of temporal values must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-time[times].
| String representations of temporal values must denote a valid time; i.e. a temporal value denoting `13:46:64` is invalid.
| `localtime(null)` returns null.
| If any of the optional parameters are provided, these will override the corresponding components of `time`.
| `localtime(tt)` may be written instead of `localtime({time: tt})`.

|===

.+localtime()+ to get the current time (no parameters)
======

.Query
[source, cypher]
----
RETURN localtime() AS now
----

The current local time (i.e. in the local timezone) is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| now
| 10:02:31.596
1+d|Rows: 1

|===

======


.+localtime()+ with timezone
======

.Query
// tag::functions_temporal_time[]
[source, cypher]
----
RETURN localtime({timezone: 'America/Los Angeles'}) AS nowInLA
----
// end::functions_temporal_time[]

The current local time in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| nowInLA
| 03:02:31.629
1+d|Rows: 1

|===

======

[[functions-localtime-create]]
=== Creating `LOCAL TIME` values

.+localtime()+
======

.Query
[source, cypher]
----
UNWIND [
localtime({hour: 12, minute: 31, second: 14, nanosecond: 789, millisecond: 123, microsecond: 456}),
localtime({hour: 12, minute: 31, second: 14}),
localtime({hour: 12})
] AS theTime
RETURN theTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theTime
| 12:31:14.123456789
| 12:31:14
| 12:00
1+d|Rows: 3

|===

======

.+localtime()+ - Creating a `LOCAL TIME` from a `STRING`
======

.Query
[source, cypher]
----
UNWIND [
localtime('21:40:32.142'),
localtime('214032.142'),
localtime('21:40'),
localtime('21')
] AS theTime
RETURN theTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theTime
| 21:40:32.142
| 21:40:32.142
| 21:40
| 21:00
1+d|Rows: 4

|===

======


.+localtime()+ - Creating a `LOCAL TIME` using other temporal values as components
======

.Query
// tag::functions_temporal_time_transaction[]
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS tt
RETURN
  localtime({time: tt}) AS timeOnly,
  localtime({time: tt, second: 42}) AS timeSS
----
// end::functions_temporal_time_transaction[]

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| timeOnly | timeSS
| 12:31:14.645876 | 12:31:42.645876
2+d|Rows: 1

|===

======


[[functions-localtime-realtime]]
== localtime.realtime()

.Details
|===
| *Syntax* 3+| `localtime.realtime([ timezone ])`
| *Description* 3+| Returns the current `LOCAL TIME` instant using the realtime clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `LOCAL TIME`
|===

The returned `LOCAL TIME`  will be the live clock of the system.

.+localtime.realtime()+
======

.Query
[source, cypher]
----
RETURN localtime.realtime() AS now
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| now
| 10:02:31.806895
1+d|Rows: 1

|===

======

[[functions-localtime-statement]]
== localtime.statement()

.Details
|===
| *Syntax* 3+| `localtime.statement([ timezone ])`
| *Description* 3+| Returns the current `LOCAL TIME` instant using the statement clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `LOCAL TIME`
|===

This returned `LOCAL TIME` will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.

.+localtime.statement()+
======

.Query
// tag::functions_temporal_time_statement[]
[source, cypher]
----
RETURN localtime.statement() AS now
----
// end::functions_temporal_time_statement[]

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| now
| 10:02:31.697
1+d|Rows: 1

|===

======


.+localtime.statement()+
======

.Query
[source, cypher]
----
RETURN localtime.statement('America/Los Angeles') AS nowInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| nowInLA
| 03:02:31.737
1+d|Rows: 1

|===

======

[[functions-localtime-transaction]]
== localtime.transaction()

.Details
|===
| *Syntax* 3+| `localtime.transaction([ timezone ])`
| *Description* 3+| Returns the current `LOCAL TIME` instant using the transaction clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `LOCAL TIME`
|===

The returned `LOCAL TIME` will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.


.+localtime.transaction()+
======

.Query
[source, cypher]
----
RETURN localtime.transaction() AS now
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| now
| 10:02:31.662
1+d|Rows: 1

|===

======

[[functions-localtime-truncate]]
== localtime.truncate()

.Details
|===
| *Syntax* 3+| `localtime.truncate(unit [, input, fields])`
| *Description* 3+| Truncates the given temporal value to a `LOCAL TIME` instant using the specified unit.
.4+| *Arguments* | *Name* | *Type* | *Description*
| `unit` | `STRING` | A string representing one of the following: 'day', 'week', 'month', 'weekYear', 'quarter', 'year', 'decade', 'century', 'millennium'.
| `input` | `ANY` | The date to be truncated using either `ZONED DATETIME`, `LOCAL DATETIME`, `LOCAL TIME`, or `DATE`.
| `fields` | `MAP` | A list of time components smaller than those specified in `unit` to preserve during truncation.
| *Returns* 3+| `LOCAL TIME`
|===

`localtime.truncate()` returns the `LOCAL TIME` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `LOCAL TIME` returned will have all components that are smaller than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are smaller than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these smaller components.
For example, `minute` -- with some value `x` -- may be provided when the truncation unit string is `'hour'` in order to ensure the returned value has the _minute_ set to `x` instead of the default _minute_ (which is `1`).


.Considerations
|===

a|
Truncating time to day -- i.e. `unit` is `'day'`  -- is supported, and yields midnight at the start of the day (`00:00`), regardless of the value of `input`.
However, the timezone of `input` is retained.
| Any component that is provided in `fields` must be smaller than `unit`; i.e. if `unit` is `'second'`, `fields` cannot contain information pertaining to a _minute_.
| Any component that is not contained in `fields` and which is smaller than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `fields` is not provided, all components of the returned value which are smaller than `unit` will be set to their default values.
| If `input` is not provided, it will be set to the current time, i.e. `localtime.truncate(unit)` is equivalent of `localtime.truncate(unit, localtime())`.

|===


.+localtime.truncate()+
======

.Query
// tag::functions_temporal_time_realtime[]
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}) AS t
RETURN
  localtime.truncate('day', t) AS truncDay,
  localtime.truncate('hour', t) AS truncHour,
  localtime.truncate('minute', t, {millisecond: 2}) AS truncMinute,
  localtime.truncate('second', t) AS truncSecond,
  localtime.truncate('millisecond', t) AS truncMillisecond,
  localtime.truncate('microsecond', t) AS truncMicrosecond
----
// end::functions_temporal_time_realtime[]

.Result
[role="queryresult",options="header,footer",cols="6*<m"]
|===

| truncDay | truncHour | truncMinute | truncSecond | truncMillisecond | truncMicrosecond
| 00:00:00 | 12:00:00 | 12:31:00.002000000 | 12:31:14 | 12:31:14.645000000 | 12:31:14.645876000
6+d|Rows: 1

|===

======


[[functions-time]]
== time()

.Details
|===
| *Syntax* 3+| `time([ input ])`
| *Description* 3+| Creates a `ZONED TIME` instant.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `input` | `ANY` | Either a string representation of a temporal value, a map containing the single key 'timezone', or a map containing temporal values ('hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'timezone') as components.
| *Returns* 3+| `ZONED TIME`
|===

.Temporal components
[options="header"]
|===
| Name | Description

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the timezone.

|===

.Considerations
|===

| If no parameters are provided, `time()` must be invoked (`+time({})+` is invalid).
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| The _timezone_ component will default to the configured default timezone if `timezone` is omitted.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The smallest components in the set `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `hour` and `minute`, but specifying `hour` and `second` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.
| String representations of temporal values must comply with the format defined for  xref::values-and-types/temporal.adoc#cypher-temporal-specify-time[times] and xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zones].
| The _timezone_ component will default to the configured default timezone if it is omitted.
| String representations of temporal values must denote a valid time; i.e. a `temporalValue` denoting `15:67` is invalid.
| `time(null)` returns `null`.
| If any of the optional parameters are provided, these will override the corresponding components of `time`.
| `time(tt)` may be written instead of `+time({time: tt})+`.
| Selecting a `ZONED TIME` or `ZONED DATETIME` value as the `time` component also selects its timezone. If a `LOCAL TIME` or `LOCAL DATETIME` is selected instead, the default timezone is used. In any case, the timezone can be overridden explicitly.
| Selecting a `ZONED DATETIME` or `ZONED TIME` as the `time` component and overwriting the timezone will adjust the local time to keep the same point in time.

|===


.+time()+ to get the current time (no parameters)
======

.Query
[source, cypher]
----
RETURN time() AS currentTime
----

The current time of day using the local timezone is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentTime
| 10:02:32.192Z
1+d|Rows: 1

|===

======


.+time()+ with timezone
======

.Query
[source, cypher]
----
RETURN time({timezone: 'America/Los Angeles'}) AS currentTimeInLA
----

The current time of day in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentTimeInLA
| 03:02:32.233-07:00
1+d|Rows: 1

|===

======

[[functions-time-create]]
=== Creating `ZONED TIME` values

.+time()+
======

.Query
[source, cypher]
----
UNWIND [
time({hour: 12, minute: 31, second: 14, millisecond: 123, microsecond: 456, nanosecond: 789}),
time({hour: 12, minute: 31, second: 14, nanosecond: 645876123}),
time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}),
time({hour: 12, minute: 31, timezone: '+01:00'}),
time({hour: 12, timezone: '+01:00'})
] AS theTime
RETURN theTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theTime
| 12:31:14.123456789Z
| 12:31:14.645876123Z
| 12:31:14.645876000+01:00
| 12:31:00+01:00
| 12:00:00+01:00
1+d|Rows: 5

|===

======


.+time()+ - Creating a `ZONED TIME` from a `STRING`
======

.Query
[source, cypher]
----
UNWIND [
time('21:40:32.142+0100'),
time('214032.142Z'),
time('21:40:32+01:00'),
time('214032-0100'),
time('21:40-01:30'),
time('2140-00:00'),
time('2140-02'),
time('22+18:00')
] AS theTime
RETURN theTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| theTime
| 21:40:32.142000000+01:00
| 21:40:32.142000000Z
| 21:40:32+01:00
| 21:40:32-01:00
| 21:40:00-01:30
| 21:40:00Z
| 21:40:00-02:00
| 22:00:00+18:00
1+d|Rows: 8

|===

======


.+time()+ - Creating a `ZONED TIME` using other temporal values as components
======

.Query
[source, cypher]
----
WITH localtime({hour: 12, minute: 31, second: 14, microsecond: 645876}) AS tt
RETURN
  time({time: tt}) AS timeOnly,
  time({time: tt, timezone: '+05:00'}) AS timeTimezone,
  time({time: tt, second: 42}) AS timeSS,
  time({time: tt, second: 42, timezone: '+05:00'}) AS timeSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| timeOnly | timeTimezone | timeSS | timeSSTimezone
| 12:31:14.645876Z | 12:31:14.645876+05:00 | 12:31:42.645876Z | 12:31:42.645876+05:00
4+d|Rows: 1

|===

======

[[functions-time-realtime]]
== time.realtime()

.Details
|===
| *Syntax* 3+| `time.realtime([ timezone ])`
| *Description* 3+| Returns the current `ZONED TIME` instant using the realtime clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `ZONED TIME`
|===

The returned `ZONED TIME` will be the live clock of the system.


.+time.realtime()+
======

.Query
[source, cypher]
----
RETURN time.realtime() AS currentTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentTime+
| +10:02:32.436948Z+
1+d|Rows: 1

|===

======

[[functions-time-statement]]
== time.statement()

.Details
|===
| *Syntax* 3+| `time.statement([ timezone ])`
| *Description* 3+| Returns the current `ZONED TIME` instant using the statement clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `ZONED TIME`
|===

The returned `ZONED TIME` will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.

.+time.statement()+
======

.Query
[source, cypher]
----
RETURN time.statement() AS currentTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentTime
| 10:02:32.317Z
1+d|Rows: 1

|===

======


.+time.statement()+
======

.Query
[source, cypher]
----
RETURN time.statement('America/Los Angeles') AS currentTimeInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| currentTimeInLA
| 03:02:32.351-07:00
1+d|Rows: 1

|===

======


[[functions-time-transaction]]
== time.transaction()

.Details
|===
| *Syntax* 3+| `time.transaction([ timezone ])`
| *Description* 3+| Returns the current `ZONED TIME` instant using the transaction clock.
.2+| *Arguments* | *Name* | *Type* | *Description*
| `timezone` | `ANY` | A string value representing a timezone.
| *Returns* 3+| `ZONED TIME`
|===

The returned `ZONED TIME` will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

.+time.transaction()+
======

.Query
[source, cypher]
----
RETURN time.transaction() AS currentTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| currentTime
| 10:02:32.276Z
1+d|Rows: 1
|===

======

[[functions-time-truncate]]
== time.truncate()

.Details
|===
| *Syntax* 3+| `time.truncate(unit [, input, fields])`
| *Description* 3+| Truncates the given temporal value to a `ZONED TIME` instant using the specified unit.
.4+| *Arguments* | *Name* | *Type* | *Description*
| `unit` | `STRING` | A string representing one of the following: 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.
| `input` | `ANY` | The date to be truncated using either `ZONED DATETIME`, `LOCAL DATETIME`, `ZONED TIME`, or `LOCAL TIME`.
| `fields` | `MAP` | A list of time components smaller than those specified in `unit` to preserve during truncation.
| *Returns* 3+| `ZONED TIME`
|===

`time.truncate()` returns the `ZONED TIME` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `ZONED TIME` returned will have all components that are smaller than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are smaller than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these smaller components.
For example, `minute` -- with some value `x` -- may be provided when the truncation unit `STRING` is `'hour'` in order to ensure the returned value has the _minute_ set to `x` instead of the default _minute_ (which is `1`).


.Considerations
|===

| Truncating time to day -- i.e. `unit` is `'day'`  -- is supported, and yields midnight at the start of the day (`00:00`), regardless of the value of `input`. However, the timezone of `input` is retained.
| The timezone of `input` may be overridden; for example, `+time.truncate('minute', input, {timezone: '+0200'})+`.
| If `input` is one of `ZONED TIME`, `ZONED DATETIME` -- a value with a timezone -- and the timezone is overridden, no time conversion occurs.
| If `input` is one of `LOCAL TIME`, `LOCAL DATETIME`, `DATE` -- a value without a timezone -- and the timezone is not overridden, the configured default timezone will be used.
| Any component that is provided in `fields` must be smaller than `unit`; i.e. if `unit` is `'second'`, `fields` cannot contain information pertaining to a _minute_.
| Any component that is not contained in `fields` and which is smaller than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `fields` is not provided, all components of the returned value which are smaller than `unit` will be set to their default values.
| If `input` is not provided, it will be set to the current time and timezone, i.e. `time.truncate(unit)` is equivalent of `time.truncate(unit, time())`.
|===


.+time()+
======

.Query
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}) AS t
RETURN
  time.truncate('day', t) AS truncDay,
  time.truncate('hour', t) AS truncHour,
  time.truncate('minute', t) AS truncMinute,
  time.truncate('second', t) AS truncSecond,
  time.truncate('millisecond', t, {nanosecond: 2}) AS truncMillisecond,
  time.truncate('microsecond', t) AS truncMicrosecond
----

.Result
[role="queryresult",options="header,footer",cols="6*<m"]
|===

| truncDay | truncHour | truncMinute | truncSecond | truncMillisecond | truncMicrosecond
| 00:00:00-01:00 | 12:00:00-01:00 | 12:31:00-01:00 | 12:31:14-01:00 | 12:31:14.645000002-01:00 | 12:31:14.645876000-01:00
6+d|Rows: 1

|===

======

