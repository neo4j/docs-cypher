:description: Cypher provides functions allowing for the creation and manipulation of values for each temporal type -- `DATE`, `ZONED TIME`, `LOCAL TIME`, `ZONED DATETIME`, and `LOCAL DATETIME`.

[[query-functions-temporal-instant-types]]
= Temporal functions - instant types

Temporal functions allow for the creation and manipulation of values for each temporal type -- `DATE`, `ZONED TIME`, `LOCAL TIME`, `ZONED DATETIME`, and `LOCAL DATETIME`.

[NOTE]
====
See also xref::values-and-types/temporal.adoc[Temporal (Date/Time) values] and xref::syntax/operators.adoc#query-operators-temporal[Temporal operators].
====


[[functions-temporal-instant-type]]
== Temporal instant types

[[functions-temporal-create-overview]]
=== An overview of temporal instant type creation

Each function bears the same name as the type, and construct the type they correspond to in one of four ways:

* Capturing the current time.
* Composing the components of the type.
* Parsing a `STRING` representation of the temporal value.
* Selecting and composing components from another temporal value by
 ** either combining temporal values (such as combining a `DATE` with a `ZONED TIME` to create a `ZONED DATETIME`), or
 ** selecting parts from a temporal value (such as selecting the `DATE` from a `ZONED DATETIME`); the _extractors_ -- groups of components which can be selected -- are:
  *** `date` -- contains all components for a `DATE` (conceptually _year_, _month_ and _day_).
  *** `time` -- contains all components for a `ZONED TIME` (_hour_, _minute_, _second_, and sub-seconds; namely _millisecond_, _microsecond_ and _nanosecond_).
  If the type being created and the type from which the time component is being selected both contain `timezone` (and a `timezone` is not explicitly specified) the `timezone` is also selected.
  *** `datetime` -- selects all components, and is useful for overriding specific components.
  Analogously to `time`, if the type being created and the type from which the time component is being selected both contain `timezone` (and a `timezone` is not explicitly specified) the `timezone` is also selected.
 ** In effect, this allows for the _conversion_ between different temporal types, and allowing for 'missing' components to be specified.


.Temporal instant type creation functions
[options="header"]
|===
| Function | Date | Time | LocalTime | DateTime | LocalDateTime

| Getting the current value.
| xref::functions/temporal/index.adoc#functions-date-current[X]
| xref::functions/temporal/index.adoc#functions-time-current[X]
| xref::functions/temporal/index.adoc#functions-localtime-current[X]
| xref::functions/temporal/index.adoc#functions-datetime-current[X]
| xref::functions/temporal/index.adoc#functions-localdatetime-current[X]

| Creating a calendar-based (Year-Month-Day) value.
| xref::functions/temporal/index.adoc#functions-date-calendar[X]
|
|
| xref::functions/temporal/index.adoc#functions-datetime-calendar[X]
| xref::functions/temporal/index.adoc#functions-localdatetime-calendar[X]

| Creating a week-based (Year-Week-Day) value.
| xref::functions/temporal/index.adoc#functions-date-week[X]
|
|
| xref::functions/temporal/index.adoc#functions-datetime-week[X]
| xref::functions/temporal/index.adoc#functions-localdatetime-week[X]

| Creating a quarter-based (Year-Quarter-Day) value.
| xref::functions/temporal/index.adoc#functions-date-quarter[X]
|
|
| xref::functions/temporal/index.adoc#functions-datetime-quarter[X]
| xref::functions/temporal/index.adoc#functions-localdatetime-quarter[X]

| Creating an ordinal (Year-Day) value.
| xref::functions/temporal/index.adoc#functions-date-ordinal[X]
|
|
| xref::functions/temporal/index.adoc#functions-datetime-ordinal[X]
| xref::functions/temporal/index.adoc#functions-localdatetime-ordinal[X]

| Creating a value from time components.
|
| xref::functions/temporal/index.adoc#functions-time-create[X]
| xref::functions/temporal/index.adoc#functions-localtime-create[X]
|
|

| Creating a value from other temporal values using extractors (i.e. converting between different types).
| xref::functions/temporal/index.adoc#functions-date-temporal[X]
| xref::functions/temporal/index.adoc#functions-time-temporal[X]
| xref::functions/temporal/index.adoc#functions-localtime-temporal[X]
| xref::functions/temporal/index.adoc#functions-datetime-temporal[X]
| xref::functions/temporal/index.adoc#functions-localdatetime-temporal[X]

| Creating a value from a `STRING`.
| xref::functions/temporal/index.adoc#functions-date-create-string[X]
| xref::functions/temporal/index.adoc#functions-time-create-string[X]
| xref::functions/temporal/index.adoc#functions-localtime-create-string[X]
| xref::functions/temporal/index.adoc#functions-datetime-create-string[X]
| xref::functions/temporal/index.adoc#functions-localdatetime-create-string[X]

| Creating a value from a timestamp.
|
|
|
| xref::functions/temporal/index.adoc#functions-datetime-timestamp[X]
|

|===


[NOTE]
====
All the temporal instant types -- including those that do not contain time zone information support such as `DATE`, `LOCAL TIME` and `ZONED DATETIME` -- allow for a time zone to specified for the functions that retrieve the current instant.
This allows for the retrieval of the current instant in the specified time zone.
====


[[functions-temporal-clock-overview]]
=== Controlling which clock to use

The functions which create temporal instant values based on the current instant use the `statement` clock as default.
However, there are three different clocks available for more fine-grained control:

* `transaction`: The same instant is produced for each invocation within the same transaction.
A different time may be produced for different transactions.
* `statement`: The same instant is produced for each invocation within the same statement.
A different time may be produced for different statements within the same transaction.
* `realtime`: The instant produced will be the live clock of the system.

The following table lists the different sub-functions for specifying the clock to be used when creating the current temporal instant value:

[options="header"]
|===
| Type | default | transaction | statement | realtime

| Date
| xref::functions/temporal/index.adoc#functions-date-current[date()]
| xref::functions/temporal/index.adoc#functions-date-transaction[date.transaction()]
| xref::functions/temporal/index.adoc#functions-date-statement[date.statement()]
| xref::functions/temporal/index.adoc#functions-date-realtime[date.realtime()]

| Time
| xref::functions/temporal/index.adoc#functions-time-current[time()]
| xref::functions/temporal/index.adoc#functions-time-transaction[time.transaction()]
| xref::functions/temporal/index.adoc#functions-time-statement[time.statement()]
| xref::functions/temporal/index.adoc#functions-time-realtime[time.realtime()]

| LocalTime
| xref::functions/temporal/index.adoc#functions-localtime-current[localtime()]
| xref::functions/temporal/index.adoc#functions-localtime-transaction[localtime.transaction()]
| xref::functions/temporal/index.adoc#functions-localtime-statement[localtime.statement()]
| xref::functions/temporal/index.adoc#functions-localtime-realtime[localtime.realtime()]

| DateTime
| xref::functions/temporal/index.adoc#functions-datetime-current[datetime()]
| xref::functions/temporal/index.adoc#functions-datetime-transaction[datetime.transaction()]
| xref::functions/temporal/index.adoc#functions-datetime-statement[datetime.statement()]
| xref::functions/temporal/index.adoc#functions-datetime-realtime[datetime.realtime()]

| LocalDateTime
| xref::functions/temporal/index.adoc#functions-localdatetime-current[localdatetime()]
| xref::functions/temporal/index.adoc#functions-localdatetime-transaction[localdatetime.transaction()]
| xref::functions/temporal/index.adoc#functions-localdatetime-statement[localdatetime.statement()]
| xref::functions/temporal/index.adoc#functions-localdatetime-realtime[localdatetime.realtime()]

|===


[[functions-temporal-truncate-overview]]
[discrete]
=== Truncating temporal values

A temporal instant value can be created by truncating another temporal instant value at the nearest preceding point in time at a specified component boundary (namely, a _truncation unit_).
A temporal instant value created in this way will have all components which are less significant than the specified truncation unit set to their default values.
// what about these?

It is possible to supplement the truncated value by providing a map containing components which are less significant than the truncation unit.
This will have the effect of overriding the default values which would otherwise have been set for these less significant components.

The following truncation units are supported:

* `millennium`: Select the temporal instant corresponding to the _millenium_ of the given instant.
* `century`: Select the temporal instant corresponding to the _century_ of the given instant.
* `decade`: Select the temporal instant corresponding to the _decade_ of the given instant.
* `year`: Select the temporal instant corresponding to the _year_ of the given instant.
* `weekYear`: Select the temporal instant corresponding to the first day of the first week of the _week-year_ of the given instant.
* `quarter`: Select the temporal instant corresponding to the _quarter of the year_ of the given instant.
* `month`: Select the temporal instant corresponding to the _month_ of the given instant.
* `week`: Select the temporal instant corresponding to the _week_ of the given instant.
* `day`: Select the temporal instant corresponding to the _month_ of the given instant.
* `hour`: Select the temporal instant corresponding to the _hour_ of the given instant.
* `minute`: Select the temporal instant corresponding to the _minute_ of the given instant.
* `second`: Select the temporal instant corresponding to the _second_ of the given instant.
* `millisecond`: Select the temporal instant corresponding to the _millisecond_ of the given instant.
* `microsecond`: Select the temporal instant corresponding to the _microsecond_ of the given instant.


The following table lists the supported truncation units and the corresponding sub-functions:

[options="header"]
|===
| Truncation unit | Date | Time | LocalTime | DateTime | LocalDateTime

| `millennium`
| xref:functions-date-truncate[date.truncate('millennium', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('millennium', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('millennium', input)]

| `century`
| xref:functions-date-truncate[date.truncate('century', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('century', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('century', input)]

| `decade`
| xref:functions-date-truncate[date.truncate('decade', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('decade', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('decade', input)]

| `year`
| xref:functions-date-truncate[date.truncate('year', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('year', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('year', input)]

| `weekYear`
| xref:functions-date-truncate[date.truncate('weekYear', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('weekYear', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('weekYear', input)]

| `quarter`
| xref:functions-date-truncate[date.truncate('quarter', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('quarter', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('quarter', input)]

| `month`
| xref:functions-date-truncate[date.truncate('month', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('month', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('month', input)]

| `week`
| xref:functions-date-truncate[date.truncate('week', input)]
|
|
| xref:functions-datetime-truncate[datetime.truncate('week', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('week', input)]

| `day`
| xref:functions-date-truncate[date.truncate('day', input)]
| xref:functions-time-truncate[time.truncate('day', input)]
| xref:functions-localtime-truncate[localtime.truncate('day', input)]
| xref:functions-datetime-truncate[datetime.truncate('day', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('day', input)]

| `hour`
|
| xref:functions-time-truncate[time.truncate('hour', input)]
| xref:functions-localtime-truncate[localtime.truncate('hour', input)]
| xref:functions-datetime-truncate[datetime.truncate('hour', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('hour',input)]

| `minute`
|
| xref:functions-time-truncate[time.truncate('minute', input)]
| xref:functions-localtime-truncate[localtime.truncate('minute', input)]
| xref:functions-datetime-truncate[datetime.truncate('minute', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('minute', input)]

| `second`
|
| xref:functions-time-truncate[time.truncate('second', input)]
| xref:functions-localtime-truncate[localtime.truncate('second', input)]
| xref:functions-datetime-truncate[datetime.truncate('second', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('second', input)]

| `millisecond`
|
| xref:functions-time-truncate[time.truncate('millisecond', input)]
| xref:functions-localtime-truncate[localtime.truncate('millisecond', input)]
| xref:functions-datetime-truncate[datetime.truncate('millisecond', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('millisecond', input)]

| `microsecond`
|
| xref:functions-time-truncate[time.truncate('microsecond', input)]
| xref:functions-localtime-truncate[localtime.truncate('microsecond', input)]
| xref:functions-datetime-truncate[datetime.truncate('microsecond', input)]
| xref:functions-localdatetime-truncate[localdatetime.truncate('microsecond', input)]

|===


[[functions-date]]
== +date()+

Details for using the `date()` function.

* xref::functions/temporal/index.adoc#functions-date-current[Getting the current `DATE`]
** xref::/functions/temporal/index.adoc#functions-date-transaction[+date.transaction()+]
** xref::/functions/temporal/index.adoc#functions-date-statement[+date.statement()+]
** xref::/functions/temporal/index.adoc#functions-date-realtime[+date.realtime()+]

* xref::functions/temporal/index.adoc#functions-date-calendar[Creating a calendar (Year-Month-Day) `DATE`]
* xref::functions/temporal/index.adoc#functions-date-week[Creating a week (Year-Week-Day) `DATE`]
* xref::functions/temporal/index.adoc#functions-date-quarter[Creating a quarter (Year-Quarter-Day) `DATE`]
* xref::functions/temporal/index.adoc#functions-date-ordinal[Creating an ordinal (Year-Day) `DATE`]
* xref::functions/temporal/index.adoc#functions-date-create-string[Creating a `DATE` from a `STRING`]
* xref::functions/temporal/index.adoc#functions-date-temporal[Creating a `DATE` using other temporal values as components]
* xref::functions/temporal/index.adoc#functions-date-truncate[Truncating a `DATE`]


[discrete]
[[functions-date-current]]
=== Getting the current `DATE`

`date()` returns the current `DATE` value.
If no time zone parameter is specified, the local time zone will be used.

*Syntax:*

[source, syntax, role="noheader"]
----
date([{timezone}])
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===

*Considerations:*

|===

| If no parameters are provided, `date()` must be invoked (`+date({})+` is invalid).

|===


.+date()+
======

.Query
[source, cypher]
----
RETURN date() AS currentDate
----

The current date is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDate+
| +2022-06-14+
1+d|Rows: 1

|===

======


.+date()+
======

.Query
[source, cypher, role=test-result-skip]
----
RETURN date({timezone: 'America/Los Angeles'}) AS currentDateInLA
----

The current date in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDateInLA+
| +2022-06-14+
1+d|Rows: 1

|===

======


[discrete]
[[functions-date-transaction]]
==== +date.transaction()+

`date.transaction()` returns the current `DATE` value using the `transaction` clock.
This value will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

*Syntax:*

[source, syntax, role="noheader"]
----
date.transaction([{timezone}])
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*
[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+date.transaction()+
======

.Query
[source, cypher]
----
RETURN date.transaction() AS currentDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDate+
| +2022-06-14+
1+d|Rows: 1

|===

======


[discrete]
[[functions-date-statement]]
==== +date.statement()+

`date.statement()` returns the current `DATE` value using the `statement` clock.
This value will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.

*Syntax:*

[source, syntax, role="noheader"]
----
date.statement([{timezone}])
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+date.statement()+
======

.Query
[source, cypher]
----
RETURN date.statement() AS currentDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDate+
| +2022-06-14+
1+d|Rows: 1

|===

======


[discrete]
[[functions-date-realtime]]
==== date.realtime()

`date.realtime()` returns the current `DATE` value using the `realtime` clock.
This value will be the live clock of the system.

*Syntax:*

[source, syntax, role="noheader"]
----
date.realtime([{timezone}])
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+date.realtime()+
======

.Query
[source, cypher]
----
RETURN date.realtime() AS currentDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDate+
| +2022-06-14+
1+d|Rows: 1

|===

======


.+date.realtime()+
======

.Query
[source, cypher]
----
RETURN date.realtime('America/Los Angeles') AS currentDateInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDateInLA+
| +2022-06-14+
1+d|Rows: 1

|===

======


[discrete]
[[functions-date-calendar]]
=== Creating a calendar (Year-Month-Day) `DATE`

`date()` returns a `DATE` value with the specified _year_, _month_ and _day_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
date({year [, month, day]})
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

|===

*Considerations:*

|===

| The _day of the month_ component will default to `1` if `day` is omitted.
| The _month_ component will default to `1` if `month` is omitted.
| If `month` is omitted, `day` must also be omitted.

|===


.+date()+
======

.Query
[source, cypher]
----
UNWIND [
date({year: 1984, month: 10, day: 11}),
date({year: 1984, month: 10}),
date({year: 1984})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-10-11+
| +1984-10-01+
| +1984-01-01+
1+d|Rows: 3

|===

======


[[functions-date-week]]
[discrete]
=== Creating a week (Year-Week-Day) `DATE`

`date()` returns a `DATE` value with the specified _year_, _week_ and _dayOfWeek_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
date({year [, week, dayOfWeek]})
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `week`
| An integer between `1` and `53` that specifies the week.

| `dayOfWeek`
| An integer between `1` and `7` that specifies the day of the week.

|===

*Considerations:*

|===

| The _day of the week_ component will default to `1` if `dayOfWeek` is omitted.
| The _week_ component will default to `1` if `week` is omitted.
| If `week` is omitted, `dayOfWeek` must also be omitted.

|===


.+date()+
======

.Query
[source, cypher]
----
UNWIND [
date({year: 1984, week: 10, dayOfWeek: 3}),
date({year: 1984, week: 10}),
date({year: 1984})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-03-07+
| +1984-03-05+
| +1984-01-01+
1+d|Rows: 3

|===

======


[discrete]
[[functions-date-quarter]]
=== Creating a quarter (Year-Quarter-Day) `DATE`

`date()` returns a `DATE` value with the specified _year_, _quarter_ and _dayOfQuarter_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
date({year [, quarter, dayOfQuarter]})
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `quarter`
| An integer between `1` and `4` that specifies the quarter.

| `dayOfQuarter`
| An integer between `1` and `92` that specifies the day of the quarter.

|===

*Considerations:*

|===

| The _day of the quarter_ component will default to `1` if `dayOfQuarter` is omitted.
| The _quarter_ component will default to `1` if `quarter` is omitted.
| If `quarter` is omitted, `dayOfQuarter` must also be omitted.

|===


.+date()+
======

.Query
[source, cypher]
----
UNWIND [
date({year: 1984, quarter: 3, dayOfQuarter: 45}),
date({year: 1984, quarter: 3}),
date({year: 1984})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-08-14+
| +1984-07-01+
| +1984-01-01+
1+d|Rows: 3

|===

======


[discrete]
[[functions-date-ordinal]]
=== Creating an ordinal (Year-Day) `DATE`

`date()` returns a `DATE` value with the specified _year_ and _ordinalDay_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
date({year [, ordinalDay]})
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `ordinalDay`
| An integer between `1` and `366` that specifies the ordinal day of the year.

|===

*Considerations:*

|===

| The _ordinal day of the year_ component will default to `1` if `ordinalDay` is omitted.

|===


.+date()+
======

.Query
[source, cypher]
----
UNWIND [
date({year: 1984, ordinalDay: 202}),
date({year: 1984})
] AS theDate
RETURN theDate
----

The date corresponding to `11 February 1984` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-07-20+
| +1984-01-01+
1+d|Rows: 2

|===

======


[discrete]
[[functions-date-create-string]]
=== Creating a `DATE` from a `STRING`

`date()` returns the `DATE` value obtained by parsing a `STRING` representation of a temporal value.

*Syntax:*

[source, syntax, role="noheader"]
----
date(temporalValue)
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `temporalValue`
| A `STRING` representing a temporal value.

|===

*Considerations:*

|===

| `temporalValue` must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-date[dates].
| `temporalValue` must denote a valid date; i.e. a `temporalValue` denoting `30 February 2001` is invalid.
| `date(null)` returns `null`.

|===


.+date()+
======

.Query
[source, cypher]
----
UNWIND [
date('2015-07-21'),
date('2015-07'),
date('201507'),
date('2015-W30-2'),
date('2015202'),
date('2015')
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +2015-07-21+
| +2015-07-01+
| +2015-07-01+
| +2015-07-21+
| +2015-07-21+
| +2015-01-01+
1+d|Rows: 6

|===

======


[discrete]
[[functions-date-temporal]]
=== Creating a `DATE` using other temporal values as components

`date()` returns the `DATE` value obtained by selecting and composing components from another temporal value.
In essence, this allows a `ZONED DATETIME` or `LOCAL DATETIME` value to be converted to a `DATE`, and for "missing" components to be provided.

*Syntax:*

[source, syntax, role="noheader"]
----
date({date [, year, month, day, week, dayOfWeek, quarter, dayOfQuarter, ordinalDay]})
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `date`
| A `DATE` value.

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

| `week`
| An integer between `1` and `53` that specifies the week.

| `dayOfWeek`
| An integer between `1` and `7` that specifies the day of the week.

| `quarter`
| An integer between `1` and `4` that specifies the quarter.

| `dayOfQuarter`
| An integer between `1` and `92` that specifies the day of the quarter.

| `ordinalDay`
| An integer between `1` and `366` that specifies the ordinal day of the year.

|===

*Considerations:*

|===

| If any of the optional parameters are provided, these will override the corresponding components of `date`.
| `date(dd)` may be written instead of `+date({date: dd})+`.

|===

.+date()+
======

.Query
[source, cypher]
----
UNWIND [
date({year: 1984, month: 11, day: 11}),
localdatetime({year: 1984, month: 11, day: 11, hour: 12, minute: 31, second: 14}),
datetime({year: 1984, month: 11, day: 11, hour: 12, timezone: '+01:00'})
] AS dd
RETURN date({date: dd}) AS dateOnly, date({date: dd, day: 28}) AS dateDay
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| +dateOnly+ | +dateDay+
| +1984-11-11+ | +1984-11-28+
| +1984-11-11+ | +1984-11-28+
| +1984-11-11+ | +1984-11-28+
2+d|Rows: 3

|===

======


[[functions-date-truncate]]
[discrete]
=== Truncating a `DATE`

`date.truncate()` returns the `DATE` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `DATE` returned will have all components that are less significant than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are less significant than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these less significant components.
For example, `day` -- with some value `x` -- may be provided when the truncation unit `STRING` is `'year'` in order to ensure the returned value has the _day_ set to `x` instead of the default _day_ (which is `1`).

*Syntax:*

[source, syntax, role="noheader"]
----
date.truncate(unit [, temporalInstantValue [, mapOfComponents ] ])
----

*Returns:*

|===

| `DATE`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `unit`
| A string expression evaluating to one of the following `STRING` values: `'millennium'`, `'century'`, `'decade'`, `'year'`, `'weekYear'`, `'quarter'`, `'month'`, `'week'`, `'day'`.

| `temporalInstantValue`
| An expression of one of the following types: `ZONED DATETIME`, `LOCAL DATETIME`, `DATE`.

| `mapOfComponents`
| An expression evaluating to a map containing components less significant than `unit`.

|===

*Considerations:*

|===

| Any component that is provided in `mapOfComponents` must be less significant than `unit`; i.e. if `unit` `STRING` is `'day'`, `mapOfComponents` cannot contain information pertaining to a _month_.
| Any component that is not contained in `mapOfComponents` and which is less significant than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `mapOfComponents` is not provided, all components of the returned value which are less significant than `unit` will be set to their default values.
| If `temporalInstantValue` is not provided, it will be set to the current date, i.e. `date.truncate(unit)` is equivalent of `date.truncate(unit, date())`.

|===


.+date.truncate()+
======

.Query
[source, cypher]
----
WITH
  datetime({
    year: 2017, month: 11, day: 11,
    hour: 12, minute: 31, second: 14, nanosecond: 645876123,
    timezone: '+01:00'
  }) AS d
RETURN
  date.truncate('millennium', d) AS truncMillenium,
  date.truncate('century', d) AS truncCentury,
  date.truncate('decade', d) AS truncDecade,
  date.truncate('year', d, {day: 5}) AS truncYear,
  date.truncate('weekYear', d) AS truncWeekYear,
  date.truncate('quarter', d) AS truncQuarter,
  date.truncate('month', d) AS truncMonth,
  date.truncate('week', d, {dayOfWeek: 2}) AS truncWeek,
  date.truncate('day', d) AS truncDay
----

.Result
[role="queryresult",options="header,footer",cols="9*<m"]
|===

| +truncMillenium+ | +truncCentury+ | +truncDecade+ | +truncYear+ | +truncWeekYear+ | +truncQuarter+ | +truncMonth+ | +truncWeek+ | +truncDay+
| +2000-01-01+ | +2000-01-01+ | +2010-01-01+ | +2017-01-05+ | +2017-01-02+ | +2017-10-01+ | +2017-11-01+ | +2017-11-07+ | +2017-11-11+
9+d|Rows: 1

|===

======


[[functions-datetime]]
== +datetime()+

Details for using the `datetime()` function.

* xref::functions/temporal/index.adoc#functions-datetime-current[Getting the current `ZONED DATETIME`]
** xref::functions/temporal/index.adoc#functions-datetime-transaction[+datetime.transaction()+]
** xref::functions/temporal/index.adoc#functions-datetime-statement[+datetime.statement()+]
** xref::functions/temporal/index.adoc#functions-datetime-realtime[+datetime.realtime()+]

* xref::functions/temporal/index.adoc#functions-datetime-calendar[Creating a calendar (Year-Month-Day) `ZONED DATETIME`]
* xref::functions/temporal/index.adoc#functions-datetime-week[Creating a week (Year-Week-Day) `ZONED DATETIME`]
* xref::functions/temporal/index.adoc#functions-datetime-quarter[Creating a quarter (Year-Quarter-Day) `ZONED DATETIME`]
* xref::functions/temporal/index.adoc#functions-datetime-ordinal[Creating an ordinal (Year-Day) `ZONED DATETIME`]
* xref::functions/temporal/index.adoc#functions-datetime-create-string[Creating a `ZONED DATETIME` from a `STRING`]
* xref::functions/temporal/index.adoc#functions-datetime-temporal[Creating a `ZONED DATETIME` using other temporal values as components]
* xref::functions/temporal/index.adoc#functions-datetime-timestamp[Creating a `ZONED DATETIME` from a timestamp]
* xref::functions/temporal/index.adoc#functions-datetime-truncate[Truncating a `ZONED DATETIME`]


[discrete]
[[functions-datetime-current]]
=== Getting the current `ZONED DATETIME`

`datetime()` returns the current `ZONED DATETIME` value.
If no time zone parameter is specified, the default time zone will be used.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime([{timezone}])
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===

*Considerations:*

|===

| If no parameters are provided, `datetime()` must be invoked (`datetime({})` is invalid).

|===


.+.datetime()+
======

.Query
[source, cypher]
----
RETURN datetime() AS currentDateTime
----

The current date and time using the local time zone is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDateTime+
| +2022-06-14T10:02:28.192Z+
1+d|Rows: 1

|===

======


.+.datetime()+
======

.Query
[source, cypher]
----
RETURN datetime({timezone: 'America/Los Angeles'}) AS currentDateTimeInLA
----

The current date and time of day in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDateTimeInLA+
| +2022-06-14T03:02:28.238-07:00[America/Los_Angeles]+
1+d|Rows: 1

|===

======


[discrete]
[[functions-datetime-transaction]]
==== datetime.transaction()

`datetime.transaction()` returns the current `ZONED DATETIME` value using the `transaction` clock.
This value will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime.transaction([{timezone}])
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+datetime.transaction()+
======

.Query
[source, cypher]
----
RETURN datetime.transaction() AS currentDateTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDateTime+
| +2022-06-14T10:02:28.290Z+
1+d|Rows: 1

|===

======


.+datetime.transaction()+
======

.Query
[source, cypher]
----
RETURN datetime.transaction('America/Los Angeles') AS currentDateTimeInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDateTimeInLA+
| +2022-06-14T03:02:28.338-07:00[America/Los_Angeles]+
1+d|Rows: 1

|===

======


[discrete]
[[functions-datetime-statement]]
==== datetime.statement()

`datetime.statement()` returns the current `ZONED DATETIME` value using the `statement` clock.
This value will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime.statement([{timezone}])
----

*Returns:*
|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+datetime.statement()+
======

.Query
[source, cypher]
----
RETURN datetime.statement() AS currentDateTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDateTime+
| +2022-06-14T10:02:28.395Z+
1+d|Rows: 1

|===

======


[discrete]
[[functions-datetime-realtime]]
==== datetime.realtime()

`datetime.realtime()` returns the current `ZONED DATETIME` value using the `realtime` clock.
This value will be the live clock of the system.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime.realtime([{timezone}])
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+datetime.realtime()+
======

.Query
[source, cypher]
----
RETURN datetime.realtime() AS currentDateTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentDateTime+
| +2022-06-14T10:02:28.494444Z+
1+d|Rows: 1

|===

======


[discrete]
[[functions-datetime-calendar]]
=== Creating a calendar (Year-Month-Day) `ZONED DATETIME`

`datetime()` returns a `ZONED DATETIME` value with the specified _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ and _timezone_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime({year [, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timezone]})
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the time zone.

|===

*Considerations:*

|===

| The _month_ component will default to `1` if `month` is omitted.
| The _day of the month_ component will default to `1` if `day` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| The _timezone_ component will default to the configured default time zone if `timezone` is omitted.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `year`, `month`, `day`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year`, `month` and `day`, but specifying `year`, `month`, `day` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+datetime()+
======

.Query
[source, cypher]
----
UNWIND [
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 123, microsecond: 456, nanosecond: 789}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, millisecond: 645, timezone: '+01:00'}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14, timezone: '+01:00'}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, second: 14}),
datetime({year: 1984, month: 10, day: 11, hour: 12, minute: 31, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, month: 10, day: 11, hour: 12, timezone: '+01:00'}),
datetime({year: 1984, month: 10, day: 11, timezone: 'Europe/Stockholm'})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-10-11T12:31:14.123456789Z+
| +1984-10-11T12:31:14.645+01:00+
| +1984-10-11T12:31:14.645876123+01:00[Europe/Stockholm]+
| +1984-10-11T12:31:14+01:00+
| +1984-10-11T12:31:14Z+
| +1984-10-11T12:31+01:00[Europe/Stockholm]+
| +1984-10-11T12:00+01:00+
| +1984-10-11T00:00+01:00[Europe/Stockholm]+
1+d|Rows: 8

|===

======


[discrete]
[[functions-datetime-week]]
=== Creating a week (Year-Week-Day) `ZONED DATETIME`

`datetime()` returns a `ZONED DATETIME` value with the specified _year_, _week_, _dayOfWeek_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ and _timezone_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime({year [, week, dayOfWeek, hour, minute, second, millisecond, microsecond, nanosecond, timezone]})
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `week`
| An integer between `1` and `53` that specifies the week.

| `dayOfWeek`
| An integer between `1` and `7` that specifies the day of the week.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the time zone.

|===

*Considerations:*

|===

| The _week_ component will default to `1` if `week` is omitted.
| The _day of the week_ component will default to `1` if `dayOfWeek` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| The _timezone_ component will default to the configured default time zone if `timezone` is omitted.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `year`, `week`, `dayOfWeek`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year`, `week` and `dayOfWeek`, but specifying `year`, `week`, `dayOfWeek` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+datetime()+
======

.Query
[source, cypher]
----
UNWIND [
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, millisecond: 645}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, minute: 31, second: 14}),
datetime({year: 1984, week: 10, dayOfWeek: 3, hour: 12, timezone: '+01:00'}),
datetime({year: 1984, week: 10, dayOfWeek: 3, timezone: 'Europe/Stockholm'})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-03-07T12:31:14.645Z+
| +1984-03-07T12:31:14.645876+01:00+
| +1984-03-07T12:31:14.645876123+01:00[Europe/Stockholm]+
| +1984-03-07T12:31:14+01:00[Europe/Stockholm]+
| +1984-03-07T12:31:14Z+
| +1984-03-07T12:00+01:00+
| +1984-03-07T00:00+01:00[Europe/Stockholm]+
1+d|Rows: 7

|===

======


[discrete]
[[functions-datetime-quarter]]
=== Creating a quarter (Year-Quarter-Day) `ZONED DATETIME`

`datetime()` returns a `ZONED DATETIME` value with the specified _year_, _quarter_, _dayOfQuarter_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ and _timezone_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime({year [, quarter, dayOfQuarter, hour, minute, second, millisecond, microsecond, nanosecond, timezone]})
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `quarter`
| An integer between `1` and `4` that specifies the quarter.

| `dayOfQuarter`
| An integer between `1` and `92` that specifies the day of the quarter.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the time zone.

|===

*Considerations:*

|===

| The _quarter_ component will default to `1` if `quarter` is omitted.
| The _day of the quarter_ component will default to `1` if `dayOfQuarter` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| The _timezone_ component will default to the configured default time zone if `timezone` is omitted.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `year`, `quarter`, `dayOfQuarter`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year`, `quarter` and `dayOfQuarter`, but specifying `year`, `quarter`, `dayOfQuarter` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+datetime()+
======

.Query
[source, cypher]
----
UNWIND [
datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, microsecond: 645876}),
datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, minute: 31, second: 14, timezone: '+01:00'}),
datetime({year: 1984, quarter: 3, dayOfQuarter: 45, hour: 12, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, quarter: 3, dayOfQuarter: 45})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-08-14T12:31:14.645876Z+
| +1984-08-14T12:31:14+01:00+
| +1984-08-14T12:00+02:00[Europe/Stockholm]+
| +1984-08-14T00:00Z+
1+d|Rows: 4

|===

======


[discrete]
[[functions-datetime-ordinal]]
=== Creating an ordinal (Year-Day) `ZONED DATETIME`

`datetime()` returns a `ZONED DATETIME` value with the specified _year_, _ordinalDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ and _timezone_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime({year [, ordinalDay, hour, minute, second, millisecond, microsecond, nanosecond, timezone]})
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `ordinalDay`
| An integer between `1` and `366` that specifies the ordinal day of the year.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the time zone.

|===

*Considerations:*

|===

| The _ordinal day of the year_ component will default to `1` if `ordinalDay` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| The _timezone_ component will default to the configured default time zone if `timezone` is omitted.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `year`, `ordinalDay`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year` and `ordinalDay`, but specifying `year`, `ordinalDay` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+datetime()+
======

.Query
[source, cypher]
----
UNWIND [
datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, millisecond: 645}),
datetime({year: 1984, ordinalDay: 202, hour: 12, minute: 31, second: 14, timezone: '+01:00'}),
datetime({year: 1984, ordinalDay: 202, timezone: 'Europe/Stockholm'}),
datetime({year: 1984, ordinalDay: 202})
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-07-20T12:31:14.645Z+
| +1984-07-20T12:31:14+01:00+
| +1984-07-20T00:00+02:00[Europe/Stockholm]+
| +1984-07-20T00:00Z+
1+d|Rows: 4

|===

======


[discrete]
[[functions-datetime-create-string]]
=== Creating a `ZONED DATETIME` from a `STRING`

`datetime()` returns the `ZONED DATETIME` value obtained by parsing a `STRING` representation of a temporal value.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime(temporalValue)
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `temporalValue`
| A `STRING` representing a temporal value.

|===

*Considerations:*

|===

| `temporalValue` must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-date[dates], xref::values-and-types/temporal.adoc#cypher-temporal-specify-time[times] and xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zones].
| The _timezone_ component will default to the configured default time zone if it is omitted.
| `temporalValue` must denote a valid date and time; i.e. a `temporalValue` denoting `30 February 2001` is invalid.
| `datetime(null)` returns null.

|===


.+datetime()+
======

.Query
[source, cypher]
----
UNWIND [
datetime('2015-07-21T21:40:32.142+0100'),
datetime('2015-W30-2T214032.142Z'),
datetime('2015T214032-0100'),
datetime('20150721T21:40-01:30'),
datetime('2015-W30T2140-02'),
datetime('2015202T21+18:00'),
datetime('2015-07-21T21:40:32.142[Europe/London]'),
datetime('2015-07-21T21:40:32.142-04[America/New_York]')
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +2015-07-21T21:40:32.142+01:00+
| +2015-07-21T21:40:32.142Z+
| +2015-01-01T21:40:32-01:00+
| +2015-07-21T21:40-01:30+
| +2015-07-20T21:40-02:00+
| +2015-07-21T21:00+18:00+
| +2015-07-21T21:40:32.142+01:00[Europe/London]+
| +2015-07-21T21:40:32.142-04:00[America/New_York]+
1+d|Rows: 8

|===

======


[discrete]
[[functions-datetime-temporal]]
=== Creating a `ZONED DATETIME` using other temporal values as components

`datetime()` returns the `ZONED DATETIME` value obtained by selecting and composing components from another temporal value.
In essence, this allows a `DATE`, `LOCAL DATETIME`, `ZONED TIME` or `LOCAL TIME` value to be converted to a `ZONED DATETIME`, and for "missing" components to be provided.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime({datetime [, year, ..., timezone]}) | datetime({date [, year, ..., timezone]}) | datetime({time [, year, ..., timezone]}) | datetime({date, time [, year, ..., timezone]})
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `datetime`
| A `ZONED DATETIME` value.

| `date`
| A `DATE` value.

| `time`
| A `ZONED TIME` value.

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

| `week`
| An integer between `1` and `53` that specifies the week.

| `dayOfWeek`
| An integer between `1` and `7` that specifies the day of the week.

| `quarter`
| An integer between `1` and `4` that specifies the quarter.

| `dayOfQuarter`
| An integer between `1` and `92` that specifies the day of the quarter.

| `ordinalDay`
| An integer between `1` and `366` that specifies the ordinal day of the year.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the time zone.

|===

*Considerations:*

|===

| If any of the optional parameters are provided, these will override the corresponding components of `datetime`, `date` and/or `time`.
| `datetime(dd)` may be written instead of `+datetime({datetime: dd})+`.
| Selecting a `ZONED TIME` or `ZONED DATETIME` value as the `time` component also selects its time zone. If a `LOCAL TIME` or `LOCAL DATETIME` is selected instead, the default time zone is used. In any case, the time zone can be overridden explicitly.
| Selecting a `ZONED DATETIME` as the `datetime` component and overwriting the time zone will adjust the local time to keep the same point in time.
| Selecting a `ZONED DATETIME` or `ZONED TIME` as the `time` component and overwriting the time zone will adjust the local time to keep the same point in time.

|===


.+datetime()+
======

The following query shows the various usages of `+datetime({date [, year, ..., timezone]})+`.

.Query
[source, cypher]
----
WITH date({year: 1984, month: 10, day: 11}) AS dd
RETURN
  datetime({date: dd, hour: 10, minute: 10, second: 10}) AS dateHHMMSS,
  datetime({date: dd, hour: 10, minute: 10, second: 10, timezone:'+05:00'}) AS dateHHMMSSTimezone,
  datetime({date: dd, day: 28, hour: 10, minute: 10, second: 10}) AS dateDDHHMMSS,
  datetime({date: dd, day: 28, hour: 10, minute: 10, second: 10, timezone:'Pacific/Honolulu'}) AS dateDDHHMMSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| +dateHHMMSS+ | +dateHHMMSSTimezone+ | +dateDDHHMMSS+ | +dateDDHHMMSSTimezone+
| +1984-10-11T10:10:10Z+ | +1984-10-11T10:10:10+05:00+ | +1984-10-28T10:10:10Z+ | +1984-10-28T10:10:10-10:00[Pacific/Honolulu]+
4+d|Rows: 1

|===

======


.+datetime()+
======

The following query shows the various usages of `datetime({time [, year, ..., timezone]})`.

.Query
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS tt
RETURN
  datetime({year: 1984, month: 10, day: 11, time: tt}) AS YYYYMMDDTime,
  datetime({year: 1984, month: 10, day: 11, time: tt, timezone:'+05:00'}) AS YYYYMMDDTimeTimezone,
  datetime({year: 1984, month: 10, day: 11, time: tt, second: 42}) AS YYYYMMDDTimeSS,
  datetime({year: 1984, month: 10, day: 11, time: tt, second: 42, timezone: 'Pacific/Honolulu'}) AS YYYYMMDDTimeSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| +YYYYMMDDTime+ | +YYYYMMDDTimeTimezone+ | +YYYYMMDDTimeSS+ | +YYYYMMDDTimeSSTimezone+
| +1984-10-11T12:31:14.645876+01:00+ | +1984-10-11T16:31:14.645876+05:00+ | +1984-10-11T12:31:42.645876+01:00+ | +1984-10-11T01:31:42.645876-10:00[Pacific/Honolulu]+
4+d|Rows: 1

|===

======


.+datetime()+
======

The following query shows the various usages of `+datetime({date, time [, year, ..., timezone]})+`; i.e. combining a `DATE` and a `ZONED TIME` value to create a single `ZONED DATETIME` value.

.Query
[source, cypher]
----
WITH
  date({year: 1984, month: 10, day: 11}) AS dd,
  localtime({hour: 12, minute: 31, second: 14, millisecond: 645}) AS tt
RETURN
  datetime({date: dd, time: tt}) AS dateTime,
  datetime({date: dd, time: tt, timezone: '+05:00'}) AS dateTimeTimezone,
  datetime({date: dd, time: tt, day: 28, second: 42}) AS dateTimeDDSS,
  datetime({date: dd, time: tt, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS dateTimeDDSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| +dateTime+ | +dateTimeTimezone+ | +dateTimeDDSS+ | +dateTimeDDSSTimezone+
| +1984-10-11T12:31:14.645Z+ | +1984-10-11T12:31:14.645+05:00+ | +1984-10-28T12:31:42.645Z+ | +1984-10-28T12:31:42.645-10:00[Pacific/Honolulu]+
4+d|Rows: 1

|===

======


.+datetime()+
======

The following query shows the various usages of `+datetime({datetime [, year, ..., timezone]})+`.

.Query
[source, cypher]
----
WITH
  datetime({
    year: 1984, month: 10, day: 11,
    hour: 12,
    timezone: 'Europe/Stockholm'
  }) AS dd
RETURN
  datetime({datetime: dd}) AS dateTime,
  datetime({datetime: dd, timezone: '+05:00'}) AS dateTimeTimezone,
  datetime({datetime: dd, day: 28, second: 42}) AS dateTimeDDSS,
  datetime({datetime: dd, day: 28, second: 42, timezone: 'Pacific/Honolulu'}) AS dateTimeDDSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| +dateTime+ | +dateTimeTimezone+ | +dateTimeDDSS+ | +dateTimeDDSSTimezone+
| +1984-10-11T12:00+01:00[Europe/Stockholm]+ | +1984-10-11T16:00+05:00+ | +1984-10-28T12:00:42+01:00[Europe/Stockholm]+ | +1984-10-28T01:00:42-10:00[Pacific/Honolulu]+
4+d|Rows: 1

|===

======


[discrete]
[[functions-datetime-timestamp]]
=== Creating a `ZONED DATETIME` from a timestamp

`datetime()` returns the `ZONED DATETIME` value at the specified number of _seconds_ or _milliseconds_ from the UNIX epoch in the UTC time zone.

Conversions to other temporal instant types from UNIX epoch representations can be achieved by transforming a `ZONED DATETIME` value to one of these types.

*Syntax:*

[source, syntax, role="noheader"]
----
datetime({ epochSeconds | epochMillis })
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `epochSeconds`
| A numeric value representing the number of seconds from the UNIX epoch in the UTC time zone.

| `epochMillis`
| A numeric value representing the number of milliseconds from the UNIX epoch in the UTC time zone.

|===

*Considerations:*

|===

| `epochSeconds`/`epochMillis` may be used in conjunction with `nanosecond`.

|===


.+datetime()+
======

.Query
[source, cypher]
----
RETURN datetime({epochSeconds: timestamp() / 1000, nanosecond: 23}) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +2022-06-14T10:02:30.000000023Z+
1+d|Rows: 1

|===

======


.+datetime()+
======

.Query
[source, cypher]
----
RETURN datetime({epochMillis: 424797300000}) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1983-06-18T15:15Z+
1+d|Rows: 1

|===

======


[discrete]
[[functions-datetime-truncate]]
=== Truncating a `ZONED DATETIME`

`datetime.truncate()` returns the `ZONED DATETIME` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `ZONED DATETIME` returned will have all components that are less significant than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are less significant than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these less significant components.
For example, `day` -- with some value `x` -- may be provided when the truncation unit `STRING` is `'year'` in order to ensure the returned value has the _day_ set to `x` instead of the default _day_ (which is `1`).

*Syntax:*

[source, syntax, role="noheader"]
----
datetime.truncate(unit [, temporalInstantValue [, mapOfComponents ] ])
----

*Returns:*

|===

| `ZONED DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `unit`
| A string expression evaluating to one of the following strings: `'millennium'`, `'century'`, `'decade'`, `'year'`, `'weekYear'`, `'quarter'`, `'month'`, `'week'`, `'day'`, `'hour'`, `'minute'`, `'second'`, `'millisecond'`, `'microsecond'`.

| `temporalInstantValue`
| An expression of one of the following types: `ZONED DATETIME`, `LOCAL DATETIME`, `DATE`.

| `mapOfComponents`
a|
An expression evaluating to a map containing components less significant than `unit`.
During truncation, a time zone can be attached or overridden using the key `timezone`.

|===

*Considerations:*

|===

| `temporalInstantValue` cannot be a `DATE` value if `unit` is one of: `'hour'`, `'minute'`, `'second'`, `'millisecond'`, `'microsecond'`.
| The time zone of `temporalInstantValue` may be overridden; for example, `+datetime.truncate('minute', input, {timezone: '+0200'})+`.
| If `temporalInstantValue` is one of `ZONED TIME`, `ZONED DATETIME` -- a value with a time zone -- and the time zone is overridden, no time conversion occurs.
| If `temporalInstantValue` is one of `LOCAL DATETIME`, `DATE` -- a value without a time zone -- and the time zone is not overridden, the configured default time zone will be used.
| Any component that is provided in `mapOfComponents` must be less significant than `unit`; i.e. if `unit` is `'day'`, `mapOfComponents` cannot contain information pertaining to a _month_.
| Any component that is not contained in `mapOfComponents` and which is less significant than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `mapOfComponents` is not provided, all components of the returned value which are less significant than `unit` will be set to their default values.
| If `temporalInstantValue` is not provided, it will be set to the current date, time and timezone, i.e. `datetime.truncate(unit)` is equivalent of `datetime.truncate(unit, datetime())`.

|===


.+datetime()+
======

.Query
[source, cypher]
----
WITH
  datetime({
    year:2017, month:11, day:11,
    hour:12, minute:31, second:14, nanosecond: 645876123,
    timezone: '+03:00'
  }) AS d
RETURN
  datetime.truncate('millennium', d, {timezone: 'Europe/Stockholm'}) AS truncMillenium,
  datetime.truncate('year', d, {day: 5}) AS truncYear,
  datetime.truncate('month', d) AS truncMonth,
  datetime.truncate('day', d, {millisecond: 2}) AS truncDay,
  datetime.truncate('hour', d) AS truncHour,
  datetime.truncate('second', d) AS truncSecond
----

.Result
[role="queryresult",options="header,footer",cols="6*<m"]
|===

| +truncMillenium+ | +truncYear+ | +truncMonth+ | +truncDay+ | +truncHour+ | +truncSecond+
| +2000-01-01T00:00+01:00[Europe/Stockholm]+ | +2017-01-05T00:00+03:00+ | +2017-11-01T00:00+03:00+ | +2017-11-11T00:00:00.002+03:00+ | +2017-11-11T12:00+03:00+ | +2017-11-11T12:31:14+03:00+
6+d|Rows: 1

|===

======


[[functions-localdatetime]]
== +localdatetime()+

Details for using the `localdatetime()` function.

* xref::functions/temporal/index.adoc#functions-localdatetime-current[Getting the current `LOCAL DATETIME`]
** xref::functions/temporal/index.adoc#functions-localdatetime-transaction[+localdatetime.transaction()+]
** xref::functions/temporal/index.adoc#functions-localdatetime-statement[+localdatetime.statement()+]
** xref::functions/temporal/index.adoc#functions-localdatetime-realtime[+localdatetime.realtime()+]

* xref::functions/temporal/index.adoc#functions-localdatetime-calendar[Creating a calendar (Year-Month-Day) `LOCAL DATETIME`]
* xref::functions/temporal/index.adoc#functions-localdatetime-week[Creating a week (Year-Week-Day) `LOCAL DATETIME`]
* xref::functions/temporal/index.adoc#functions-localdatetime-quarter[Creating a quarter (Year-Quarter-Day) `LOCAL DATETIME`]
* xref::functions/temporal/index.adoc#functions-localdatetime-ordinal[Creating an ordinal (Year-Day) `LOCAL DATETIME`]
* xref::functions/temporal/index.adoc#functions-localdatetime-create-string[Creating a `LOCAL DATETIME` from a `STRING`]
* xref::functions/temporal/index.adoc#functions-localdatetime-temporal[Creating a `LOCAL DATETIME` using other temporal values as components]
* xref::functions/temporal/index.adoc#functions-localdatetime-truncate[Truncating a `LOCAL DATETIME`]


[discrete]
[[functions-localdatetime-current]]
=== Getting the current `LOCAL DATETIME`

`localdatetime()` returns the current `LOCAL DATETIME` value.
If no time zone parameter is specified, the local time zone will be used.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime([{timezone}])
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===

*Considerations:*

|===

| If no parameters are provided, `localdatetime()` must be invoked (+localdatetime({})+ is invalid).

|===


.+localdatetime()+
======

.Query
[source, cypher]
----
RETURN localdatetime() AS now
----

The current local date and time (i.e. in the local time zone) is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +2022-06-14T10:02:30.447+
1+d|Rows: 1

|===

======


.+localdatetime()+
======

.Query
[source, cypher]
----
RETURN localdatetime({timezone: 'America/Los Angeles'}) AS now
----

The current local date and time in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +2022-06-14T03:02:30.482+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-transaction]]
==== localdatetime.transaction()

`localdatetime.transaction()` returns the current `LOCAL DATETIME` value using the `transaction` clock.
This value will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime.transaction([{timezone}])
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+localdatetime.transaction()+
======

.Query
[source, cypher]
----
RETURN localdatetime.transaction() AS now
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +2022-06-14T10:02:30.532+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-statement]]
==== localdatetime.statement()

`localdatetime.statement()` returns the current `LOCAL DATETIME` value using the `statement` clock.
This value will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime.statement([{timezone}])
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+localdatetime.statement()+
======

.Query
[source, cypher]
----
RETURN localdatetime.statement() AS now
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +2022-06-14T10:02:30.570+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-realtime]]
==== localdatetime.realtime()

`localdatetime.realtime()` returns the current `LOCAL DATETIME` value using the `realtime` clock.
This value will be the live clock of the system.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime.realtime([{timezone}])
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+localdatetime.realtime()+
======

.Query
[source, cypher]
----
RETURN localdatetime.realtime() AS now
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +2022-06-14T10:02:30.647817+
1+d|Rows: 1

|===

======


.+localdatetime.realtime()+
======

.Query
[source, cypher]
----
RETURN localdatetime.realtime('America/Los Angeles') AS nowInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +nowInLA+
| +2022-06-14T03:02:30.691099+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-calendar]]
=== Creating a calendar (Year-Month-Day) `LOCAL DATETIME`

`localdatetime()` returns a `LOCAL DATETIME` value with the specified _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_ and _nanosecond_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime({year [, month, day, hour, minute, second, millisecond, microsecond, nanosecond]})
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

*Considerations:*

|===

| The _month_ component will default to `1` if `month` is omitted.
| The _day of the month_ component will default to `1` if `day` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `year`, `month`, `day`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year`, `month` and `day`, but specifying `year`, `month`, `day` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+localdatetime.realtime()+
======

.Query
[source, cypher]
----
RETURN
  localdatetime({
    year: 1984, month: 10, day: 11,
    hour: 12, minute: 31, second: 14, millisecond: 123, microsecond: 456, nanosecond: 789
  }) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-10-11T12:31:14.123456789+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-week]]
=== Creating a week (Year-Week-Day) `LOCAL DATETIME`

`localdatetime()` returns a `LOCAL DATETIME` value with the specified _year_, _week_, _dayOfWeek_, _hour_, _minute_, _second_, _millisecond_, _microsecond_ and _nanosecond_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime({year [, week, dayOfWeek, hour, minute, second, millisecond, microsecond, nanosecond]})
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `week`
| An integer between `1` and `53` that specifies the week.

| `dayOfWeek`
| An integer between `1` and `7` that specifies the day of the week.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

*Considerations:*

|===

| The _week_ component will default to `1` if `week` is omitted.
| The _day of the week_ component will default to `1` if `dayOfWeek` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `year`, `week`, `dayOfWeek`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year`, `week` and `dayOfWeek`, but specifying `year`, `week`, `dayOfWeek` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+localdatetime()+
======

.Query
[source, cypher]
----
RETURN
  localdatetime({
    year: 1984, week: 10, dayOfWeek: 3,
    hour: 12, minute: 31, second: 14, millisecond: 645
  }) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-03-07T12:31:14.645+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-quarter]]
=== Creating a quarter (Year-Quarter-Day) `ZONED DATETIME`

`localdatetime()` returns a `LOCAL DATETIME` value with the specified _year_, _quarter_, _dayOfQuarter_, _hour_, _minute_, _second_, _millisecond_, _microsecond_ and _nanosecond_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime({year [, quarter, dayOfQuarter, hour, minute, second, millisecond, microsecond, nanosecond]})
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `quarter`
| An integer between `1` and `4` that specifies the quarter.

| `dayOfQuarter`
| An integer between `1` and `92` that specifies the day of the quarter.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

*Considerations:*

|===

| The _quarter_ component will default to `1` if `quarter` is omitted.
| The _day of the quarter_ component will default to `1` if `dayOfQuarter` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `year`, `quarter`, `dayOfQuarter`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year`, `quarter` and `dayOfQuarter`, but specifying `year`, `quarter`, `dayOfQuarter` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+localdatetime()+
======

.Query
[source, cypher]
----
RETURN
  localdatetime({
    year: 1984, quarter: 3, dayOfQuarter: 45,
    hour: 12, minute: 31, second: 14, nanosecond: 645876123
  }) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-08-14T12:31:14.645876123+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-ordinal]]
=== Creating an ordinal (Year-Day) `LOCAL DATETIME`

`localdatetime()` returns a `LOCAL DATETIME` value with the specified _year_, _ordinalDay_, _hour_, _minute_, _second_, _millisecond_, _microsecond_ and _nanosecond_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime({year [, ordinalDay, hour, minute, second, millisecond, microsecond, nanosecond]})
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `ordinalDay`
| An integer between `1` and `366` that specifies the ordinal day of the year.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

*Considerations:*

|===

| The _ordinal day of the year_ component will default to `1` if `ordinalDay` is omitted.
| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `year`, `ordinalDay`, `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `year` and `ordinalDay`, but specifying `year`, `ordinalDay` and `minute` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+localdatetime()+
======

.Query
[source, cypher]
----
RETURN
  localdatetime({
    year: 1984, ordinalDay: 202,
    hour: 12, minute: 31, second: 14, microsecond: 645876
  }) AS theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +1984-07-20T12:31:14.645876+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-create-string]]
=== Creating a `LOCAL DATETIME` from a `STRING`

`localdatetime()` returns the `LOCAL DATETIME` value obtained by parsing a `STRING` representation of a temporal value.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime(temporalValue)
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `temporalValue`
| A `STRING` representing a temporal value.

|===

*Considerations:*

|===

| `temporalValue` must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-date[dates] and xref::values-and-types/temporal.adoc#cypher-temporal-specify-time[times].
| `temporalValue` must denote a valid date and time; i.e. a `temporalValue` denoting `30 February 2001` is invalid.
| `localdatetime(null)` returns null.

|===


.+localdatetime()+
======

.Query
[source, cypher]
----
UNWIND [
localdatetime('2015-07-21T21:40:32.142'),
localdatetime('2015-W30-2T214032.142'),
localdatetime('2015-202T21:40:32'),
localdatetime('2015202T21')
] AS theDate
RETURN theDate
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theDate+
| +2015-07-21T21:40:32.142+
| +2015-07-21T21:40:32.142+
| +2015-07-21T21:40:32+
| +2015-07-21T21:00+
1+d|Rows: 4

|===

======


[discrete]
[[functions-localdatetime-temporal]]
=== Creating a `LOCAL DATETIME` using other temporal values as components

`localdatetime()` returns the `LOCAL DATETIME` value obtained by selecting and composing components from another temporal value.
In essence, this allows a `DATE`, `ZONED DATETIME`, `ZONED TIME` or `LOCAL TIME` value to be converted to a `LOCAL DATETIME`, and for "missing" components to be provided.

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime({datetime [, year, ..., nanosecond]}) | localdatetime({date [, year, ..., nanosecond]}) | localdatetime({time [, year, ..., nanosecond]}) | localdatetime({date, time [, year, ..., nanosecond]})
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `datetime` | A `ZONED DATETIME` value.

| `date`
| A `DATE` value.

| `time`
| A `ZONED TIME` value.

| `year`
| An expression consisting of at xref::values-and-types/temporal.adoc#cypher-temporal-year[least four digits] that specifies the year.

| `month`
| An integer between `1` and `12` that specifies the month.

| `day`
| An integer between `1` and `31` that specifies the day of the month.

| `week`
| An integer between `1` and `53` that specifies the week.

| `dayOfWeek`
| An integer between `1` and `7` that specifies the day of the week.

| `quarter`
| An integer between `1` and `4` that specifies the quarter.

| `dayOfQuarter`
| An integer between `1` and `92` that specifies the day of the quarter.

| `ordinalDay`
| An integer between `1` and `366` that specifies the ordinal day of the year.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

*Considerations:*

|===

| If any of the optional parameters are provided, these will override the corresponding components of `datetime`, `date` and/or `time`.
| `localdatetime(dd)` may be written instead of `+localdatetime({datetime: dd})+`.

|===


.+localdatetime()+
======

The following query shows the various usages of `+localdatetime({date [, year, ..., nanosecond]})+`.

.Query
[source, cypher]
----
WITH date({year: 1984, month: 10, day: 11}) AS dd
RETURN
  localdatetime({date: dd, hour: 10, minute: 10, second: 10}) AS dateHHMMSS,
  localdatetime({date: dd, day: 28, hour: 10, minute: 10, second: 10}) AS dateDDHHMMSS
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| +dateHHMMSS+ | +dateDDHHMMSS+
| +1984-10-11T10:10:10+ | +1984-10-28T10:10:10+
2+d|Rows: 1

|===

======


.+localdatetime()+
======

The following query shows the various usages of `+localdatetime({time [, year, ..., nanosecond]})+`.

.Query
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS tt
RETURN
  localdatetime({year: 1984, month: 10, day: 11, time: tt}) AS YYYYMMDDTime,
  localdatetime({year: 1984, month: 10, day: 11, time: tt, second: 42}) AS YYYYMMDDTimeSS
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| +YYYYMMDDTime+ | +YYYYMMDDTimeSS+
| +1984-10-11T12:31:14.645876+ | +1984-10-11T12:31:42.645876+
2+d|Rows: 1

|===

======


.+localdatetime()+
======

The following query shows the various usages of `+localdatetime({date, time [, year, ..., nanosecond]})+`; i.e. combining a `DATE` and a `ZONED TIME` value to create a single `LOCAL DATETIME` value.

.Query
[source, cypher]
----
WITH
  date({year: 1984, month: 10, day: 11}) AS dd,
  time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS tt
RETURN
  localdatetime({date: dd, time: tt}) AS dateTime,
  localdatetime({date: dd, time: tt, day: 28, second: 42}) AS dateTimeDDSS
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| +dateTime+ | +dateTimeDDSS+
| +1984-10-11T12:31:14.645876+ | +1984-10-28T12:31:42.645876+
2+d|Rows: 1

|===

======


.+localdatetime()+
======

The following query shows the various usages of `+localdatetime({datetime [, year, ..., nanosecond]})+`.

.Query
[source, cypher]
----
WITH
  datetime({
    year: 1984, month: 10, day: 11,
    hour: 12,
    timezone: '+01:00'
  }) AS dd
RETURN
  localdatetime({datetime: dd}) AS dateTime,
  localdatetime({datetime: dd, day: 28, second: 42}) AS dateTimeDDSS
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| +dateTime+ | +dateTimeDDSS+
| +1984-10-11T12:00+ | +1984-10-28T12:00:42+
2+d|Rows: 1

|===

======


[discrete]
[[functions-localdatetime-truncate]]
=== Truncating a `LOCAL DATETIME`

`localdatetime.truncate()` returns the `LOCAL DATETIME` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `LOCAL DATETIME` returned will have all components that are less significant than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are less significant than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these less significant components.
For example, `day` -- with some value `x` -- may be provided when the truncation unit `STRING` is `'year'` in order to ensure the returned value has the _day_ set to `x` instead of the default _day_ (which is `1`).

*Syntax:*

[source, syntax, role="noheader"]
----
localdatetime.truncate(unit [, temporalInstantValue [, mapOfComponents ] ])
----

*Returns:*

|===

| `LOCAL DATETIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `unit`
| A string expression evaluating to one of the following `STRING` values`: `'millennium'`, `'century'`, `'decade'`, `'year'`, `'weekYear'`, `'quarter'`, `'month'`, `'week'`, `'day'`, `'hour'`, `'minute'`, `'second'`, `'millisecond'`, `'microsecond'`.

| `temporalInstantValue`
| An expression of one of the following types: `ZONED DATETIME`, `LOCAL DATETIME`, `DATE`.

| `mapOfComponents`
| An expression evaluating to a map containing components less significant than `unit`.

|===

*Considerations:*

|===

| `temporalInstantValue` cannot be a `DATE` value if `unit` is one of: `'hour'`, `'minute'`, `'second'`, `'millisecond'`, `'microsecond'`.
| Any component that is provided in `mapOfComponents` must be less significant than `unit`; i.e. if `unit` is `'day'`, `mapOfComponents` cannot contain information pertaining to a _month_.
| Any component that is not contained in `mapOfComponents` and which is less significant than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `mapOfComponents` is not provided, all components of the returned value which are less significant than `unit` will be set to their default values.
| If `temporalInstantValue` is not provided, it will be set to the current date and time, i.e. `localdatetime.truncate(unit)` is equivalent of `localdatetime.truncate(unit, localdatetime())`.

|===


.+localdatetime.truncate()+
======

.Query
[source, cypher]
----
WITH
  localdatetime({
    year: 2017, month: 11, day: 11,
    hour: 12, minute: 31, second: 14, nanosecond: 645876123
  }) AS d
RETURN
  localdatetime.truncate('millennium', d) AS truncMillenium,
  localdatetime.truncate('year', d, {day: 2}) AS truncYear,
  localdatetime.truncate('month', d) AS truncMonth,
  localdatetime.truncate('day', d) AS truncDay,
  localdatetime.truncate('hour', d, {nanosecond: 2}) AS truncHour,
  localdatetime.truncate('second', d) AS truncSecond
----

.Result
[role="queryresult",options="header,footer",cols="6*<m"]
|===

| +truncMillenium+ | +truncYear+ | +truncMonth+ | +truncDay+ | +truncHour+ | +truncSecond+
| +2000-01-01T00:00+ | +2017-01-02T00:00+ | +2017-11-01T00:00+ | +2017-11-11T00:00+ | +2017-11-11T12:00:00.000000002+ | +2017-11-11T12:31:14+
6+d|Rows: 1

|===

======


[[functions-localtime]]
== +localtime()+

Details for using the `localtime()` function.

* xref::functions/temporal/index.adoc#functions-localtime-current[Getting the current `LOCAL TIME`]
** xref::functions/temporal/index.adoc#functions-localtime-transaction[+localtime.transaction()+]
** xref::functions/temporal/index.adoc#functions-localtime-statement[+localtime.statement()+]
** xref::functions/temporal/index.adoc#functions-localtime-realtime[+localtime.realtime()+]

* xref::functions/temporal/index.adoc#functions-localtime-create[Creating a `LOCAL TIME`]
* xref::functions/temporal/index.adoc#functions-localtime-create-string[Creating a `LOCAL TIME` from a `STRING`]
* xref::functions/temporal/index.adoc#functions-localtime-temporal[Creating a `LOCAL TIME` using other temporal values as components]
* xref::functions/temporal/index.adoc#functions-localtime-truncate[Truncating a `LOCAL TIME`]


[discrete]
[[functions-localtime-current]]
=== Getting the current `LOCAL TIME`

`localtime()` returns the current `LOCAL TIME` value.
If no time zone parameter is specified, the local time zone will be used.

*Syntax:*

[source, syntax, role="noheader"]
----
localtime([{timezone}])
----

*Returns:*

|===

| `LOCAL TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===

*Considerations:*

|===

| If no parameters are provided, `localtime()` must be invoked (`+localtime({})+` is invalid).

|===


.+localtime()+
======

.Query
[source, cypher]
----
RETURN localtime() AS now
----

The current local time (i.e. in the local time zone) is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +10:02:31.596+
1+d|Rows: 1

|===

======


.+localtime()+
======

.Query
[source, cypher]
----
RETURN localtime({timezone: 'America/Los Angeles'}) AS nowInLA
----

The current local time in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +nowInLA+
| +03:02:31.629+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localtime-transaction]]
==== localtime.transaction()

`localtime.transaction()` returns the current `LOCAL TIME` value using the `transaction` clock.
This value will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

*Syntax:*

[source, syntax, role="noheader"]
----
localtime.transaction([{timezone}])
----

*Returns:*

|===

| `LOCAL TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+localtime.transaction()+
======

.Query
[source, cypher]
----
RETURN localtime.transaction() AS now
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +10:02:31.662+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localtime-statement]]
==== localtime.statement()

`localtime.statement()` returns the current `LOCAL TIME` value using the `statement` clock.
This value will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.

*Syntax:*

[source, syntax, role="noheader"]
----
localtime.statement([{timezone}])
----

*Returns:*

|===

| `LOCAL TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+localtime.statement()+
======

.Query
[source, cypher]
----
RETURN localtime.statement() AS now
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +10:02:31.697+
1+d|Rows: 1

|===

======


.+localtime.statement()+
======

.Query
[source, cypher]
----
RETURN localtime.statement('America/Los Angeles') AS nowInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +nowInLA+
| +03:02:31.737+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localtime-realtime]]
==== localtime.realtime()

`localtime.realtime()` returns the current `LOCAL TIME` value using the `realtime` clock.
This value will be the live clock of the system.

*Syntax:*

[source, syntax, role="noheader"]
----
localtime.realtime([{timezone}])
----

*Returns:*

|===

| `LOCAL TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+localtime.realtime()+
======

.Query
[source, cypher]
----
RETURN localtime.realtime() AS now
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +now+
| +10:02:31.806895+
1+d|Rows: 1

|===

======


[discrete]
[[functions-localtime-create]]
=== Creating a `LOCAL TIME`

`localtime()` returns a `LOCAL TIME` value with the specified _hour_, _minute_, _second_, _millisecond_, _microsecond_ and _nanosecond_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
localtime({hour [, minute, second, millisecond, microsecond, nanosecond]})
----

*Returns:*

|===

| `LOCAL TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

*Considerations:*
|===

| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `hour` and `minute`, but specifying `hour` and `second` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+localtime()+
======

.Query
[source, cypher]
----
UNWIND [
localtime({hour: 12, minute: 31, second: 14, nanosecond: 789, millisecond: 123, microsecond: 456}),
localtime({hour: 12, minute: 31, second: 14}),
localtime({hour: 12})
] AS theTime
RETURN theTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theTime+
| +12:31:14.123456789+
| +12:31:14+
| +12:00+
1+d|Rows: 3

|===

======


[discrete]
[[functions-localtime-create-string]]
=== Creating a `LOCAL TIME` from a `STRING`

`localtime()` returns the `LOCAL TIME` value obtained by parsing a `STRING` representation of a temporal value.

*Syntax:*

[source, syntax, role="noheader"]
----
localtime(temporalValue)
----

*Returns:*

|===

| `LOCAL TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `temporalValue`
| A `STRING` representing a temporal value.

|===

*Considerations:*

|===

| `temporalValue` must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-time[times].
| `temporalValue` must denote a valid time; i.e. a `temporalValue` denoting `13:46:64` is invalid.
| `localtime(null)` returns null.

|===


.+localtime()+
======

.Query
[source, cypher]
----
UNWIND [
localtime('21:40:32.142'),
localtime('214032.142'),
localtime('21:40'),
localtime('21')
] AS theTime
RETURN theTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theTime+
| +21:40:32.142+
| +21:40:32.142+
| +21:40+
| +21:00+
1+d|Rows: 4

|===

======


[discrete]
[[functions-localtime-temporal]]
=== Creating a `LOCAL TIME` using other temporal values as components

`localtime()` returns the `LOCAL TIME` value obtained by selecting and composing components from another temporal value.
In essence, this allows a `ZONED DATETIME`, `LOCAL DATETIME` or `ZONED TIME` value to be converted to a `LOCAL TIME`, and for "missing" components to be provided.

*Syntax:*

[source, syntax, role="noheader"]
----
localtime({time [, hour, ..., nanosecond]})
----

*Returns:*

|===

| `LOCAL TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `time`
| A `ZONED TIME` value.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

|===

*Considerations:*

|===

| If any of the optional parameters are provided, these will override the corresponding components of `time`.
| `localtime(tt)` may be written instead of `+localtime({time: tt})+`.

|===


.+localtime()+
======

.Query
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}) AS tt
RETURN
  localtime({time: tt}) AS timeOnly,
  localtime({time: tt, second: 42}) AS timeSS
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| +timeOnly+ | +timeSS+
| +12:31:14.645876+ | +12:31:42.645876+
2+d|Rows: 1

|===

======


[discrete]
[[functions-localtime-truncate]]
=== Truncating a `LOCAL TIME`

`localtime.truncate()` returns the `LOCAL TIME` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `LOCAL TIME` returned will have all components that are less significant than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are less significant than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these less significant components.
For example, `minute` -- with some value `x` -- may be provided when the truncation unit string is `'hour'` in order to ensure the returned value has the _minute_ set to `x` instead of the default _minute_ (which is `1`).

*Syntax:*

[source, syntax, role="noheader"]
----
localtime.truncate(unit [, temporalInstantValue [, mapOfComponents ] ])
----

*Returns:*

|===

| `LOCAL TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `unit`
| A string expression evaluating to one of the following `STRING` values: `'day'`, `'hour'`, `'minute'`, `'second'`, `'millisecond'`, `'microsecond'`.

| `temporalInstantValue`
| An expression of one of the following types: `ZONED DATETIME`, `LOCAL DATETIME`, `ZONED TIME`, `LOCAL TIME`.

| `mapOfComponents`
| An expression evaluating to a map containing components less significant than `unit`.

|===

*Considerations:*

|===

a|
Truncating time to day -- i.e. `unit` is `'day'`  -- is supported, and yields midnight at the start of the day (`00:00`), regardless of the value of `temporalInstantValue`.
However, the time zone of `temporalInstantValue` is retained.
| Any component that is provided in `mapOfComponents` must be less significant than `unit`; i.e. if `unit` is `'second'`, `mapOfComponents` cannot contain information pertaining to a _minute_.
| Any component that is not contained in `mapOfComponents` and which is less significant than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `mapOfComponents` is not provided, all components of the returned value which are less significant than `unit` will be set to their default values.
| If `temporalInstantValue` is not provided, it will be set to the current time, i.e. `localtime.truncate(unit)` is equivalent of `localtime.truncate(unit, localtime())`.

|===


.+localtime.truncate()+
======

.Query
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}) AS t
RETURN
  localtime.truncate('day', t) AS truncDay,
  localtime.truncate('hour', t) AS truncHour,
  localtime.truncate('minute', t, {millisecond: 2}) AS truncMinute,
  localtime.truncate('second', t) AS truncSecond,
  localtime.truncate('millisecond', t) AS truncMillisecond,
  localtime.truncate('microsecond', t) AS truncMicrosecond
----

.Result
[role="queryresult",options="header,footer",cols="6*<m"]
|===

| +truncDay+ | +truncHour+ | +truncMinute+ | +truncSecond+ | +truncMillisecond+ | +truncMicrosecond+
| +00:00:00+ | +12:00:00+ | +12:31:00.002000000+ | +12:31:14"+ | +12:31:14.645000000+ | +12:31:14.645876000+
6+d|Rows: 1

|===

======


[[functions-time]]
== +time()+

Details for using the `time()` function.

* xref::functions/temporal/index.adoc#functions-time-current[Getting the current `ZONED TIME`]
** xref::functions/temporal/index.adoc#functions-time-transaction[+time.transaction()+]
** xref::functions/temporal/index.adoc#functions-time-statement[+time.statement()+]
** xref::functions/temporal/index.adoc#functions-time-realtime[+time.realtime()+]

* xref::functions/temporal/index.adoc#functions-time-create[Creating a `ZONED TIME`]
* xref::functions/temporal/index.adoc#functions-time-create-string[Creating a `ZONED TIME` from a `STRING`]
* xref::functions/temporal/index.adoc#functions-time-temporal[Creating a `ZONED TIME` using other temporal values as components]
* xref::functions/temporal/index.adoc#functions-time-truncate[Truncating a `ZONED TIME`]


[discrete]
[[functions-time-current]]
=== Getting the current `ZONED TIME`

`time()` returns the current `ZONED TIME` value.
If no time zone parameter is specified, the local time zone will be used.

*Syntax:*

[source, syntax, role="noheader"]
----
time([{timezone}])
----

*Returns:*

|===

| `ZONED TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===

*Considerations:*

|===

| If no parameters are provided, `time()` must be invoked (`+time({})+` is invalid).

|===


.+time()+
======

.Query
[source, cypher]
----
RETURN time() AS currentTime
----

The current time of day using the local time zone is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentTime+
| +10:02:32.192Z+
1+d|Rows: 1

|===

======


.+time()+
======

.Query
[source, cypher]
----
RETURN time({timezone: 'America/Los Angeles'}) AS currentTimeInLA
----

The current time of day in California is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentTimeInLA+
| +03:02:32.233-07:00+
1+d|Rows: 1

|===

======


[discrete]
[[functions-time-transaction]]
==== time.transaction()

`time.transaction()` returns the current `ZONED TIME` value using the `transaction` clock.
This value will be the same for each invocation within the same transaction.
However, a different value may be produced for different transactions.

*Syntax:*

[source, syntax, role="noheader"]
----
time.transaction([{timezone}])
----

*Returns:*

|===

| `ZONED TIME`

|===

*Arguments:*
[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+time.transaction()+
======

.Query
[source, cypher]
----
RETURN time.transaction() AS currentTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +currentTime+
| +10:02:32.276Z+
1+d|Rows: 1
|===

======


[discrete]
[[functions-time-statement]]
==== time.statement()

`time.statement()` returns the current `ZONED TIME` value  using the `statement` clock.
This value will be the same for each invocation within the same statement.
However, a different value may be produced for different statements within the same transaction.

*Syntax:*

[source, syntax, role="noheader"]
----
time.statement([{timezone}])
----

*Returns:*

|===

| `ZONED TIME`

|===


*Arguments:*
[options="header"]
|===
| Name | Description

| `timezone` | A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+time.statement()+
======

.Query
[source, cypher]
----
RETURN time.statement() AS currentTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentTime+
| +10:02:32.317Z+
1+d|Rows: 1

|===

======


.+time.statement()+
======

.Query
[source, cypher]
----
RETURN time.statement('America/Los Angeles') AS currentTimeInLA
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentTimeInLA+
| +03:02:32.351-07:00+
1+d|Rows: 1

|===

======


[discrete]
[[functions-time-realtime]]
==== time.realtime()

`time.realtime()` returns the current `ZONED TIME` value using the `realtime` clock.
This value will be the live clock of the system.

*Syntax:*

[source, syntax, role="noheader"]
----
time.realtime([{timezone}])
----

*Returns:*

|===

| `ZONED TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `timezone`
| A string expression that represents the xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zone].

|===


.+time.realtime()+
======

.Query
[source, cypher]
----
RETURN time.realtime() AS currentTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +currentTime+
| +10:02:32.436948Z+
1+d|Rows: 1

|===

======


[discrete]
[[functions-time-create]]
=== Creating a `ZONED TIME`

`time()` returns a `ZONED TIME` value with the specified _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ and _timezone_ component values.

*Syntax:*

[source, syntax, role="noheader"]
----
time({hour [, minute, second, millisecond, microsecond, nanosecond, timezone]})
----

*Returns:*

|===

| `ZONED TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the time zone.

|===

*Considerations:*

|===

| The _hour_ component will default to `0` if `hour` is omitted.
| The _minute_ component will default to `0` if `minute` is omitted.
| The _second_ component will default to `0` if `second` is omitted.
| Any missing `millisecond`, `microsecond` or `nanosecond` values will default to `0`.
| The _timezone_ component will default to the configured default time zone if `timezone` is omitted.
| If `millisecond`, `microsecond` and `nanosecond` are given in combination (as part of the same set of parameters), the individual values must be in the range `0` to `999`.
| The least significant components in the set `hour`, `minute`, and `second` may be omitted; i.e. it is possible to specify only `hour` and `minute`, but specifying `hour` and `second` is not permitted.
| One or more of `millisecond`, `microsecond` and `nanosecond` can only be specified as long as `second` is also specified.

|===


.+time()+
======

.Query
[source, cypher]
----
UNWIND [
time({hour: 12, minute: 31, second: 14, millisecond: 123, microsecond: 456, nanosecond: 789}),
time({hour: 12, minute: 31, second: 14, nanosecond: 645876123}),
time({hour: 12, minute: 31, second: 14, microsecond: 645876, timezone: '+01:00'}),
time({hour: 12, minute: 31, timezone: '+01:00'}),
time({hour: 12, timezone: '+01:00'})
] AS theTime
RETURN theTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theTime+
| +12:31:14.123456789Z+
| +12:31:14.645876123Z+
| +12:31:14.645876000+01:00+
| +12:31:00+01:00+
| +12:00:00+01:00+
1+d|Rows: 5

|===

======


[discrete]
[[functions-time-create-string]]
=== Creating a `ZONED TIME` from a `STRING`

`time()` returns the `ZONED TIME` value obtained by parsing a `STRING` representation of a temporal value.

*Syntax:*

[source, syntax, role="noheader"]
----
time(temporalValue)
----

*Returns:*

|===

| `ZONED TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `temporalValue`
| A `STRING` representing a temporal value.

|===

*Considerations:*

|===

| `temporalValue` must comply with the format defined for xref::values-and-types/temporal.adoc#cypher-temporal-specify-time[times] and xref::values-and-types/temporal.adoc#cypher-temporal-specify-time-zone[time zones].
| The _timezone_ component will default to the configured default time zone if it is omitted.
| `temporalValue` must denote a valid time; i.e. a `temporalValue` denoting `15:67` is invalid.
| `time(null)` returns `null`.

|===


.+time()+
======

.Query
[source, cypher]
----
UNWIND [
time('21:40:32.142+0100'),
time('214032.142Z'),
time('21:40:32+01:00'),
time('214032-0100'),
time('21:40-01:30'),
time('2140-00:00'),
time('2140-02'),
time('22+18:00')
] AS theTime
RETURN theTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===

| +theTime+
| +21:40:32.142000000+01:00+
| +21:40:32.142000000Z+
| +21:40:32+01:00+
| +21:40:32-01:00+
| +21:40:00-01:30+
| +21:40:00Z+
| +21:40:00-02:00+
| +22:00:00+18:00+
1+d|Rows: 8

|===

======


[discrete]
[[functions-time-temporal]]
=== Creating a `ZONED TIME` using other temporal values as components

`time()` returns the `ZONED TIME` value obtained by selecting and composing components from another temporal value.
In essence, this allows a `ZONED DATETIME`, `LOCAL DATETIME` or `LOCAL TIME` value to be converted to a `ZONED TIME`, and for "missing" components to be provided.

*Syntax:*

[source, syntax, role="noheader"]
----
time({time [, hour, ..., timezone]})
----

*Returns:*

|===

| `ZONED TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `A single map consisting of the following:`
|

| `time`
| A `ZONED TIME` value.

| `hour`
| An integer between `0` and `23` that specifies the hour of the day.

| `minute`
| An integer between `0` and `59` that specifies the number of minutes.

| `second`
| An integer between `0` and `59` that specifies the number of seconds.

| `millisecond`
| An integer between `0` and `999` that specifies the number of milliseconds.

| `microsecond`
| An integer between `0` and `999,999` that specifies the number of microseconds.

| `nanosecond`
| An integer between `0` and `999,999,999` that specifies the number of nanoseconds.

| `timezone`
| An expression that specifies the time zone.

|===

*Considerations:*

|===

| If any of the optional parameters are provided, these will override the corresponding components of `time`.
| `time(tt)` may be written instead of `+time({time: tt})+`.
| Selecting a `ZONED TIME` or `ZONED DATETIME` value as the `time` component also selects its time zone. If a `LOCAL TIME` or `LOCAL DATETIME` is selected instead, the default time zone is used. In any case, the time zone can be overridden explicitly.
| Selecting a `ZONED DATETIME` or `ZONED TIME` as the `time` component and overwriting the time zone will adjust the local time to keep the same point in time.

|===


.+time()+
======

.Query
[source, cypher]
----
WITH localtime({hour: 12, minute: 31, second: 14, microsecond: 645876}) AS tt
RETURN
  time({time: tt}) AS timeOnly,
  time({time: tt, timezone: '+05:00'}) AS timeTimezone,
  time({time: tt, second: 42}) AS timeSS,
  time({time: tt, second: 42, timezone: '+05:00'}) AS timeSSTimezone
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===

| +timeOnly+ | +timeTimezone+ | +timeSS+ | +timeSSTimezone+
| +12:31:14.645876Z+ | +12:31:14.645876+05:00+ | +12:31:42.645876Z+ | +12:31:42.645876+05:00+
4+d|Rows: 1

|===

======


[discrete]
[[functions-time-truncate]]
=== Truncating a `ZONED TIME`

`time.truncate()` returns the `ZONED TIME` value obtained by truncating a specified temporal instant value at the nearest preceding point in time at the specified component boundary (which is denoted by the truncation unit passed as a parameter to the function).
In other words, the `ZONED TIME` returned will have all components that are less significant than the specified truncation unit set to their default values.

It is possible to supplement the truncated value by providing a map containing components which are less significant than the truncation unit.
This will have the effect of _overriding_ the default values which would otherwise have been set for these less significant components.
For example, `minute` -- with some value `x` -- may be provided when the truncation unit `STRING` is `'hour'` in order to ensure the returned value has the _minute_ set to `x` instead of the default _minute_ (which is `1`).

*Syntax:*

[source, syntax, role="noheader"]
----
time.truncate(unit [, temporalInstantValue [, mapOfComponents ] ])
----

*Returns:*

|===

| `ZONED TIME`

|===

*Arguments:*

[options="header"]
|===
| Name | Description

| `unit`
| A string expression evaluating to one of the following `STRING` values: `'day'`, `'hour'`, `'minute'`, `'second'`, `'millisecond'`, `'microsecond'`.

| `temporalInstantValue`
| An expression of one of the following types: `ZONED DATETIME`, `LOCAL DATETIME`, `ZONED TIME`, `LOCAL TIME`.

| `mapOfComponents`
a|
An expression evaluating to a map containing components less significant than `unit`.
During truncation, a time zone can be attached or overridden using the key `timezone`.

|===

*Considerations:*

|===

| Truncating time to day -- i.e. `unit` is `'day'`  -- is supported, and yields midnight at the start of the day (`00:00`), regardless of the value of `temporalInstantValue`. However, the time zone of `temporalInstantValue` is retained.
| The time zone of `temporalInstantValue` may be overridden; for example, `+time.truncate('minute', input, {timezone: '+0200'})+`.
| If `temporalInstantValue` is one of `ZONED TIME`, `ZONED DATETIME` -- a value with a time zone -- and the time zone is overridden, no time conversion occurs.
| If `temporalInstantValue` is one of `LOCAL TIME`, `LOCAL DATETIME`, `DATE` -- a value without a time zone -- and the time zone is not overridden, the configured default time zone will be used.
| Any component that is provided in `mapOfComponents` must be less significant than `unit`; i.e. if `unit` is `'second'`, `mapOfComponents` cannot contain information pertaining to a _minute_.
| Any component that is not contained in `mapOfComponents` and which is less significant than `unit` will be set to its xref::values-and-types/temporal.adoc#cypher-temporal-accessing-components-temporal-instants[minimal value].
| If `mapOfComponents` is not provided, all components of the returned value which are less significant than `unit` will be set to their default values.
| If `temporalInstantValue` is not provided, it will be set to the current time and timezone, i.e. `time.truncate(unit)` is equivalent of `time.truncate(unit, time())`.
|===


.+time()+
======

.Query
[source, cypher]
----
WITH time({hour: 12, minute: 31, second: 14, nanosecond: 645876123, timezone: '-01:00'}) AS t
RETURN
  time.truncate('day', t) AS truncDay,
  time.truncate('hour', t) AS truncHour,
  time.truncate('minute', t) AS truncMinute,
  time.truncate('second', t) AS truncSecond,
  time.truncate('millisecond', t, {nanosecond: 2}) AS truncMillisecond,
  time.truncate('microsecond', t) AS truncMicrosecond
----

.Result
[role="queryresult",options="header,footer",cols="6*<m"]
|===

| +truncDay+ | +truncHour+ | +truncMinute+ | +truncSecond+ | +truncMillisecond+ | +truncMicrosecond+
| +00:00:00-01:00+ | +12:00:00-01:00+ | +12:31:00-01:00+ | +12:31:14-01:00+ | +12:31:14.645000002-01:00+ | +12:31:14.645876000-01:00+
6+d|Rows: 1

|===

======

