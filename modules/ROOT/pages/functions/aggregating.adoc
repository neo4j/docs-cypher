[[query-functions-aggregating]]
= Aggregating functions

To calculate aggregated data, Cypher offers aggregation, analogous to SQL's `GROUP BY`.

Aggregating functions take a set of values and calculate an aggregated value over them.
Examples are `avg()` that calculates the average of multiple numeric values, or `min()` that finds the smallest numeric or string value in a set of values.
When we say below that an aggregating function operates on a _set of values_, we mean these to be the result of the application of the inner expression (such as `n.age`) to all the records within the same aggregation group.

Aggregation can be computed over all the matching subgraphs, or it can be further divided by introducing grouping keys.
These are non-aggregate expressions, that are used to group the values going into the aggregate functions.

Assume we have the following return statement:

[source, cypher]
----
RETURN n, count(*)
----


We have two return expressions: `n`, and `count(*)`.
The first, `n`, is not an aggregate function, and so it will be the grouping key.
The latter, `count(*)` is an aggregate expression.
The matching subgraphs will be divided into different buckets, depending on the grouping key.
The aggregate function will then be run on these buckets, calculating an aggregate value per bucket.

To use aggregations to sort the result set, the aggregation must be included in the `RETURN` to be used in the `ORDER BY`.


The `DISTINCT` operator works in conjunction with aggregation.
It is used to make all values unique before running them through an aggregate function.
More information about `DISTINCT` may be found xref:syntax/operators.adoc#query-operators-aggregation[here].

Functions:

* xref:functions/aggregating.adoc#functions-avg[avg() - Numeric values]
* xref:functions/aggregating.adoc#functions-avg-duration[avg() - Durations]
* xref:functions/aggregating.adoc#functions-collect[collect()]
* xref:functions/aggregating.adoc#functions-count[count()]
* xref:functions/aggregating.adoc#functions-max[max()]
* xref:functions/aggregating.adoc#functions-min[min()]
* xref:functions/aggregating.adoc#functions-percentilecont[percentileCont()]
* xref:functions/aggregating.adoc#functions-percentiledisc[percentileDisc()]
* xref:functions/aggregating.adoc#functions-stdev[stDev()]
* xref:functions/aggregating.adoc#functions-stdevp[stDevP()]
* xref:functions/aggregating.adoc#functions-sum[sum() - Numeric values]
* xref:functions/aggregating.adoc#functions-sum-duration[sum() - Durations]
      

The following graph is used for the examples below:

.Graph
["dot", "Aggregating functions-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Person|name = \'A\'\lage = 13\l}"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "{Person|name = \'B\'\lage = 33\leyes = \'blue\'\l}"
  ]
  N1 -> N4 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N2 [
    label = "{Person|name = \'C\'\lage = 44\leyes = \'blue\'\l}"
  ]
  N2 -> N4 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "{Person|name = \'D\'\leyes = \'brown\'\l}"
  ]
  N4 [
    label = "{Person|name = \'D\'\l}"
  ]

----
 

[[functions-avg]]
== avg() - Numeric values

`avg()` returns the average of a set of numeric values.

*Syntax:* `avg(expression)`

*Returns:*
|===
|
Either an Integer or a Float, depending on the values returned by `expression` and whether or not the calculation overflows.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression returning a set of numeric values.
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|`avg(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (n:Person)
RETURN avg(n.age)
----

The average of all the values in the property `age` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +avg(n.age)+
| +30.0+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n:Person) RETURN avg(n.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-avg-duration]]
== avg() - Durations

`avg()` returns the average of a set of Durations.

*Syntax:* `avg(expression)`

*Returns:*
|===
|
A Duration.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression returning a set of Durations.
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|`avg(null)` returns `null`.
|===


.Query
[source, cypher]
----
UNWIND [duration('P2DT3H'), duration('PT1H45S')] AS dur
RETURN avg(dur)
----

The average of the two supplied Durations is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +avg(dur)+
| +P1DT2H22.5S+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
UNWIND [duration('P2DT3H'), duration('PT1H45S')] AS dur RETURN avg(dur)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-collect]]
== collect()

`collect()` returns a list containing the values returned by an expression.
Using this function aggregates data by amalgamating multiple records or values into a single list.

*Syntax:* `collect(expression)`

*Returns:*
|===
|
A list containing heterogeneous elements; the types of the elements are determined by the values returned by `expression`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression returning a set of values.
|===


*Considerations:*
|===
|Any `null` values are ignored and will not be added to the list.
|`collect(null)` returns an empty list.
|===


.Query
[source, cypher]
----
MATCH (n:Person)
RETURN collect(n.age)
----

All the values are collected and returned in a single list.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +collect(n.age)+
| +[13,33,44]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n:Person) RETURN collect(n.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-count]]
== count()

`count()` returns the number of values or rows, and appears in two variants:

* `count(*)` returns the number of matching rows, and
* `count(expr)` returns the number of non-`null` values returned by an expression.
        

*Syntax:* `count(expression)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression.
|===


*Considerations:*
|===
|`count(*)` includes rows returning `null`.
|`count(expr)` ignores `null` values.
|`count(null)` returns `0`.
|===

=== Using `count(*)` to return the number of nodes

`count(*)` can be used to return the number of nodes; for example, the number of nodes connected to some node `n`.


.Query
[source, cypher]
----
MATCH (n { name: 'A' })-->(x)
RETURN labels(n), n.age, count(*)
----

The labels and `age` property of the start node `n` and the number of nodes related to `n` are returned.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +labels(n)+ | +n.age+ | +count(*)+
| +["Person"]+ | +13+ | +3+
3+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n {name: 'A'})-->(x) RETURN labels(n), n.age, count(*)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

=== Using `count(*)` to group and count relationship types

`count(*)` can be used to group relationship types and return the number.


.Query
[source, cypher]
----
MATCH (n { name: 'A' })-[r]->()
RETURN type(r), count(*)
----

The relationship types and their group count are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +type(r)+ | +count(*)+
| +"KNOWS"+ | +3+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n {name: 'A'})-[r]->() RETURN type(r), count(*)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

=== Using `count(expression)` to return the number of values

Instead of simply returning the number of rows with `count(*)`, it may be more useful to return the actual number of values returned by an expression.


.Query
[source, cypher]
----
MATCH (n { name: 'A' })-->(x)
RETURN count(x)
----

The number of nodes connected to the start node is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +count(x)+
| +3+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n {name: 'A'})-->(x) RETURN count(x)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

=== Counting non-`null` values

`count(expression)` can be used to return the number of non-`null` values returned by the expression.


.Query
[source, cypher]
----
MATCH (n:Person)
RETURN count(n.age)
----

The number of `:Person` nodes having an `age` property is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +count(n.age)+
| +3+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n:Person) RETURN count(n.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

=== Counting with and without duplicates

In this example we are trying to find all our friends of friends, and count them:

* The first aggregate function, `count(DISTINCT friend_of_friend)`, will only count a `friend_of_friend` once, as `DISTINCT` removes the duplicates.
* The second aggregate function, `count(friend_of_friend)`, will consider the same `friend_of_friend` multiple times.


.Query
[source, cypher]
----
MATCH (me:Person)-->(friend:Person)-->(friend_of_friend:Person)
WHERE me.name = 'A'
RETURN count(DISTINCT friend_of_friend), count(friend_of_friend)
----

Both `B` and `C` know `D` and thus `D` will get counted twice when not using `DISTINCT`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +count(DISTINCT friend_of_friend)+ | +count(friend_of_friend)+
| +1+ | +2+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (me:Person)-->(friend:Person)-->(friend_of_friend:Person)
WHERE me.name = 'A'
RETURN count(DISTINCT friend_of_friend), count(friend_of_friend)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-max]]
== max()

`max()` returns the maximum value in a set of values.

*Syntax:* `max(expression)`

*Returns:*
|===
|
A xref:syntax/values.adoc#property-types[property type], or a list, depending on the values returned by `expression`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression returning a set containing any combination of xref:syntax/values.adoc#property-types[property types] and lists thereof.
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|In a mixed set, any numeric value is always considered to be higher than any string value, and any string value is always considered to be higher than any list.
|Lists are compared in dictionary order, i.e. list elements are compared pairwise in ascending order from the start of the list to the end.
|`max(null)` returns `null`.
|===


.Query
[source, cypher]
----
UNWIND [1, 'a', NULL , 0.2, 'b', '1', '99'] AS val
RETURN max(val)
----

The highest of all the values in the mixed set -- in this case, the numeric value `1` -- is returned.
Note that the (string) value `"99"`, which may _appear_ at first glance to be the highest value in the list, is considered to be a lower value than `1` as the latter is a string.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +max(val)+
| +1+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
UNWIND [1, 'a', null, 0.2, 'b', '1', '99'] AS val RETURN max(val)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


.Query
[source, cypher]
----
UNWIND [[1, 'a', 89],[1, 2]] AS val
RETURN max(val)
----

The highest of all the lists in the set -- in this case, the list `[1, 2]` -- is returned, as the number `2` is considered to be a higher value than the string `"a"`, even though the list `[1, 'a', 89]` contains more elements.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +max(val)+
| +[1,2]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
UNWIND [[1, 'a', 89], [1, 2]] AS val RETURN max(val)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


.Query
[source, cypher]
----
MATCH (n:Person)
RETURN max(n.age)
----

The highest of all the values in the property `age` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +max(n.age)+
| +44+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n:Person) RETURN max(n.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-min]]
== min()

`min()` returns the minimum value in a set of values.

*Syntax:* `min(expression)`

*Returns:*
|===
|
A xref:syntax/values.adoc#property-types[property type], or a list, depending on the values returned by `expression`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression returning a set containing any combination of xref:syntax/values.adoc#property-types[property types] and lists thereof.
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|In a mixed set, any string value is always considered to be lower than any numeric value, and any list is always considered to be lower than any string.
|Lists are compared in dictionary order, i.e. list elements are compared pairwise in ascending order from the start of the list to the end.
|`min(null)` returns `null`.
|===


.Query
[source, cypher]
----
UNWIND [1, 'a', NULL , 0.2, 'b', '1', '99'] AS val
RETURN min(val)
----

The lowest of all the values in the mixed set -- in this case, the string value `"1"` -- is returned.
Note that the (numeric) value `0.2`, which may _appear_ at first glance to be the lowest value in the list, is considered to be a higher value than `"1"` as the latter is a string.
          

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +min(val)+
| +"1"+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
UNWIND [1, 'a', null, 0.2, 'b', '1', '99'] AS val RETURN min(val)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


.Query
[source, cypher]
----
UNWIND ['d',[1, 2],['a', 'c', 23]] AS val
RETURN min(val)
----

The lowest of all the values in the set -- in this case, the list `['a', 'c', 23]` -- is returned, as (i) the two lists are considered to be lower values than the string `"d"`, and (ii) the string `"a"` is considered to be a lower value than the numerical value `1`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +min(val)+
| +["a","c",23]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
UNWIND ['d', [1, 2], ['a', 'c', 23]] AS val RETURN min(val)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


.Query
[source, cypher]
----
MATCH (n:Person)
RETURN min(n.age)
----

The lowest of all the values in the property `age` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +min(n.age)+
| +13+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n:Person) RETURN min(n.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-percentilecont]]
== percentileCont()

`percentileCont()` returns the percentile of the given value over a group, with a percentile from 0.0 to 1.0.
It uses a linear interpolation method, calculating a weighted average between two values if the desired percentile lies between them.
For nearest values using a rounding method, see `percentileDisc`.

*Syntax:* `percentileCont(expression, percentile)`

*Returns:*
|===
|
A Float.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
| `percentile` | A numeric value between 0.0 and 1.0
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|`percentileCont(null, percentile)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (n:Person)
RETURN percentileCont(n.age, 0.4)
----

The 40th percentile of the values in the property `age` is returned, calculated with a weighted average. In this case, 0.4 is the median, or 40th percentile.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +percentileCont(n.age, 0.4)+
| +29.0+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n:Person) RETURN percentileCont(n.age, 0.4)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-percentiledisc]]
== percentileDisc()

`percentileDisc()` returns the percentile of the given value over a group, with a percentile from 0.0 to 1.0.
It uses a rounding method and calculates the nearest value to the percentile.
For interpolated values, see `percentileCont`.

*Syntax:* `percentileDisc(expression, percentile)`

*Returns:*
|===
|
Either an Integer or a Float, depending on the values returned by `expression` and whether or not the calculation overflows.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
| `percentile` | A numeric value between 0.0 and 1.0
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|`percentileDisc(null, percentile)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (n:Person)
RETURN percentileDisc(n.age, 0.5)
----

The 50th percentile of the values in the property `age` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +percentileDisc(n.age, 0.5)+
| +33+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n:Person) RETURN percentileDisc(n.age, 0.5)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-stdev]]
== stDev()

`stDev()` returns the standard deviation for the given value over a group.
It uses a standard two-pass method, with `N - 1` as the denominator, and should be used when taking a sample of the population for an unbiased estimate.
When the standard variation of the entire population is being calculated, `stdDevP` should be used.

*Syntax:* `stDev(expression)`

*Returns:*
|===
|
A Float.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|`stDev(null)` returns `0`.
|===


.Query
[source, cypher]
----
MATCH (n)
WHERE n.name IN ['A', 'B', 'C']
RETURN stDev(n.age)
----

The standard deviation of the values in the property `age` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +stDev(n.age)+
| +15.716233645501712+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n) WHERE n.name IN ['A', 'B', 'C'] RETURN stDev(n.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-stdevp]]
== stDevP()

`stDevP()` returns the standard deviation for the given value over a group.
It uses a standard two-pass method, with `N` as the denominator, and should be used when calculating the standard deviation for an entire population.
When the standard variation of only a sample of the population is being calculated, `stDev` should be used.

*Syntax:* `stDevP(expression)`

*Returns:*
|===
|
A Float.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|`stDevP(null)` returns `0`.
|===


.Query
[source, cypher]
----
MATCH (n)
WHERE n.name IN ['A', 'B', 'C']
RETURN stDevP(n.age)
----

The population standard deviation of the values in the property `age` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +stDevP(n.age)+
| +12.832251036613439+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n) WHERE n.name IN ['A', 'B', 'C'] RETURN stDevP(n.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-sum]]
== sum() - Numeric values

`sum()` returns the sum of a set of numeric values.

*Syntax:* `sum(expression)`

*Returns:*
|===
|
Either an Integer or a Float, depending on the values returned by `expression`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression returning a set of numeric values.
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|`sum(null)` returns `0`.
|===


.Query
[source, cypher]
----
MATCH (n:Person)
RETURN sum(n.age)
----

The sum of all the values in the property `age` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +sum(n.age)+
| +90+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
MATCH (n:Person) RETURN sum(n.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-sum-duration]]
== sum() - Durations

`sum()` returns the sum of a set of Durations.

*Syntax:* `sum(expression)`

*Returns:*
|===
|
A Duration.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression returning a set of Durations.
|===


*Considerations:*
|===
|Any `null` values are excluded from the calculation.
|===


.Query
[source, cypher]
----
UNWIND [duration('P2DT3H'), duration('PT1H45S')] AS dur
RETURN sum(dur)
----

The sum of the two supplied Durations is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +sum(dur)+
| +P2DT4H45S+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (a:Person {name: 'A', age: 13}),
       (b:Person {name: 'B', age: 33, eyes: 'blue'}),
       (c:Person {name: 'C', age: 44, eyes: 'blue'}),
       (d1:Person {name: 'D', eyes: 'brown'}),
       (d2:Person {name: 'D'}),

       (a)-[:KNOWS]->(d1),
       (a)-[:KNOWS]->(c),
       (a)-[:KNOWS]->(b),
       (c)-[:KNOWS]->(d2),
       (b)-[:KNOWS]->(d2)

]]></database><command><![CDATA[
UNWIND [duration('P2DT3H'), duration('PT1H45S')] AS dur RETURN sum(dur)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

