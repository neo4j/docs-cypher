[[query-functions-predicate]]
= Predicate functions
:description: Predicates are boolean functions that return true or false for a given set of non-null input. They are most commonly used to filter out subgraphs in the `WHERE` part of a query. 

Functions:

* xref:functions/predicate.adoc#functions-all[all()]
* xref:functions/predicate.adoc#functions-any[any()]
* xref:functions/predicate.adoc#functions-exists[exists()]
* xref:functions/predicate.adoc#functions-none[none()]
* xref:functions/predicate.adoc#functions-single[single()]

.Graph
["dot", "Predicate functions-1.svg", "neoviz", ""]
----
  N0 [
    label = "name = \'Alice\'\leyes = \'brown\'\lage = 38\l"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "name = \'Bob\'\leyes = \'blue\'\lage = 25\l"
  ]
  N1 -> N4 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "MARRIED\n"
  ]
  N1 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N2 [
    label = "name = \'Charlie\'\leyes = \'green\'\lage = 53\l"
  ]
  N2 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "name = \'Daniel\'\leyes = \'brown\'\lage = 54\l"
  ]
  N4 [
    label = "array = \[\'one\', \'two\', \'three\'\]\lname = \'Eskil\'\leyes = \'blue\'\lage = 41\l"
  ]
  N5 [
    label = "eyes = \'brown\'\lage = 61\l"
  ]

----
 

[[functions-all]]
== all()

`all()` returns true if the predicate holds for all elements in the given list. `null` is returned if the list is `null` or all of its elements are `null`.

*Syntax:* `all(variable IN list WHERE predicate)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list. A single element cannot be explicitly passed as a literal in the cypher statement. However, an implicit conversion will happen for a single elements when passing node properties during cypher execution.
| `variable` | This is the variable that can be used from within the predicate.
| `predicate` | A predicate that is tested against all items in the list.
|===


.Query
[source, cypher]
----
MATCH p =(a)-[*1..3]->(b)
WHERE a.name = 'Alice' AND b.name = 'Daniel' AND ALL (x IN nodes(p) WHERE x.age > 30)
RETURN p
----

All nodes in the returned paths will have an `age` property of at least *'30'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(0)-[KNOWS,1]->(2)-[KNOWS,3]->(3)+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
       (alice {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
       (frank {age: 61, eyes: 'brown'}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (a)-[*1..3]->(b)
WHERE a.name = 'Alice' AND b.name = 'Daniel'
AND all(x IN nodes(p) WHERE x.age > 30)
RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-any]]
== any()

`any()` returns true if the predicate holds for at least one element in the given list. `null` is returned if the list is `null` or all of its elements are `null`.

*Syntax:* `any(variable IN list WHERE predicate)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list. A single element cannot be explicitly passed as a literal in the cypher statement. However, an implicit conversion will happen for a single elements when passing node properties during cypher execution.
| `variable` | This is the variable that can be used from within the predicate.
| `predicate` | A predicate that is tested against all items in the list.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Eskil' AND ANY (x IN a.array WHERE x = 'one')
RETURN a.name, a.array
----

All nodes in the returned paths have at least one *'one'* value set in the array property named `array`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.name+ | +a.array+
| +"Eskil"+ | +["one","two","three"]+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
       (alice {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
       (frank {age: 61, eyes: 'brown'}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Eskil'
AND any(x IN a.array WHERE x = 'one')
RETURN a.name, a.array
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-exists]]
== exists()

`exists()` returns true if a match for the given pattern exists in the graph, or if the specified property exists in the node, relationship or map. `null` is returned if the input argument is `null`.

*Syntax:* `exists(pattern-or-property)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `pattern-or-property` | A pattern or a property (in the form 'variable.prop').
|===


.Query
[source, cypher]
----
MATCH (n)
WHERE exists(n.name)
RETURN n.name AS name, exists((n)-[:MARRIED]->()) AS is_married
----

The names of all nodes with the `name` property are returned, along with a boolean `true` / `false` indicating if they are married.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+ | +is_married+
| +"Alice"+ | +false+
| +"Bob"+ | +true+
| +"Charlie"+ | +false+
| +"Daniel"+ | +false+
| +"Eskil"+ | +false+
2+d|5 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
       (alice {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
       (frank {age: 61, eyes: 'brown'}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)
WHERE exists(n.name)
RETURN n.name AS name, exists((n)-[:MARRIED]->()) AS is_married
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


.Query
[source, cypher]
----
MATCH (a),(b)
WHERE exists(a.name) AND NOT exists(b.name)
OPTIONAL MATCH (c:DoesNotExist)
RETURN a.name AS a_name, b.name AS b_name, exists(b.name) AS b_has_name, c.name AS c_name, exists(c.name) AS c_has_name
ORDER BY a_name, b_name, c_name
LIMIT 1
----

Three nodes are returned: one with a name property, one without a name property, and one that does not exist (e.g., is `null`). This query exemplifies the behavior of `exists()` when operating on `null` nodes.

.Result
[role="queryresult",options="header,footer",cols="5*<m"]
|===
| +a_name+ | +b_name+ | +b_has_name+ | +c_name+ | +c_has_name+
| +"Alice"+ | +<null>+ | +false+ | +<null>+ | +<null>+
5+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
       (alice {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
       (frank {age: 61, eyes: 'brown'}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a), (b)
WHERE exists(a.name) AND NOT exists(b.name)
OPTIONAL MATCH (c:DoesNotExist)
RETURN a.name AS a_name, b.name AS b_name, exists(b.name) AS b_has_name, c.name AS c_name, exists(c.name) AS c_has_name
ORDER BY a_name, b_name, c_name LIMIT 1
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-none]]
== none()

`none()` returns true if the predicate holds for no element in the given list. `null` is returned if the list is `null` or all of its elements are `null`.

*Syntax:* `none(variable IN list WHERE predicate)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list. A single element cannot be explicitly passed as a literal in the cypher statement. However, an implicit conversion will happen for a single elements when passing node properties during cypher execution.
| `variable` | This is the variable that can be used from within the predicate.
| `predicate` | A predicate that is tested against all items in the list.
|===


.Query
[source, cypher]
----
MATCH p =(n)-[*1..3]->(b)
WHERE n.name = 'Alice' AND NONE (x IN nodes(p) WHERE x.age = 25)
RETURN p
----

No node in the returned paths has an `age` property set to *'25'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(0)-[KNOWS,1]->(2)+
| +(0)-[KNOWS,1]->(2)-[KNOWS,3]->(3)+
1+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
       (alice {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
       (frank {age: 61, eyes: 'brown'}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (n)-[*1..3]->(b)
WHERE n.name = 'Alice'
AND none(x IN nodes(p) WHERE x.age = 25) RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-single]]
== single()

`single()` returns true if the predicate holds for exactly one of the elements in the given list. `null` is returned if the list is `null` or all of its elements are `null`.

*Syntax:* `single(variable IN list WHERE predicate)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
| `variable` | This is the variable that can be used from within the predicate.
| `predicate` | A predicate that is tested against all items in the list.
|===


.Query
[source, cypher]
----
MATCH p =(n)-->(b)
WHERE n.name = 'Alice' AND SINGLE (var IN nodes(p) WHERE var.eyes = 'blue')
RETURN p
----

Exactly one node in every returned path has the `eyes` property set to *'blue'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(0)-[KNOWS,0]->(1)+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
       (alice {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
       (frank {age: 61, eyes: 'brown'}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (n)-->(b)
WHERE n.name = 'Alice'
AND single(var IN nodes(p) WHERE var.eyes = 'blue')
RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

