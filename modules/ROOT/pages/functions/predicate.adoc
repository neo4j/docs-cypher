[[query-functions-predicate]]
= Predicate functions
:description: Predicates are boolean functions that return `true` or `false` for a given set of non-null input. They are most commonly used to filter out paths in the `WHERE` part of a query. 

Functions:

* xref:functions/predicate.adoc#functions-all[all()]
* xref:functions/predicate.adoc#functions-any[any()]
* xref:functions/predicate.adoc#functions-exists[exists()]
* xref:functions/predicate.adoc#functions-none[none()]
* xref:functions/predicate.adoc#functions-single[single()]

.Graph
["dot", "Predicate functions-1.svg", "neoviz", ""]
----
  N0 [
    label = "name = \'Alice\'\leyes = \'brown\'\lage = 38\l"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "name = \'Bob\'\leyes = \'blue\'\lage = 25\l"
  ]
  N1 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 -> N4 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "MARRIED\n"
  ]
  N2 [
    label = "name = \'Charlie\'\leyes = \'green\'\lage = 53\l"
  ]
  N2 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "name = \'Daniel\'\leyes = \'brown\'\lage = 54\l"
  ]
  N4 [
    label = "liked_colors = \[\'pink\', \'yellow\', \'black\'\]\lname = \'Eskil\'\leyes = \'blue\'\lage = 41\l"
  ]
  N5 [
    label = "alias = \'Frank\'\leyes = \'brown\'\lage = 61\lliked_colors = \[\'blue\', \'green\'\]\l"
  ]

----
 

[[functions-all]]
== all()

The function `all()` returns `true` if the predicate holds for all elements in the given list.
`null` is returned if the list is `null` or all of its elements are `null`.

*Syntax:* `all(variable IN list WHERE predicate)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
A single element cannot be explicitly passed as a literal in the cypher statement.
However, an implicit conversion will happen for single elements when passing node properties during cypher execution.
| `variable` | A variable that can be used from within the predicate.
| `predicate` | A predicate that is tested against all items in the list.
|===


.Query
[source, cypher]
----
MATCH p = (a)-[*1..3]->(b)
WHERE
  a.name = 'Alice'
  AND b.name = 'Daniel'
  AND all(x IN nodes(p) WHERE x.age > 30)
RETURN p
----

All nodes in the returned paths will have a property `age` with a value larger than `30`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(0)-[KNOWS,1]->(2)-[KNOWS,3]->(3)+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (frank {alias: 'Frank', age: 61, eyes: 'brown', liked_colors: ['blue', 'green']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (a)-[*1..3]->(b)
WHERE
  a.name = 'Alice'
  AND b.name = 'Daniel'
  AND all(x IN nodes(p) WHERE x.age > 30)
RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-any]]
== any()

The function `any()` returns `true` if the predicate holds for at least one element in the given list.
`null` is returned if the list is `null` or all of its elements are `null`.

*Syntax:* `any(variable IN list WHERE predicate)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
A single element cannot be explicitly passed as a literal in the cypher statement.
However, an implicit conversion will happen for single elements when passing node properties during cypher execution.
| `variable` | A variable that can be used from within the predicate.
| `predicate` | A predicate that is tested against all items in the list.
|===


.Query
[source, cypher]
----
MATCH (n)
WHERE any(color IN n.liked_colors WHERE color = 'yellow')
RETURN n
----

The query returns nodes with the property `liked_colors` (as a list), where at least one element has the value `'yellow'`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n+
| +Node[4]{liked_colors:["pink","yellow","black"],name:"Eskil",eyes:"blue",age:41}+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (frank {alias: 'Frank', age: 61, eyes: 'brown', liked_colors: ['blue', 'green']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)
WHERE any(color IN n.liked_colors WHERE color = 'yellow')
RETURN n
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-exists]]
== exists()

The function `exists()` returns `true` if a match for the given pattern exists in the graph, or if the specified property exists in the node, relationship or map.
`null` is returned if the input argument is `null`.

*Syntax:* `exists(pattern-or-property)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `pattern-or-property` | A pattern or a property (in the form 'variable.prop').
|===


.Query
[source, cypher]
----
MATCH (n)
WHERE exists(n.name)
RETURN
  n.name AS name,
  exists((n)-[:MARRIED]->()) AS is_married
----

The names of all nodes with the `name` property are returned, along with a boolean (`true` or `false`) indicating if they are married.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+ | +is_married+
| +"Alice"+ | +false+
| +"Bob"+ | +true+
| +"Charlie"+ | +false+
| +"Daniel"+ | +false+
| +"Eskil"+ | +false+
2+d|Rows: 5
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (frank {alias: 'Frank', age: 61, eyes: 'brown', liked_colors: ['blue', 'green']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)
WHERE exists(n.name)
RETURN
  n.name AS name,
  exists((n)-[:MARRIED]->()) AS is_married
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


.Query
[source, cypher]
----
MATCH
  (a),
  (b)
WHERE
  exists(a.name)
  AND NOT exists(b.name)
OPTIONAL MATCH (c:DoesNotExist)
RETURN
  a.name AS a_name,
  b.name AS b_name,
  exists(b.name) AS b_has_name,
  c.name AS c_name,
  exists(c.name) AS c_has_name
ORDER BY a_name, b_name, c_name
LIMIT 1
----

Three nodes are returned: one with a property `name`, one without a property `name`, and one that does not exist (e.g., is `null`).
This query exemplifies the behavior of `exists()` when operating on `null` nodes.

.Result
[role="queryresult",options="header,footer",cols="5*<m"]
|===
| +a_name+ | +b_name+ | +b_has_name+ | +c_name+ | +c_has_name+
| +"Alice"+ | +<null>+ | +false+ | +<null>+ | +<null>+
5+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (frank {alias: 'Frank', age: 61, eyes: 'brown', liked_colors: ['blue', 'green']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH
  (a),
  (b)
WHERE
  exists(a.name)
  AND NOT exists(b.name)
OPTIONAL MATCH (c:DoesNotExist)
RETURN
  a.name AS a_name,
  b.name AS b_name,
  exists(b.name) AS b_has_name,
  c.name AS c_name,
  exists(c.name) AS c_has_name
ORDER BY a_name, b_name, c_name
LIMIT 1
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-none]]
== none()

The function `none()` returns `true` if the predicate does _not_ hold for any element in the given list.
`null` is returned if the list is `null` or all of its elements are `null`.

*Syntax:* `none(variable IN list WHERE predicate)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
A single element cannot be explicitly passed as a literal in the cypher statement.
However, an implicit conversion will happen for single elements when passing node properties during cypher execution.
| `variable` | A variable that can be used from within the predicate.
| `predicate` | A predicate that is tested against all items in the list.
|===


.Query
[source, cypher]
----
MATCH p = (n)-[*1..3]->(b)
WHERE
  n.name = 'Alice'
  AND none(x IN nodes(p) WHERE x.age = 25)
RETURN p
----

No node in the returned paths has a property `age` with the value `25`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(0)-[KNOWS,1]->(2)+
| +(0)-[KNOWS,1]->(2)-[KNOWS,3]->(3)+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (frank {alias: 'Frank', age: 61, eyes: 'brown', liked_colors: ['blue', 'green']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (n)-[*1..3]->(b)
WHERE
  n.name = 'Alice'
  AND none(x IN nodes(p) WHERE x.age = 25)
RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-single]]
== single()

The function `single()` returns `true` if the predicate holds for exactly _one_ of the elements in the given list.
`null` is returned if the list is `null` or all of its elements are `null`.

*Syntax:* `single(variable IN list WHERE predicate)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
| `variable` | A variable that can be used from within the predicate.
| `predicate` | A predicate that is tested against all items in the list.
|===


.Query
[source, cypher]
----
MATCH p = (n)-->(b)
WHERE
  n.name = 'Alice'
  AND single(var IN nodes(p) WHERE var.eyes = 'blue')
RETURN p
----

In every returned path there is exactly one node that has a property `eyes` with the value `'blue'`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(0)-[KNOWS,0]->(1)+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (frank {alias: 'Frank', age: 61, eyes: 'brown', liked_colors: ['blue', 'green']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (n)-->(b)
WHERE
  n.name = 'Alice'
  AND single(var IN nodes(p) WHERE var.eyes = 'blue')
RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

