[[query-functions-mathematical-numeric]]
= Mathematical functions - numeric
:description: These functions all operate on numeric expressions only, and will return an error if used on any other values. See also xref:syntax/operators.adoc#query-operators-mathematical[Mathematical operators]. 

Functions:

* xref:functions/mathematical-numeric.adoc#functions-abs[abs()]
* xref:functions/mathematical-numeric.adoc#functions-ceil[ceil()]
* xref:functions/mathematical-numeric.adoc#functions-floor[floor()]
* xref:functions/mathematical-numeric.adoc#functions-rand[rand()]
* xref:functions/mathematical-numeric.adoc#functions-round[round()]
* xref:functions/mathematical-numeric.adoc#functions-sign[sign()]
      

The following graph is used for the examples below:

.Graph
["dot", "Mathematical functions - numeric-1.svg", "neoviz", ""]
----
  N0 [
    label = "{A|name = \'Alice\'\leyes = \'brown\'\lage = 38\l}"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "{B|name = \'Bob\'\leyes = \'blue\'\lage = 25\l}"
  ]
  N1 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 -> N4 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "MARRIED\n"
  ]
  N2 [
    label = "{C|name = \'Charlie\'\leyes = \'green\'\lage = 53\l}"
  ]
  N2 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "{D|name = \'Daniel\'\leyes = \'brown\'\lage = 54\l}"
  ]
  N4 [
    label = "{E|array = \[\'one\', \'two\', \'three\'\]\lname = \'Eskil\'\leyes = \'blue\'\lage = 41\l}"
  ]

----
 

[[functions-abs]]
== abs()

`abs()` returns the absolute value of the given number.

*Syntax:* `abs(expression)`

*Returns:*
|===
|
The type of the value returned will be that of `expression`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
|===


*Considerations:*
|===
|`abs(null)` returns `null`.
|If `expression` is negative, `-(expression)` (i.e. the _negation_ of `expression`) is returned.
|===


.Query
[source, cypher]
----
MATCH (a), (e) WHERE a.name = 'Alice' AND e.name = 'Eskil' RETURN a.age, e.age, abs(a.age - e.age)
----

The absolute value of the age difference is returned.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +a.age+ | +e.age+ | +abs(a.age - e.age)+
| +38+ | +41+ | +3+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
       (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel:D {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a), (e) WHERE a.name = 'Alice' AND e.name = 'Eskil' RETURN a.age, e.age, abs(a.age - e.age)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-ceil]]
== ceil()

`ceil()` returns the smallest floating point number that is greater than or equal to the given number and equal to a mathematical integer.

*Syntax:* `ceil(expression)`

*Returns:*
|===
|
A Float.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
|===


*Considerations:*
|===
|`ceil(null)` returns `null`.
|===


.Query
[source, cypher]
----
RETURN ceil(0.1)
----

The ceil of `0.1` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +ceil(0.1)+
| +1.0+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
       (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel:D {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN ceil(0.1)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-floor]]
== floor()

`floor()` returns the largest floating point number that is less than or equal to the given number and equal to a mathematical integer.

*Syntax:* `floor(expression)`

*Returns:*
|===
|
A Float.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
|===


*Considerations:*
|===
|`floor(null)` returns `null`.
|===


.Query
[source, cypher]
----
RETURN floor(0.9)
----

The floor of `0.9` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +floor(0.9)+
| +0.0+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
       (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel:D {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN floor(0.9)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-rand]]
== rand()

`rand()` returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e. `[0,1)`. The numbers returned follow an approximate uniform distribution.

*Syntax:* `rand()`

*Returns:*
|===
|
A Float.
|===


.Query
[source, cypher]
----
RETURN rand()
----

A random number is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +rand()+
| +0.14033781345155882+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
       (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel:D {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN rand()
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-round]]
== round()

`round()` returns the value of the given number rounded to the nearest integer.

*Syntax:* `round(expression)`

*Returns:*
|===
|
A Float.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
|===


*Considerations:*
|===
|`round(null)` returns `null`.
|===


.Query
[source, cypher]
----
RETURN round(3.141592)
----

`3.0` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +round(3.141592)+
| +3.0+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
       (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel:D {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN round(3.141592)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-sign]]
== sign()

`sign()` returns the signum of the given number: `0` if the number is `0`, `-1` for any negative number, and `1` for any positive number.

*Syntax:* `sign(expression)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | A numeric expression.
|===


*Considerations:*
|===
|`sign(null)` returns `null`.
|===


.Query
[source, cypher]
----
RETURN sign(-17), sign(0.1)
----

The signs of `-17` and `0.1` are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +sign(-17)+ | +sign(0.1)+
| +-1+ | +1+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
       (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel:D {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN sign(-17), sign(0.1)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

