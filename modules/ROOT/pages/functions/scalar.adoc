[[query-functions-scalar]]
= Scalar functions
:description: Scalar functions return a single value. 

[IMPORTANT]
====
The `length()` and `size()` functions are quite similar, and so it is important to take note of the difference.
     Owing to backwards compatibility, `length()` currently works on four types: strings, paths, lists and pattern expressions.
     However, it is recommended to use `length()` only for paths, and the `size()` function for strings, lists and pattern expressions.
     `length()` on those types may be deprecated in future.


====

[NOTE]
====
The `timestamp()` function returns the equivalent value of `datetime().epochMillis`.


====

[NOTE]
====
The function `toInt()` has been superseded by `toInteger()`, and will be removed in a future release.


====

Functions:

* xref:functions/scalar.adoc#functions-coalesce[coalesce()]
* xref:functions/scalar.adoc#functions-endnode[endNode()]
* xref:functions/scalar.adoc#functions-head[head()]
* xref:functions/scalar.adoc#functions-id[id()]
* xref:functions/scalar.adoc#functions-last[last()]
* xref:functions/scalar.adoc#functions-length[length()]
* xref:functions/scalar.adoc#functions-properties[properties()]
* xref:functions/scalar.adoc#functions-randomuuid[randomUUID()]
* xref:functions/scalar.adoc#functions-size[size()]
* xref:functions/scalar.adoc#functions-size-of-pattern-expression[Size of pattern expression]
* xref:functions/scalar.adoc#functions-size-of-string[Size of string]
* xref:functions/scalar.adoc#functions-startnode[startNode()]
* xref:functions/scalar.adoc#functions-timestamp[timestamp()]
* xref:functions/scalar.adoc#functions-toboolean[toBoolean()]
* xref:functions/scalar.adoc#functions-tofloat[toFloat()]
* xref:functions/scalar.adoc#functions-tointeger[toInteger()]
* xref:functions/scalar.adoc#functions-type[type()]

.Graph
["dot", "Scalar functions-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Developer|name = \'Alice\'\leyes = \'brown\'\lage = 38\l}"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "name = \'Bob\'\leyes = \'blue\'\lage = 25\l"
  ]
  N1 -> N4 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "MARRIED\n"
  ]
  N1 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N2 [
    label = "name = \'Charlie\'\leyes = \'green\'\lage = 53\l"
  ]
  N2 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "name = \'Daniel\'\leyes = \'brown\'\lage = 54\l"
  ]
  N4 [
    label = "array = \[\'one\', \'two\', \'three\'\]\lname = \'Eskil\'\leyes = \'blue\'\lage = 41\l"
  ]

----
 

[[functions-coalesce]]
== coalesce()

`coalesce()` returns the first non-`null` value in the given list of expressions.

*Syntax:* `coalesce(expression [, expression]*)`

*Returns:*
|===
|
The type of the value returned will be that of the first non-`null` expression.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression which may return `null`.
|===


*Considerations:*
|===
|`null` will be returned if all the arguments are `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Alice'
RETURN coalesce(a.hairColor, a.eyes)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +coalesce(a.hairColor, a.eyes)+
| +"brown"+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Alice'
RETURN coalesce(a.hairColor, a.eyes)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-endnode]]
== endNode()

`endNode()` returns the end node of a relationship.

*Syntax:* `endNode(relationship)`

*Returns:*
|===
|
A Node.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `relationship` | An expression that returns a relationship.
|===


*Considerations:*
|===
|`endNode(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (x:Developer)-[r]-()
RETURN endNode(r)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +endNode(r)+
| +Node[2]{name:"Charlie",eyes:"green",age:53}+
| +Node[1]{name:"Bob",eyes:"blue",age:25}+
1+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (x:Developer)-[r]-()
RETURN endNode(r)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-head]]
== head()

`head()` returns the first element in a list.

*Syntax:* `head(list)`

*Returns:*
|===
|
The type of the value returned will be that of the first element of `list`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
|===


*Considerations:*
|===
|`head(null)` returns `null`.
|If the first element in `list` is `null`, `head(list)` will return `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.array, head(a.array)
----

The first element in the list is returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.array+ | +head(a.array)+
| +["one","two","three"]+ | +"one"+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.array, head(a.array)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-id]]
== id()

The function `id()` returns a node or a relationship identifier, unique by an object type and a database.
Therefore, it is perfectly allowable for `id()` to return the same value for both nodes and relationships in the same database.
For examples on how to get a node and a relationship by ID, see xref:clauses/match.adoc#get-node-rel-by-id[Get node or relationship by id].

[NOTE]
====
Neo4j implements the id so that:

Node::
Every node in a database has an identifier.
The identifier for a node is guaranteed to be unique among other nodes' identifiers in the same database, within the scope of a single transaction.

Relationship::
Every relationship in a database has an identifier.
The identifier for a relationship is guaranteed to be unique among other relationships' identifiers in the same database, within the scope of a single transaction.


====

*Syntax:* `id(expression)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a node or a relationship.
|===


*Considerations:*
|===
|`id(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
RETURN id(a)
----

The node identifier for each of the nodes is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +id(a)+
| +0+
| +1+
| +2+
| +3+
| +4+
1+d|5 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
RETURN id(a)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-last]]
== last()

`last()` returns the last element in a list.

*Syntax:* `last(expression)`

*Returns:*
|===
|
The type of the value returned will be that of the last element of `list`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
|===


*Considerations:*
|===
|`last(null)` returns `null`.
|If the last element in `list` is `null`, `last(list)` will return `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.array, last(a.array)
----

The last element in the list is returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.array+ | +last(a.array)+
| +["one","two","three"]+ | +"three"+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.array, last(a.array)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-length]]
== length()

`length()` returns the length of a path.

*Syntax:* `length(path)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `path` | An expression that returns a path.
|===


*Considerations:*
|===
|`length(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH p =(a)-->(b)-->(c)
WHERE a.name = 'Alice'
RETURN length(p)
----

The length of the path `p` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +length(p)+
| +2+
| +2+
| +2+
1+d|3 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (a)-->(b)-->(c)
WHERE a.name = 'Alice'
RETURN length(p)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-properties]]
== properties()

`properties()` returns a map containing all the properties of a node or relationship.
If the argument is already a map, it is returned unchanged.

*Syntax:* `properties(expression)`

*Returns:*
|===
|
A Map.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a node, a relationship, or a map.
|===


*Considerations:*
|===
|`properties(null)` returns `null`.
|===


.Query
[source, cypher]
----
CREATE (p:Person { name: 'Stefan', city: 'Berlin' })
RETURN properties(p)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +properties(p)+
| +{city -> "Berlin", name -> "Stefan"}+
1+d|1 row +
Nodes created: 1 +
Properties set: 2 +
Labels added: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
CREATE (p:Person {name: 'Stefan', city: 'Berlin'})
RETURN properties(p)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-randomuuid]]
== randomUUID()

`randomUUID()` returns a randomly-generated Universally Unique Identifier (UUID), also known as a Globally Unique Identifier (GUID).
This is a 128-bit value with strong guarantees of uniqueness.
        

*Syntax:* `randomUUID()`

*Returns:*
|===
|
A String.
|===


.Query
[source, cypher]
----
RETURN randomUUID() AS uuid
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +uuid+
| +"401ee4f1-6eb3-45f9-9cd9-c2a2f3a2a7f8"+
1+d|1 row
|===

A randomly-generated UUID is returned.

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN randomUUID() AS uuid
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-size]]
== size()

`size()` returns the number of elements in a list.

*Syntax:* `size(list)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
|===


*Considerations:*
|===
|`size(null)` returns `null`.
|===


.Query
[source, cypher]
----
RETURN size(['Alice', 'Bob'])
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +size(['Alice', 'Bob'])+
| +2+
1+d|1 row
|===

The number of elements in the list is returned.

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN size(['Alice', 'Bob'])
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-size-of-pattern-expression]]
== size() applied to pattern expression

This is the same `size()` method as described above, but instead of passing in a list directly, a pattern expression can be provided that can be used in a match query to provide a new set of results.
These results are a _list_ of paths.
The size of the result is calculated, not the length of the expression itself.

*Syntax:* `size(pattern expression)`


*Arguments:*
[options="header"]
|===
| Name | Description
| `pattern expression` | A pattern expression that returns a list.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Alice'
RETURN size((a)-->()-->()) AS fof
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +fof+
| +3+
1+d|1 row
|===

The number of paths matching the pattern expression is returned.

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Alice'
RETURN size((a)-->()-->()) AS fof
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-size-of-string]]
== size() applied to string

`size()` returns the number of Unicode characters in a string.

*Syntax:* `size(string)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `string` | An expression that returns a string value.
|===


*Considerations:*
|===
|`size(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE size(a.name)> 6
RETURN size(a.name)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +size(a.name)+
| +7+
1+d|1 row
|===

The number of characters in the string *'Charlie'* is returned.

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE size(a.name) > 6
RETURN size(a.name)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-startnode]]
== startNode()

`startNode()` returns the start node of a relationship.

*Syntax:* `startNode(relationship)`

*Returns:*
|===
|
A Node.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `relationship` | An expression that returns a relationship.
|===


*Considerations:*
|===
|`startNode(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (x:Developer)-[r]-()
RETURN startNode(r)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +startNode(r)+
| +Node[0]{name:"Alice",eyes:"brown",age:38}+
| +Node[0]{name:"Alice",eyes:"brown",age:38}+
1+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (x:Developer)-[r]-()
RETURN startNode(r)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-timestamp]]
== timestamp()

`timestamp()` returns the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC.

*Syntax:* `timestamp()`

*Returns:*
|===
|
An Integer.
|===


*Considerations:*
|===
|`timestamp()` will return the same value during one entire query, even for long-running queries.
|===


.Query
[source, cypher]
----
RETURN timestamp()
----

The time in milliseconds is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +timestamp()+
| +1632753553112+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN timestamp()
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-toboolean]]
== toBoolean()

`toBoolean()` converts a string value to a boolean value.

*Syntax:* `toBoolean(expression)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a boolean or string value.
|===


*Considerations:*
|===
|`toBoolean(null)` returns `null`.
|If `expression` is a boolean value, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|===


.Query
[source, cypher]
----
RETURN toBoolean('TRUE'), toBoolean('not a boolean')
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +toBoolean('TRUE')+ | +toBoolean('not a boolean')+
| +true+ | +<null>+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toBoolean('TRUE'), toBoolean('not a boolean')
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-tofloat]]
== toFloat()

`toFloat()` converts an integer or string value to a floating point number.

*Syntax:* `toFloat(expression)`

*Returns:*
|===
|
A Float.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a numeric or string value.
|===


*Considerations:*
|===
|`toFloat(null)` returns `null`.
|If `expression` is a floating point number, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|===


.Query
[source, cypher]
----
RETURN toFloat('11.5'), toFloat('not a number')
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +toFloat('11.5')+ | +toFloat('not a number')+
| +11.5+ | +<null>+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toFloat('11.5'), toFloat('not a number')
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-tointeger]]
== toInteger()

`toInteger()` converts a floating point or string value to an integer value.

*Syntax:* `toInteger(expression)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a numeric or string value.
|===


*Considerations:*
|===
|`toInteger(null)` returns `null`.
|If `expression` is an integer value, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|===


.Query
[source, cypher]
----
RETURN toInteger('42'), toInteger('not a number')
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +toInteger('42')+ | +toInteger('not a number')+
| +42+ | +<null>+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toInteger('42'), toInteger('not a number')
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-type]]
== type()

`type()` returns the string representation of the relationship type.

*Syntax:* `type(relationship)`

*Returns:*
|===
|
A String.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `relationship` | An expression that returns a relationship.
|===


*Considerations:*
|===
|`type(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (n)-[r]->()
WHERE n.name = 'Alice'
RETURN type(r)
----

The relationship type of `r` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +type(r)+
| +"KNOWS"+
| +"KNOWS"+
1+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)-[r]->()
WHERE n.name = 'Alice'
RETURN type(r)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

