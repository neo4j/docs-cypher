[[query-functions-scalar]]
= Scalar functions
:description: Scalar functions return a single value. 

Functions:

* xref:functions/scalar.adoc#functions-coalesce[coalesce()]
* xref:functions/scalar.adoc#functions-endnode[endNode()]
* xref:functions/scalar.adoc#functions-head[head()]
* xref:functions/scalar.adoc#functions-id[id()]
* xref:functions/scalar.adoc#functions-last[last()]
* xref:functions/scalar.adoc#functions-length[length()]
* xref:functions/scalar.adoc#functions-properties[properties()]
* xref:functions/scalar.adoc#functions-randomuuid[randomUUID()]
* xref:functions/scalar.adoc#functions-size[size()]
* xref:functions/scalar.adoc#functions-size-of-pattern-expression[Size of pattern expression]
* xref:functions/scalar.adoc#functions-size-of-string[Size of string]
* xref:functions/scalar.adoc#functions-startnode[startNode()]
* xref:functions/scalar.adoc#functions-timestamp[timestamp()]
* xref:functions/scalar.adoc#functions-toboolean[toBoolean()]
* xref:functions/scalar.adoc#functions-tobooleanornull[toBooleanOrNull()]
* xref:functions/scalar.adoc#functions-tofloat[toFloat()]
* xref:functions/scalar.adoc#functions-tofloatornull[toFloatOrNull()]
* xref:functions/scalar.adoc#functions-tointeger[toInteger()]
* xref:functions/scalar.adoc#functions-tointegerornull[toIntegerOrNull()]
* xref:functions/scalar.adoc#functions-type[type()]

[IMPORTANT]
====
The `length()` and `size()` functions are quite similar, and so it is important to take note of the difference.

Function `length()`:: Only works for xref:functions/scalar.adoc#functions-length[paths].
Function `size()`:: Only works for the three types: xref:functions/scalar.adoc#functions-size-of-string[strings], xref:functions/scalar.adoc#functions-size[lists], and xref:functions/scalar.adoc#functions-size-of-pattern-expression[pattern expressions].


====

.Graph
["dot", "Scalar functions-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Developer|name = \'Alice\'\lage = 38\leyes = \'brown\'\l}"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "name = \'Bob\'\lage = 25\leyes = \'blue\'\l"
  ]
  N1 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 -> N4 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "MARRIED\n"
  ]
  N2 [
    label = "name = \'Charlie\'\lage = 53\leyes = \'green\'\l"
  ]
  N2 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "name = \'Daniel\'\lage = 54\leyes = \'brown\'\l"
  ]
  N4 [
    label = "eyes = \'blue\'\lliked_colors = \[\'pink\', \'yellow\', \'black\'\]\lname = \'Eskil\'\lage = 41\l"
  ]

----
 

[[functions-coalesce]]
== coalesce()

The function `coalesce()` returns the first non-`null` value in the given list of expressions.

*Syntax:* `coalesce(expression [, expression]*)`

*Returns:*
|===
|
The type of the value returned will be that of the first non-`null` expression.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that may return `null`.
|===


*Considerations:*
|===
|`null` will be returned if all the arguments are `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Alice'
RETURN coalesce(a.hairColor, a.eyes)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +coalesce(a.hairColor, a.eyes)+
| +"brown"+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Alice'
RETURN coalesce(a.hairColor, a.eyes)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-endnode]]
== endNode()

The function `endNode()` returns the end node of a relationship.

*Syntax:* `endNode(relationship)`

*Returns:*
|===
|
A Node.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `relationship` | An expression that returns a relationship.
|===


*Considerations:*
|===
|`endNode(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (x:Developer)-[r]-()
RETURN endNode(r)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +endNode(r)+
| +Node[2]{name:"Charlie",age:53,eyes:"green"}+
| +Node[1]{name:"Bob",age:25,eyes:"blue"}+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (x:Developer)-[r]-()
RETURN endNode(r)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-head]]
== head()

The function `head()` returns the first element in a list.

*Syntax:* `head(expression)`

*Returns:*
|===
|
The type of the value returned will be that of the first element of the list.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a list.
|===


*Considerations:*
|===
|`head(null)` returns `null`.
|`head([])` returns `null`.
|If the first element in `list` is `null`, `head(list)` will return `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.liked_colors, head(a.liked_colors)
----

The first element in the list is returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.liked_colors+ | +head(a.liked_colors)+
| +["pink","yellow","black"]+ | +"pink"+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.liked_colors, head(a.liked_colors)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-id]]
== id()

The function `id()` returns a node or a relationship identifier, unique by an object type and a database.
Therefore, it is perfectly allowable for `id()` to return the same value for both nodes and relationships in the same database.
For examples on how to get a node and a relationship by ID, see xref:clauses/match.adoc#get-node-rel-by-id[Get node or relationship by id].

[NOTE]
====
Neo4j implements the id so that:

Node::
Every node in a database has an identifier.
The identifier for a node is guaranteed to be unique among other nodes' identifiers in the same database, within the scope of a single transaction.

Relationship::
Every relationship in a database has an identifier.
The identifier for a relationship is guaranteed to be unique among other relationships' identifiers in the same database, within the scope of a single transaction.


====

*Syntax:* `id(expression)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a node or a relationship.
|===


*Considerations:*
|===
|`id(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
RETURN id(a)
----

The node identifier for each of the nodes is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +id(a)+
| +0+
| +1+
| +2+
| +3+
| +4+
1+d|Rows: 5
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
RETURN id(a)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-last]]
== last()

The function `last()` returns the last element in a list.

*Syntax:* `last(expression)`

*Returns:*
|===
|
The type of the value returned will be that of the last element of the list.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a list.
|===


*Considerations:*
|===
|`last(null)` returns `null`.
|`last([])` returns `null`.
|If the last element in `list` is `null`, `last(list)` will return `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.liked_colors, last(a.liked_colors)
----

The last element in the list is returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.liked_colors+ | +last(a.liked_colors)+
| +["pink","yellow","black"]+ | +"black"+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.liked_colors, last(a.liked_colors)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-length]]
== length()

The function `length()` returns the length of a path.

*Syntax:* `length(path)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `path` | An expression that returns a path.
|===


*Considerations:*
|===
|`length(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH p = (a)-->(b)-->(c)
WHERE a.name = 'Alice'
RETURN length(p)
----

The length of the path `p` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +length(p)+
| +2+
| +2+
| +2+
1+d|Rows: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (a)-->(b)-->(c)
WHERE a.name = 'Alice'
RETURN length(p)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-properties]]
== properties()

The function `properties()` returns a map containing all the properties; the function can be utilized for a relationship or a node.
If the argument is already a map, it is returned unchanged.

*Syntax:* `properties(expression)`

*Returns:*
|===
|
A Map.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a relationship, a node, or a map.
|===


*Considerations:*
|===
|`properties(null)` returns `null`.
|===


.Query
[source, cypher]
----
CREATE (p:Person {name: 'Stefan', city: 'Berlin'})
RETURN properties(p)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +properties(p)+
| +{city -> "Berlin", name -> "Stefan"}+
1+d|Rows: 1 +
Nodes created: 1 +
Properties set: 2 +
Labels added: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
CREATE (p:Person {name: 'Stefan', city: 'Berlin'})
RETURN properties(p)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-randomuuid]]
== randomUUID()

The function `randomUUID()` returns a randomly-generated Universally Unique Identifier (UUID), also known as a Globally Unique Identifier (GUID).
This is a 128-bit value with strong guarantees of uniqueness.

*Syntax:* `randomUUID()`

*Returns:*
|===
|
A String.
|===


.Query
[source, cypher]
----
RETURN randomUUID() AS uuid
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +uuid+
| +"9c45ba13-84e5-4e8c-bb9e-3cb612fa9c08"+
1+d|Rows: 1
|===

A randomly-generated UUID is returned.

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN randomUUID() AS uuid
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-size]]
== size()

The function `size()` returns the number of elements in a list.

*Syntax:* `size(list)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
|===


*Considerations:*
|===
|`size(null)` returns `null`.
|===


.Query
[source, cypher]
----
RETURN size(['Alice', 'Bob'])
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +size(['Alice', 'Bob'])+
| +2+
1+d|Rows: 1
|===

The number of elements in the list is returned.

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN size(['Alice', 'Bob'])
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-size-of-pattern-expression]]
== size() applied to pattern expression

This is the same function `size()` as described above, but you pass in a pattern expression, instead of a list.
The function size will then calculate on a _list_ of paths.

*Syntax:* `size(pattern expression)`


*Arguments:*
[options="header"]
|===
| Name | Description
| `pattern expression` | A pattern expression that returns a list.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Alice'
RETURN size((a)-->()-->()) AS fof
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +fof+
| +3+
1+d|Rows: 1
|===

The number of paths matching the pattern expression is returned. (The size of the list of paths).

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Alice'
RETURN size((a)-->()-->()) AS fof
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-size-of-string]]
== size() applied to string

The function `size()` returns the number of Unicode characters in a string.

*Syntax:* `size(string)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `string` | An expression that returns a string value.
|===


*Considerations:*
|===
|`size(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE size(a.name) > 6
RETURN size(a.name)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +size(a.name)+
| +7+
1+d|Rows: 1
|===

The number of characters in the string `'Charlie'` is returned.

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE size(a.name) > 6
RETURN size(a.name)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-startnode]]
== startNode()

The function `startNode()` returns the start node of a relationship.

*Syntax:* `startNode(relationship)`

*Returns:*
|===
|
A Node.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `relationship` | An expression that returns a relationship.
|===


*Considerations:*
|===
|`startNode(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (x:Developer)-[r]-()
RETURN startNode(r)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +startNode(r)+
| +Node[0]{name:"Alice",age:38,eyes:"brown"}+
| +Node[0]{name:"Alice",age:38,eyes:"brown"}+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (x:Developer)-[r]-()
RETURN startNode(r)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-timestamp]]
== timestamp()

The function `timestamp()` returns the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC.

[NOTE]
====
It is the equivalent of `datetime().epochMillis`.


====

*Syntax:* `timestamp()`

*Returns:*
|===
|
An Integer.
|===


*Considerations:*
|===
|`timestamp()` will return the same value during one entire query, even for long-running queries.
|===


.Query
[source, cypher]
----
RETURN timestamp()
----

The time in milliseconds is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +timestamp()+
| +1668159154237+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN timestamp()
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-toboolean]]
== toBoolean()

The function `toBoolean()` converts a string, integer or boolean value to a boolean value.

*Syntax:* `toBoolean(expression)`

*Returns:*
|===
|
A Boolean.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a boolean, string or integer value.
|===


*Considerations:*
|===
|`toBoolean(null)` returns `null`.
|If `expression` is a boolean value, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|If `expression` is the integer value `0`, `false` will be returned. For any other integer value `true` will be returned.
|This function will return an error if provided with an expression that is not a string, integer or boolean value.
|===


.Query
[source, cypher]
----
RETURN toBoolean('true'), toBoolean('not a boolean'), toBoolean(0)
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +toBoolean('true')+ | +toBoolean('not a boolean')+ | +toBoolean(0)+
| +true+ | +<null>+ | +false+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toBoolean('true'), toBoolean('not a boolean'), toBoolean(0)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-tobooleanornull]]
== toBooleanOrNull()

The function `toBooleanOrNull()` converts a string, integer or boolean value to a boolean value. For any other input value, `null` will be returned.

*Syntax:* `toBooleanOrNull(expression)`

*Returns:*
|===
|
A Boolean or `null`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | Any expression that returns a value.
|===


*Considerations:*
|===
|`toBooleanOrNull(null)` returns `null`.
|If `expression` is a boolean value, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|If `expression` is the integer value `0`, `false` will be returned. For any other integer value `true` will be returned.
|If the `expression` is not a string, integer or boolean value, `null` will be returned.
|===


.Query
[source, cypher]
----
RETURN toBooleanOrNull('true'), toBooleanOrNull('not a boolean'), toBooleanOrNull(0), toBooleanOrNull(1.5)
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===
| +toBooleanOrNull('true')+ | +toBooleanOrNull('not a boolean')+ | +toBooleanOrNull(0)+ | +toBooleanOrNull(1.5)+
| +true+ | +<null>+ | +false+ | +<null>+
4+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toBooleanOrNull('true'), toBooleanOrNull('not a boolean'), toBooleanOrNull(0), toBooleanOrNull(1.5)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-tofloat]]
== toFloat()

The function `toFloat()` converts an integer, floating point or a string value to a floating point number.

*Syntax:* `toFloat(expression)`

*Returns:*
|===
|
A Float.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a numeric or a string value.
|===


*Considerations:*
|===
|`toFloat(null)` returns `null`.
|If `expression` is a floating point number, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|This function will return an error if provided with an expression that is not an integer, floating point or a string value.
|===


.Query
[source, cypher]
----
RETURN toFloat('11.5'), toFloat('not a number')
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +toFloat('11.5')+ | +toFloat('not a number')+
| +11.5+ | +<null>+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toFloat('11.5'), toFloat('not a number')
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-tofloatornull]]
== toFloatOrNull()

The function `toFloatOrNull()` converts an integer, floating point or a string value to a floating point number. For any other input value, `null` will be returned.

*Syntax:* `toFloatOrNull(expression)`

*Returns:*
|===
|
A Float or `null`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | Any expression that returns a value.
|===


*Considerations:*
|===
|`toFloatOrNull(null)` returns `null`.
|If `expression` is a floating point number, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|If the `expression` is not an integer, floating point or a string value, `null` will be returned.
|===


.Query
[source, cypher]
----
RETURN toFloatOrNull('11.5'), toFloatOrNull('not a number'), toFloatOrNull(true)
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +toFloatOrNull('11.5')+ | +toFloatOrNull('not a number')+ | +toFloatOrNull(true)+
| +11.5+ | +<null>+ | +<null>+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toFloatOrNull('11.5'), toFloatOrNull('not a number'), toFloatOrNull(true)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-tointeger]]
== toInteger()

The function `toInteger()` converts a boolean, integer, floating point or a string value to an integer value.

*Syntax:* `toInteger(expression)`

*Returns:*
|===
|
An Integer.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a boolean, numeric or a string value.
|===


*Considerations:*
|===
|`toInteger(null)` returns `null`.
|If `expression` is an integer value, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|If `expression` is the boolean value `false`, `0` will be returned. If `expression` is the boolean value `true`, `1` will be returned.
|This function will return an error if provided with an expression that is not a boolean, floating point, integer or a string value.
|===


.Query
[source, cypher]
----
RETURN toInteger('42'), toInteger('not a number'), toInteger(true)
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +toInteger('42')+ | +toInteger('not a number')+ | +toInteger(true)+
| +42+ | +<null>+ | +1+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toInteger('42'), toInteger('not a number'), toInteger(true)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-tointegerornull]]
== toIntegerOrNull()

The function `toIntegerOrNull()` converts a boolean, integer, floating point or a string value to an integer value. For any other input value, `null` will be returned.

*Syntax:* `toIntegerOrNull(expression)`

*Returns:*
|===
|
An Integer or `null`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | Any expression that returns a value.
|===


*Considerations:*
|===
|`toIntegerOrNull(null)` returns `null`.
|If `expression` is an integer value, it will be returned unchanged.
|If the parsing fails, `null` will be returned.
|If `expression` is the boolean value `false`, `0` will be returned. If `expression` is the boolean value `true`, `1` will be returned.
|If the `expression` is not a boolean, floating point, integer or a string value, `null` will be returned.
|===


.Query
[source, cypher]
----
RETURN toIntegerOrNull('42'), toIntegerOrNull('not a number'), toIntegerOrNull(true), toIntegerOrNull(['A', 'B', 'C'])
----

.Result
[role="queryresult",options="header,footer",cols="4*<m"]
|===
| +toIntegerOrNull('42')+ | +toIntegerOrNull('not a number')+ | +toIntegerOrNull(true)+ | +toIntegerOrNull(['A', 'B', 'C'])+
| +42+ | +<null>+ | +1+ | +<null>+
4+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN toIntegerOrNull('42'), toIntegerOrNull('not a number'), toIntegerOrNull(true), toIntegerOrNull(['A', 'B', 'C'])
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-type]]
== type()

The function `type()` returns the string representation of the relationship type.

*Syntax:* `type(relationship)`

*Returns:*
|===
|
A String.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `relationship` | An expression that returns a relationship.
|===


*Considerations:*
|===
|`type(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (n)-[r]->()
WHERE n.name = 'Alice'
RETURN type(r)
----

The relationship type of `r` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +type(r)+
| +"KNOWS"+
| +"KNOWS"+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:Developer {name:'Alice', age: 38, eyes: 'brown'}),
  (bob {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
  (eskil {name: 'Eskil', age: 41, eyes: 'blue', liked_colors: ['pink', 'yellow', 'black']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)-[r]->()
WHERE n.name = 'Alice'
RETURN type(r)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

