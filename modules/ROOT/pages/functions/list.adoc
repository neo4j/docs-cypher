[[query-functions-list]]
= List functions
:description: List functions return lists of things -- nodes in a path, and so on. 

Further details and examples of lists may be found in xref:syntax/lists.adoc[Lists] and xref:syntax/operators.adoc#query-operators-list[List operators].

[NOTE]
====
The function `rels()` has been superseded by `relationships()`, and will be removed in a future release.

The functions `extract()` and `filter()` have been deprecated and will be removed in a future release. Consider using a xref:syntax/lists.adoc#cypher-list-comprehension[list comprehension] (e.g. `[x IN xs WHERE predicate | extraction]`) instead.


====

Functions:

* xref:functions/list.adoc#functions-extract[extract()]
* xref:functions/list.adoc#functions-filter[filter()]
* xref:functions/list.adoc#functions-keys[keys()]
* xref:functions/list.adoc#functions-labels[labels()]
* xref:functions/list.adoc#functions-nodes[nodes()]
* xref:functions/list.adoc#functions-range[range()]
* xref:functions/list.adoc#functions-reduce[reduce()]
* xref:functions/list.adoc#functions-relationships[relationships()]
* xref:functions/list.adoc#functions-reverse-list[reverse()]
* xref:functions/list.adoc#functions-tail[tail()]

.Graph
["dot", "List functions-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Person, Developer|name = \'Alice\'\leyes = \'brown\'\lage = 38\l}"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "name = \'Bob\'\leyes = \'blue\'\lage = 25\l"
  ]
  N1 -> N4 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "MARRIED\n"
  ]
  N1 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N2 [
    label = "name = \'Charlie\'\leyes = \'green\'\lage = 53\l"
  ]
  N2 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "name = \'Daniel\'\leyes = \'brown\'\lage = 54\l"
  ]
  N4 [
    label = "array = \[\'one\', \'two\', \'three\'\]\lname = \'Eskil\'\leyes = \'blue\'\lage = 41\l"
  ]

----
 

[role=deprecated]

[[functions-extract]]
== extract()

`extract()` returns a list `l~result~` containing the values resulting from an expression which has been applied to each element in a list `list`.
This function is analogous to the `map` method in functional languages such as Lisp and Scala. Note that this function has been deprecated, consider using a xref:syntax/lists.adoc#cypher-list-comprehension[list comprehension] (e.g. `[variable IN list | expression]`) instead.

*Syntax:* `extract(variable IN list | expression)`

*Returns:*
|===
|
A list containing heterogeneous elements; the types of the elements are determined by `expression`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
| `variable` | The closure will have a variable introduced in its context. We decide here which variable to use.
| `expression` | This expression will run once per value in `list`, and add it to the list which is returned by `extract()`.
|===


*Considerations:*
|===
|Any `null` values in `list` are preserved.
|===


Common usages of `extract()` include:

* Returning a property from a list of nodes or relationships; for example, `expression` = `n.prop` and `list` = `nodes(<some-path>)`.
* Returning the result of the application of a function on each element in a list; for example, `expression` = `toUpper(x)` and `variable` = `x`.


.Query
[source, cypher]
----
MATCH p =(a)-->(b)-->(c)
WHERE a.name = 'Alice' AND b.name = 'Bob' AND c.name = 'Daniel'
RETURN extract(n IN nodes(p)| n.age) AS extracted
----

The `age` property of all nodes in path `p` are returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +extracted+
| +[38,25,54]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (a)-->(b)-->(c)
WHERE a.name = 'Alice' AND b.name = 'Bob' AND c.name = 'Daniel'
RETURN extract(n IN nodes(p) | n.age) AS extracted
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[role=deprecated]

[[functions-filter]]
== filter()

`filter()` returns a list `l~result~` containing all the elements from a list `list` that comply with the given predicate. Note that this function has been deprecated, consider using a xref:syntax/lists.adoc#cypher-list-comprehension[list comprehension] (e.g. `[variable IN list WHERE predicate]`) instead.

*Syntax:* `filter(variable IN list WHERE predicate)`

*Returns:*
|===
|
A list containing heterogeneous elements; the types of the elements are determined by the elements in `list`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
| `variable` | This is the variable that can be used from the predicate.
| `predicate` | A predicate that is tested against all elements in `list`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.array, filter(x IN a.array WHERE size(x)= 3)
----

The property named `array` and a list of all values having size *'3'* are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.array+ | +filter(x IN a.array WHERE size(x)= 3)+
| +["one","two","three"]+ | +["one","two"]+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.array, filter(x IN a.array WHERE size(x)= 3)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-keys]]
== keys()

`keys` returns a list containing the string representations for all the property names of a node, relationship, or map.

*Syntax:* `keys(expression)`

*Returns:*
|===
|
A list containing String elements.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `expression` | An expression that returns a node, a relationship, or a map.
|===


*Considerations:*
|===
|`keys(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Alice'
RETURN keys(a)
----

A list containing the names of all the properties on the node bound to `a` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +keys(a)+
| +["name","eyes","age"]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a) WHERE a.name = 'Alice'
RETURN keys(a)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-labels]]
== labels()

`labels` returns a list containing the string representations for all the labels of a node.

*Syntax:* `labels(node)`

*Returns:*
|===
|
A list containing String elements.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `node` | An expression that returns a single node.
|===


*Considerations:*
|===
|`labels(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Alice'
RETURN labels(a)
----

A list containing all the labels of the node bound to `a` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +labels(a)+
| +["Person","Developer"]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a) WHERE a.name = 'Alice'
RETURN labels(a)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-nodes]]
== nodes()

`nodes()` returns a list containing all the nodes in a path.

*Syntax:* `nodes(path)`

*Returns:*
|===
|
A list containing Node elements.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `path` | An expression that returns a path.
|===


*Considerations:*
|===
|`nodes(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH p =(a)-->(b)-->(c)
WHERE a.name = 'Alice' AND c.name = 'Eskil'
RETURN nodes(p)
----

A list containing all the nodes in the path `p` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +nodes(p)+
| +[Node[0]{name:"Alice",eyes:"brown",age:38},Node[1]{name:"Bob",eyes:"blue",age:25},Node[4]{array:["one","two","three"],name:"Eskil",eyes:"blue",age:41}]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (a)-->(b)-->(c)
WHERE a.name = 'Alice' AND c.name = 'Eskil'
RETURN nodes(p)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-range]]
== range()

`range()` returns a list comprising all integer values within a range bounded by a start value `start` and end value `end`, where the difference `step` between any two consecutive values is constant; i.e. an arithmetic progression.
The range is inclusive, and the arithmetic progression will therefore always contain `start` and -- depending on the values of `start`, `step` and `end` -- `end`.

*Syntax:* `range(start, end [, step])`

*Returns:*
|===
|
A list of Integer elements.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `start` | An expression that returns an integer value.
| `end` | An expression that returns an integer value.
| `step` | A numeric expression defining the difference between any two consecutive values, with a default of `1`.
|===


.Query
[source, cypher]
----
RETURN range(0, 10), range(2, 18, 3)
----

Two lists of numbers in the given ranges are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +range(0, 10)+ | +range(2, 18, 3)+
| +[0,1,2,3,4,5,6,7,8,9,10]+ | +[2,5,8,11,14,17]+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
RETURN range(0, 10), range(2, 18, 3)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-reduce]]
== reduce()

`reduce()` returns the value resulting from the application of an expression on each successive element in a list in conjunction with the result of the computation thus far.
           This function will iterate through each element `e` in the given list, run the expression on `e` -- taking into account the current partial result -- and store the new partial result in the accumulator.
           This function is analogous to the `fold` or `reduce` method in functional languages such as Lisp and Scala.

*Syntax:* `reduce(accumulator = initial, variable IN list | expression)`

*Returns:*
|===
|
The type of the value returned depends on the arguments provided, along with the semantics of `expression`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `accumulator` | A variable that will hold the result and the partial results as the list is iterated.
| `initial` | An expression that runs once to give a starting value to the accumulator.
| `list` | An expression that returns a list.
| `variable` | The closure will have a variable introduced in its context. We decide here which variable to use.
| `expression` | This expression will run once per value in the list, and produce the result value.
|===


.Query
[source, cypher]
----
MATCH p =(a)-->(b)-->(c)
WHERE a.name = 'Alice' AND b.name = 'Bob' AND c.name = 'Daniel'
RETURN reduce(totalAge = 0, n IN nodes(p)| totalAge + n.age) AS reduction
----

The `age` property of all nodes in the path are summed and returned as a single value.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +reduction+
| +117+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (a)-->(b)-->(c)
WHERE a.name = 'Alice' AND b.name = 'Bob' AND c.name = 'Daniel'
RETURN reduce(totalAge = 0, n IN nodes(p) | totalAge + n.age) AS reduction
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-relationships]]
== relationships()

`relationships()` returns a list containing all the relationships in a path.

*Syntax:* `relationships(path)`

*Returns:*
|===
|
A list containing Relationship elements.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `path` | An expression that returns a path.
|===


*Considerations:*
|===
|`relationships(null)` returns `null`.
|===


.Query
[source, cypher]
----
MATCH p =(a)-->(b)-->(c)
WHERE a.name = 'Alice' AND c.name = 'Eskil'
RETURN relationships(p)
----

A list containing all the relationships in the path `p` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +relationships(p)+
| +[:KNOWS[0]{},:MARRIED[4]{}]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH p = (a)-->(b)-->(c)
WHERE a.name = 'Alice' AND c.name = 'Eskil'
RETURN relationships(p)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-reverse-list]]
== reverse()

`reverse()` returns a list in which the order of all elements in the original list have been reversed.

*Syntax:* `reverse(original)`

*Returns:*
|===
|
A list containing homogeneous or heterogeneous elements; the types of the elements are determined by the elements within `original`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `original` | An expression that returns a list.
|===


*Considerations:*
|===
|Any `null` element in `original` is preserved.
|===


.Query
[source, cypher]
----
WITH [4923,'abc',521, NULL , 487] AS ids
RETURN reverse(ids)
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +reverse(ids)+
| +[487,<null>,521,"abc",4923]+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
WITH [4923,'abc',521, null, 487] AS ids
RETURN reverse(ids)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[functions-tail]]
== tail()

`tail()` returns a list `l~result~` containing all the elements, excluding the first one, from a list `list`.

*Syntax:* `tail(list)`

*Returns:*
|===
|
A list containing heterogeneous elements; the types of the elements are determined by the elements in `list`.
|===


*Arguments:*
[options="header"]
|===
| Name | Description
| `list` | An expression that returns a list.
|===


.Query
[source, cypher]
----
MATCH (a)
WHERE a.name = 'Eskil'
RETURN a.array, tail(a.array)
----

The property named `array` and a list comprising all but the first element of the `array` property are returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.array+ | +tail(a.array)+
| +["one","two","three"]+ | +["two","three"]+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (alice:Person:Developer {name:'Alice', age: 38, eyes: 'brown'}),
       (bob {name: 'Bob', age: 25, eyes: 'blue'}),
       (charlie {name: 'Charlie', age: 53, eyes: 'green'}),
       (daniel {name: 'Daniel', age: 54, eyes: 'brown'}),
       (eskil {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),

       (alice)-[:KNOWS]->(bob),
       (alice)-[:KNOWS]->(charlie),
       (bob)-[:KNOWS]->(daniel),
       (charlie)-[:KNOWS]->(daniel),
       (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (a) WHERE a.name = 'Eskil'
RETURN a.array, tail(a.array)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

