:description: Information about finding the `SHORTEST` path patterns.
= Shortest paths

The Cypher keyword `SHORTEST` is used to find variations of the shortest paths between nodes.
This includes the ability to look for the shortest, second-shortest (and so on) paths, all available shortest paths, and groups of paths containing the same pattern length.
The `ANY` keyword, which can be used to test the reachability of nodes from a given node(s), is also explained, as is how to apply filters in queries using `SHORTEST`.

[NOTE]
`SHORTEST` functionally replaces and extends the `shortestPath()` and `allShortestPaths()` functions.
However, both functions can still be used.
For more information, see xref:patterns/reference.adoc#shortest-functions[Syntax and semantics -> The `shortestPath()` and `allShortestPaths()` functions].

[[shortest]]
== `SHORTEST k`

This section uses the following graph:

image::patterns_shortest_graph.svg[width="600", role="middle"]

To recreate it, run the following query against an empty Neo4j database:

[source,cypher, role=test-setup]
----
CREATE (asc:Station {name:"Ashchurch"}),
  (bmv:Station {name:"Bromsgrove"}),
  (cnm:Station {name:"Cheltenham Spa"}),
  (dtw:Station {name:"Droitwich Spa"}),
  (hby:Station {name:"Hartlebury"}),
  (psh:Station {name:"Pershore"}),
  (wop:Station {name:"Worcestershire Parkway Ll"}),
  (wof:Station {name:"Worcester Foregate Street"}),
  (wos:Station {name:"Worcester Shrub Hill"})
CREATE (asc)-[:LINK {distance: 7.25}]->(cnm),
  (asc)-[:LINK {distance: 11.29}]->(wop),
  (asc)-[:LINK {distance: 14.75}]->(wos),
  (bmv)-[:LINK {distance: 31.14}]->(cnm),
  (bmv)-[:LINK {distance: 6.16}]->(dtw),
  (bmv)-[:LINK {distance: 12.6}]->(wop),
  (dtw)-[:LINK {distance: 5.64}]->(hby),
  (dtw)-[:LINK {distance: 6.03}]->(wof),
  (dtw)-[:LINK {distance: 5.76}]->(wos),
  (psh)-[:LINK {distance: 4.16}]->(wop),
  (wop)-[:LINK {distance: 3.71}]->(wos),
  (wof)-[:LINK {distance: 0.65}]->(wos)
----

The paths matched by a xref:patterns/fixed-length-patterns.adoc#path-patterns[path pattern] can be restricted to only the shortest (by number of hops) by including the keyword `SHORTEST k`, where `k` is the number of paths to match.
For example, the following example uses `SHORTEST 1` to return the length of the shortest path between `Worcester Shrub Hill` and `Bromsgrove`:

.Query
[source, cypher]
----
MATCH p = SHORTEST 1 (wos:Station)-[:LINK]-+(bmv:Station)
WHERE wos.name = "Worcester Shrub Hill" AND bmv.name = "Bromsgrove"
RETURN length(p) AS result
----

[TIP]
Note that this and the following examples in this section use a quantified relationship `-[:LINK]-+`, which is composed of a relationship pattern `-[:LINK]-` and a postfix quantifier `+`. The relationship pattern is only concerned with following relationships with type `LINK`, and will otherwise traverse any node along the way. There is no arrowhead `<` or `>` on the relationship pattern, allowing the pattern to match relationships going in either direction. This represents the fact that trains can go in both directions along the `LINK` relationships between Stations. The `+` quantifier means that one or more relationships should be matched. For more information, see xref:patterns/reference.adoc#quantified-relationships[Syntax and semantics - quantified relationships].

.Result
[role="queryresult",options="header,footer",cols="m"]
|===
| result

| 2

1+d|Rows: 1

|===

Although the query returned a single result, there are in fact two paths that are tied for shortest:

image::patterns_shortest_tie.svg[width="500",role="middle"]

Because `1` was specified in `SHORTEST`, only one of the paths is returned.
Which one is returned is non-deterministic.

If instead `SHORTEST 2` is specified, all shortest paths in this example would be returned, and the result would be deterministic:

.Query
[source, cypher]
----
MATCH p = SHORTEST 2 (wos:Station)-[:LINK]-+(bmv:Station)
WHERE wos.name = "Worcester Shrub Hill" AND bmv.name = "Bromsgrove"
RETURN [n in nodes(p) | n.name] AS stops
----

.Result
[role="queryresult",options="header,footer",cols="m"]
|===
| stops

| ["Worcester Shrub Hill", "Droitwich Spa", "Bromsgrove"]
| ["Worcester Shrub Hill", "Worcestershire Parkway Ll", "Bromsgrove"]

1+d|Rows: 2

|===

Increasing the number of paths will return the next shortest paths.
Three paths are tied for the second shortest:

image::patterns_second_shortest_paths.svg[width="500",role="middle"]

The following query returns all three of the second shortest paths, along with the two shortest paths:

.Query
[source, cypher]
----
MATCH p = SHORTEST 5 (wos:Station)-[:LINK]-+(bmv:Station)
WHERE wos.name = "Worcester Shrub Hill" AND bmv.name = "Bromsgrove"
RETURN [n in nodes(p) | n.name] AS stops
----

.Result
[role="queryresult",options="header,footer",cols="m"]
|===

| stops

| ["Worcester Shrub Hill", "Droitwich Spa", "Bromsgrove"]
| ["Worcester Shrub Hill", "Worcestershire Parkway Ll", "Bromsgrove"]
| ["Worcester Shrub Hill", "Worcester Foregate Street", "Droitwich Spa", "Bromsgrove"]
| ["Worcester Shrub Hill", "Ashchurch", "Worcestershire Parkway Ll", "Bromsgrove"]
| ["Worcester Shrub Hill", "Ashchurch", "Cheltenham Spa", "Bromsgrove"]

1+d|Rows: 5
|===

If there had been only four possible paths between the two Stations, then only those four would have been returned.

[[all-shortest]]
== `ALL SHORTEST`

To return all paths that are tied for shortest length, use the keywords `ALL SHORTEST`:

.Query
[source,cypher]
----
MATCH p = ALL SHORTEST (wos)-[:LINK]-+(cnm)
WHERE hby.name = "Worcester Shrub Hill" AND cnm.name = "Bromsgrove"
RETURN [n in nodes(p) | n.name] AS stops
----

.Result
[role="queryresult",options="header,footer",cols="m"]
|===
| stops

| ["Worcester Shrub Hill", "Droitwich Spa", "Bromsgrove"]
| ["Worcester Shrub Hill", "Worcestershire Parkway Ll", "Bromsgrove"]

1+d|Rows: 2

|===


[[shortest-groups]]
== `SHORTEST k GROUPS`

To return all paths that are tied for first, second, and so on up to the kth shortest length, use `SHORTEST k GROUPS`.
For example, the following returns the first and second shortest length paths between  `Worcester Shrub Hill` and `Bromsgrove`:

.Query
[source,cypher]
----
MATCH p = SHORTEST 2 GROUPS (wos:Station)-[:LINK]-+(bmv:Station)
WHERE wos.name = "Worcester Shrub Hill" AND bmv.name = "Bromsgrove"
RETURN [n in nodes(p) | n.name] AS stops, length(p) AS pathLength
----

.Result
[role="queryresult",options="header,footer",cols="2m,m"]
|===
| stops | pathLength
| ["Worcester Shrub Hill", "Droitwich Spa", "Bromsgrove"] | 2
| ["Worcester Shrub Hill", "Worcestershire Parkway Ll", "Bromsgrove"] | 2
| ["Worcester Shrub Hill", "Worcester Foregate Street", "Droitwich Spa", "Bromsgrove"] | 3
| ["Worcester Shrub Hill", "Ashchurch", "Worcestershire Parkway Ll", "Bromsgrove"] | 3
| ["Worcester Shrub Hill", "Ashchurch", "Cheltenham Spa", "Bromsgrove"] | 3
2+d|Rows: 5
|===

The first group includes the two shortest paths with `pathLength = 2` (as seen in the first two rows of the results), and the second group includes the three second shortest paths with `pathLength = 3` (as seen in the last three rows of the results).

If more groups are specified than exist in the graph, only those paths that exist are returned.
For example, if the paths equal to one of the eight shortest paths are specified for `Worcester Shrub Hill` to `Bromsgrove`, only seven groups are returned:

.Query
[source,cypher]
----
MATCH p = SHORTEST 8 GROUPS (wos:Station)-[:LINK]-+(bmv:Station)
WHERE wos.name = "Worcester Shrub Hill" AND bmv.name = "Bromsgrove"
RETURN length(p) AS pathLength, count(*) AS numPaths
----

.Result
[role="queryresult",options="header,footer",cols="2*m"]
|===
| pathLength | numPaths

| 2 | 2
| 3 | 3
| 4 | 1
| 5 | 4
| 6 | 8
| 7 | 10
| 8 | 6

2+d|Rows: 7
|===

[[any]]
== `ANY`

The `ANY` keyword can be used to test the reachability of nodes from a given node(s).
It returns the same as `SHORTEST 1`, but by using the `ANY` keyword the intent of the query is clearer.
For example, the following query shows that there exists a route from `Pershore` to `Bromsgrove` where the distance between each pair of stations is less than 10 miles:

.Query
[source,cypher]
----
MATCH path = ANY
  (:Station {name: 'Pershore'})-[l:LINK WHERE l.distance < 10]-+(b:Station {name: 'Bromsgrove'})
RETURN [r IN relationships(path) | r.distance] AS distances
----

.Result
[role="queryresult",options="header,footer",cols="m"]
|===

| distances

| [4.16, 3.71, 5.76, 6.16]

1+d|Rows: 1
|===

[[partitions]]
== Partitions

When there are multiple start or end nodes matching a path pattern, the matches are partitioned into distinct pairs of start and end nodes prior to selecting the shortest paths; a partition is one distinct pair of start node and end node.
The selection of shortest paths is then done from all paths that join the start and end node of a given partition.
The results are then formed from the union of all the shortest paths found for each partition.

For example, if the start nodes of matches are bound to either `Droitwich Spa` or `Hartlebury`, and the end nodes are bound to either `Ashchurch` or `Cheltenham Spa`, there will be four distinct pairs of start and end nodes, and therefore four partitions:

[options="header",cols="a,a"]
|===
| *Start node* | *End node*

| `Droitwich Spa` | `Ashchurch`
| `Droitwich Spa` | `Cheltenham Spa`
| `Hartlebury` | `Ashchurch`
| `Hartlebury` | `Cheltenham Spa``

|===

The following query illustrates how these partitions define the sets of results within which the shortest paths are selected.
It uses a pair of xref:clauses/unwind.adoc[`UNWIND`] clauses to generate a Cartesian product of the names of the `Stations` (all possible pairs of start node and end node), followed by the `MATCH` clause to find the shortest two groups of paths for each pair of distinct start and end `Stations`:

.Query
[source,cypher]
----
UNWIND ["Droitwich Spa", "Hartlebury"] AS a
UNWIND ["Ashchurch", "Cheltenham Spa"] AS b
MATCH SHORTEST 2 GROUPS (o:Station {name: a})-[l]-+(d:Station {name: b})
RETURN o.name AS start, d.name AS end,
    size(l) AS pathLength, count(*) AS numPaths
ORDER BY start, end, pathLength
----

.Result
[role="queryresult",options="header,footer",cols="4*m"]
|===

| start | end | pathLength | numPaths

| "Droitwich Spa" | "Ashchurch" | 2 | 1
| "Droitwich Spa" | "Ashchurch" | 3 | 4
| "Droitwich Spa" | "Cheltenham Spa" | 2 | 1
| "Droitwich Spa" | "Cheltenham Spa" | 3 | 1
| "Hartlebury" | "Ashchurch" | 3 | 1
| "Hartlebury" | "Ashchurch" | 4 | 4
| "Hartlebury" | "Cheltenham Spa" | 3 | 1
| "Hartlebury" | "Cheltenham Spa" | 4 | 1

4+d|Rows: 8
|===

Each partition appears twice: once for the group of shortest paths and once for the group of second shortest paths.
For example, for the partition of `Droitwich Spa` as the `start` and `Ashchurch` as the `end`, the shortest path group (paths with length `2`) has one path, and the second shortest path group (paths with length `3`) has four paths.

[[filters]]
== Pre-filters and post-filters

The position of a filter in a shortest path query will affect whether it is applied before or after selecting the shortest paths.
To see the difference, first consider a query that returns the shortest path from `Hartlebury` to `Cheltenham Spa`:

.Query
[source,cypher]
----
MATCH SHORTEST 1
  (:Station {name: 'Hartlebury'}) 
  (()--(n))+ 
  (:Station {name: 'Cheltenham Spa'})
RETURN [stop in n[..-1] | stop.name] AS stops
----

.Result
[role="queryresult",options="header,footer",cols="m"]
|===
| stops

| ["Droitwich Spa", "Bromsgrove"]

1+d|Rows: 1
|===

Note that `n[..-1]` is a slicing operation that returns all elements of `n` except the last.
If instead, the query uses a `WHERE` clause at the `MATCH` level to filter out routes that go via Bromsgrove, the filtering is applied after the shortest paths are selected.
This results in the only solution being removed, and no results being returned:

.Query
[source,cypher]
----
MATCH SHORTEST 1 
  (:Station {name: 'Hartlebury'}) 
  (()--(n:Station))+ 
  (:Station {name: 'Cheltenham Spa'})
WHERE none(stop IN n[..-1] WHERE stop.name = 'Bromsgrove')
RETURN [stop in n[..-1] | stop.name] AS stops
----

.Result
[role="queryresult",options="header,footer",cols="m"]
|===
| stops

1+d|Rows: 0
|===

There are two ways to turn a post-filter without solutions into a pre-filter that returns solutions.
One is to inline the predicate into the path pattern:

.Query
[source,cypher]
----
MATCH SHORTEST 1
  (:Station {name: 'Hartlebury'}) 
  (()--(n:Station WHERE n.name <> 'Bromsgrove'))+
  (:Station {name: 'Cheltenham Spa'})
RETURN [stop in n[..-1] | stop.name] AS stops
----

.Result
[role="queryresult",options="header,footer",cols="m"]
|===
| stops

| ["Droitwich Spa", "Worcester Shrub Hill", "Ashchurch"]

1+d|Rows: 1
|===

The shortest journey that avoids `Bromsgrove` is now returned.

An alternative is to wrap the path pattern and filter in parentheses (leaving the `SHORTEST` keyword on the outside):

.Query
[source,cypher]
----
MATCH SHORTEST 1
  ( (:Station {name: 'Hartlebury'}) 
    (()--(n:Station))+ 
    (:Station {name: 'Cheltenham Spa'})
     WHERE none(stop IN n[..-1] WHERE stop.name = 'Bromsgrove') )
RETURN [stop in n[..-1] | stop.name] AS stops
----

.Result
[role="queryresult",options="header,footer",cols="m"]
|===
| stops

| ["Droitwich Spa", "Worcester Shrub Hill", "Ashchurch"]

1+d|Rows: 1
|===

[[pre-filter-path-variable]]
== Pre-filter with a path variable

The previous section showed how to apply a filter before the shortest path selection by the use of parentheses.
Placing a path variable declaration before the shortest path keywords, however, places it outside the scope of the parentheses.
To reference a path variable in a pre-filter, it has to be declared inside the parentheses.

To illustrate, consider this example that returns all shortest paths from `Hartlebury` to each of the other `Stations`:

.Query
[source,cypher]
----
MATCH p = SHORTEST 1 (:Station {name: 'Hartlebury'})--+(b:Station)
RETURN b.name AS destination, length(p) AS pathLength
ORDER BY pathLength, destination
----

.Result
[role="queryresult",options="header,footer",cols="2*m"]
|===
| destination | pathLength

| "Droitwich Spa" | 1
| "Bromsgrove" | 2
| "Worcester Foregate Street" | 2
| "Worcester Shrub Hill" | 2
| "Ashchurch" | 3
| "Cheltenham Spa" | 3
| "Worcestershire Parkway Ll" | 3
| "Pershore" | 4

2+d|Rows: 8

|===

If the query is altered to only include routes that have an even number of stops, adding a `WHERE` clause at the `MATCH` level will not work, because it would be a post-filter.
It would return the results of the previous query with all routes with an odd number of stops removed:

.Query
[source,cypher]
----
MATCH p = SHORTEST 1 (:Station {name: 'Hartlebury'})--+(b:Station)
WHERE length(p) % 2 = 0
RETURN b.name AS destination, length(p) AS pathLength
ORDER BY pathLength, destination
----

.Result
[role="queryresult",options="header,footer",cols="2*m"]
|===
| destination | pathLength

| "Bromsgrove" | 2
| "Worcester Foregate Street" | 2
| "Worcester Shrub Hill" | 2
| "Pershore" | 4

2+d|Rows: 4
|===

To move the predicate to a pre-filter, the path variable should be referenced from within the parentheses, and the shortest routes with an even number of stops will be returned for all the destinations:

.Query
[source,cypher]
----
MATCH SHORTEST 1
  (p = (:Station {name: 'Hartlebury'})--+(b:Station) 
    WHERE length(p) % 2 = 0 )
RETURN b.name AS destination, length(p) AS pathLength
ORDER BY pathLength, destination
----

.Result
[role="queryresult",options="header,footer",cols="2*m"]
|===
| destination | pathLength

| "Bromsgrove" | 2
| "Worcester Foregate Street" | 2
| "Worcester Shrub Hill" | 2
| "Ashchurch" | 4
| "Cheltenham Spa" | 4
| "Droitwich Spa" | 4
| "Pershore" | 4
| "Worcestershire Parkway Ll" | 4

2+d|Rows: 8
|===

[[shortest-path-graph-patterns]]
== Single shortest path per graph pattern

xref:patterns/non-linear-patterns.adoc#graph-patterns[Graph patterns] can contain more than one path pattern.
The exception is when one of those path patterns has a selective shortest path keyword (for more information, see xref:patterns/reference.adoc#shortest-paths-rules-selective[Syntax and semantics -> selective path selectors]), in which case it can be the only path pattern in the graph pattern.
Consider the following example of finding the shortest paths from `Droitwich Spa` to `Worcestershire Parkway` and from `Droitwich Spa` to `Cheltenham Spa` with a single `MATCH` statement:

.Invalid query
[source,cypher, role=test-fail]
----
MATCH (d:Station {name: 'Droitwich Spa'}),
      (w:Station {name: 'Worcestershire Parkway Ll'}),
      (c:Station {name: 'Cheltenham Spa'})
MATCH p = SHORTEST 1 (d)--+(w), q = SHORTEST 1 (d)--+(c)
RETURN [stop IN nodes(p) | stop.name] AS r1,
       [stop IN nodes(q) | stop.name] AS r2
----

*Note that this is not a valid query.*
*It is shown to illustrate a problem.*

There is one shortest path from `Droitwich Spa` to `Cheltenham Spa` that goes via `Bromsgrove`.
There are two shortest paths from `Droitwich Spa` to `Worcestershire Parkway Ll`, one via `Worcestershire Shrub Hill`, and the other via `Bromsgrove`.
As each path pattern is looking for a single shortest path, there are two possible solutions.
For the first of those solutions, the two paths follow different relationships:

image::patterns_shortest_graph_pattern1.svg[width="400", role="middle"]

For the second solution, however, both paths go via the link between `Droitwich Spa` and `Bromsgrove`:

image::patterns_shortest_graph_pattern2.svg[width="400", role="middle"]

The problem with this is that relationships are required to be unique within a given match to a graph pattern (for more information, see xref:patterns/reference.adoc#graph-patterns-rules-relationship-uniqueness[Syntax and semantics -> relationship uniqueness]).
So if this second pair of paths were selected, then the query would return no results, in contrast to the first pair of paths.
To avoid this non-determinism in the number of results, a rule is imposed whereby selective path patterns cannot be combined with any other path patterns in the same graph pattern.

If it makes sense for there to be relationships appearing more than once, the path patterns can solved by putting them in separate `MATCH` clauses:

.Valid query
[source,cypher]
----
MATCH (d:Station {name: 'Droitwich Spa'}),
      (w:Station {name: 'Worcestershire Parkway Ll'}),
      (c:Station {name: 'Cheltenham Spa'})
MATCH p = SHORTEST 1 (d)--+(w)
MATCH q = SHORTEST 1 (d)--+(c)
RETURN [stop IN nodes(p) | stop.name] AS r1,
       [stop IN nodes(q) | stop.name] AS r2
----

.Result
[role="queryresult",options="header,footer",cols="2*m"]
|===
| r1 | r2

| ["Droitwich Spa", "Bromsgrove", "Worcestershire Parkway Ll"]
| ["Droitwich Spa", "Bromsgrove", "Cheltenham Spa"]

2+d|Rows: 1
|===


[[planning-StatefulShortestPath-operator]]
== Planning the StatefulShortestPath-operator
The `StatefulShortestPath(All)` uses a unidirectional breadth first search algorithm, while the `StatefulShortestPath(Into)` uses a bidirectional breadth first search algorithm.
See xref:planning-and-tuning/operators/operators-detail.adoc#query-plan-stateful-shortest-path-into[the operator-detail page] for a description of the `StatefulShortestPath(All)` and `StatefulShortestPath(Into)` operators.

The planner decides between the two variants using this heuristic:

* When both boundary nodes have been matched in a `MATCH` clause prior to the `MATCH` clause containing the shortest paths query, `StatefulShortestPath(Into)` is planned.
* Otherwise, if both boundary nodes match to at most one data node, then `StatefulShortestPath(Into)` is planned.
* Otherwise, `StatefulShortestPath(All)` is planned.

Sometimes the planner cannot make reliable estimations about how many data nodes a pattern nodes will match.
Consider using a xref:constraints/index.adoc#unique-node-property[uniqueness constraint] where applicable to help the planner getting more reliable estimates.

As an example, consider the case where the left boundary node matches to 10 data nodes and the right boundary node to 3 data nodes.
Using `StatefulShortestPath(Into)` requires 30 bidirectional breath first search (BFS) invocations.
Using `StatefulShortestPath(All)` requires only 3 unidirectional BFS invocations expanding from the right boundary node.

This heuristic decision to favour `StatefulShortestPath(All)` can sometimes lead to worse query performance.
In case you want the `StatefulShortestPath(Into)` to be chosen, you can rewrite your query using a `CALL subquery`.

For example, this query
[source,cypher]
----
MATCH
  p = ALL SHORTEST (a:Station)(()-[]-()-[]-()){1,}(b:Station)
RETURN p
----

will use `StatefulShortestPath(All)`
[role="queryplan", subs="attributes+"]
----
+----------------------------+----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| Operator                   | Id | Details                                                                                 | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline      |
+----------------------------+----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +ProduceResults            |  0 | p                                                                                       |            383 |  154 |       0 |              0 |                    0/0 |     0.158 |               |
| |                          +----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+               |
| +Projection                |  1 | (a) ((anon_12)-[anon_14]-(anon_13)-[anon_11]-())* (b) AS p                              |            383 |  154 |       0 |                |                    0/0 |     2.785 |               |
| |                          +----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+               |
| +StatefulShortestPath(All) |  2 | SHORTEST 1 GROUPS (a) ((`anon_5`)-[`anon_6`]-(`anon_7`)-[`anon_8`]-(`anon_9`)){1, } (b) |            383 |  154 |     655 |          19711 |                    1/0 |    70.908 | In Pipeline 1 |
| |                          |    |         expanding from: a                                                               |                |      |         |                |                        |           |               |
| |                          |    |     inlined predicates: b:Station                                                       |                |      |         |                |                        |           |               |
| |                          +----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +NodeByLabelScan           |  3 | a:Station                                                                               |             10 |    9 |      10 |            376 |                    1/0 |     1.106 | In Pipeline 0 |
+----------------------------+----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
----




Rewriting the query using a `CALL` subquery
[source,cypher]
----
MATCH
  (a:Station),
  (b:Station)
CALL {
  WITH a, b
  MATCH
    p = ALL SHORTEST (a)(()-[]-()-[]-()){1,}(b)
  RETURN p
}
RETURN p
----

makes use of `StatefulShortestPath(Into)`, because the CALL subquery is executed for each incoming row. Each incoming row matches `a` to exactly one station node and `b` to exactly one station node.
[role="queryplan", subs="attributes+"]
----
+-----------------------------+----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| Operator                    | Id | Details                                                                                 | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Pipeline      |
+-----------------------------+----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +ProduceResults             |  0 | p                                                                                       |            383 |  154 |       0 |              0 |                    0/0 |     0.166 |               |
| |                           +----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+               |
| +Projection                 |  1 | (a) ((anon_12)-[anon_14]-(anon_13)-[anon_11]-())* (b) AS p                              |            383 |  154 |       0 |                |                    0/0 |     2.605 |               |
| |                           +----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+               |
| +StatefulShortestPath(Into) |  2 | SHORTEST 1 GROUPS (a) ((`anon_5`)-[`anon_6`]-(`anon_7`)-[`anon_8`]-(`anon_9`)){1, } (b) |            383 |  154 |    1517 |          24486 |                    1/0 |    76.973 | In Pipeline 3 |
| |                           |    |         expanding from: a                                                               |                |      |         |                |                        |           |               |
| |                           +----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +CartesianProduct           |  3 |                                                                                         |            100 |   81 |       0 |           2056 |                    0/0 |     1.352 | In Pipeline 2 |
| |\                          +----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| | +NodeByLabelScan          |  4 | b:Station                                                                               |             10 |    9 |      10 |            392 |                    1/0 |     0.229 | In Pipeline 1 |
| |                           +----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
| +NodeByLabelScan            |  5 | a:Station                                                                               |             10 |    9 |      10 |            376 |                    1/0 |     1.224 | In Pipeline 0 |
+-----------------------------+----+-----------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------+
----
