= Concepts

This is a step-by-step guide to the concepts behind graph pattern matching.
It starts with the simple building blocks of graph patterns: node patterns and relationship patterns.
It then shows how those are composed into path patterns that match fixed-length paths, variable-length paths and paths that have cycles in them.
//TODO: add QPP, group variables etc. when available. 

The model data in the examples below are based on the UK national rail network, using https://www.raildeliverygroup.com/our-services/rail-data/fares-timetable-data.html[publicly available datasets].

[[node-patterns]]
== Node patterns

Every graph pattern contains at least one node pattern. 
The simplest graph pattern is a single, empty node pattern:

[source, syntax, role=noheader]
----
MATCH ()
----

The empty node pattern matches every node in a property graph.
In order to obtain a reference to the nodes matched, a variable needs to be declared in the node pattern:

[source, syntax, role=noheader]
----
MATCH (n)
----

With this reference, node properties can be accessed:

[source, syntax, role=noheader]
----
MATCH (n)
RETURN n.name
----

Adding a label expression to the node pattern means only nodes with labels that match will be returned.
The following matches nodes that have the `Stop` label:

[source, syntax, role=noheader]
----
MATCH (n:Stop)
----

The following more complex label expression matches all nodes that are either a `TrainStation` and a `BusStation` or `StationGroup`:

[source, syntax, role=noheader]
----
MATCH (n:(TrainStation&BusStation)|StationGroup)
----

A map of property names and values can be used to match on node properties based on equality with the specified values.
The following matches nodes that have their `mode` property equal to `Rail`:

[source, syntax, role=noheader]
----
MATCH (n { mode: "Rail" }) 
----

More general predicates can be expressed with a `WHERE` clause.
The following matches nodes whose name property matches the regular expression `Preston.*`:

[source, syntax, role=noheader]
----
MATCH (n:Station WHERE n.name =~ "Preston.*")
----

See the xref:patterns/reference.adoc#node-pattern[node pattern] reference section for more details. 

[[rel-patterns]]
== Relationship patterns

The simplest possible relationship pattern is a pair of dashes:

[source, syntax, role=noheader]
----
--
----

This pattern matches a relationship with any direction and does not filter on any relationship type or property. 
Unlike a node pattern, a relationship pattern cannot be used in a `MATCH` clause without node patterns at both ends. 
See xref:patterns/concepts.adoc#path-patterns[] for more details.

In order to obtain a reference to the relationships matched by the pattern, a relationship variable needs to be declared in the pattern by adding the variable name in square brackets in between the dashes:

[source, syntax, role=noheader]
----
-[r]-
----

To match a specific direction, add `<` or `>` to the left or right hand side respectively:

[source, syntax, role=noheader]
----
-[r]->
----

To match on a relationship type, add the type name after a colon:

[source, syntax, role=noheader]
----
-[:CALLS_AT]->
----

Similar to node patterns, a map of property names and values can be added to filter on properties of the relationship based on equality with the specified values:

[source, syntax, role=noheader]
----
-[{ distance: 0.24, duration: "PT4M" }]->
----

A `WHERE` clause can be used for more general predicates:

[source, syntax, role=noheader]
----
-[r WHERE time() + duration(r.duration) < time("22:00") ]->
----

See the xref:patterns/reference.adoc#rel-pattern[relationship pattern] reference section for more details. 

[[path-patterns]]
== Path patterns

Any valid path starts and ends with a node, with relationships between each node (if there is more than one node).
Path patterns have the same restrictions, and for all valid path patterns the following are true:

* They have at least one node pattern.
* They begin and end with a node pattern.
* They alternate between nodes and relationships.

[options="header"cols="2a,1a"]
|===
| Valid path patterns | Invalid path patterns 

| `()` | `-->`
| `(s)--(e)` | `()-->`
| `(:Station)--()<--(m WHERE m.departs > time(12:00))-->()-[:NEXT]->(n)` | `()-->-->()`

|===

[[patterns-path-pattern-matching]]
== Path pattern matching 

This section contains an example of matching a path pattern to paths in a property graph.

The following code block is used for the example:

[source,cypher, role=test-setup]
----
CREATE (pmr:Station {name: 'Peckham Rye'}),
  (dmk:Station {name: 'Denmark Hill'}),
  (vic:Station {name: 'London Victoria'}),
  (clp:Station {name: 'Clapham High Street'}),
  (eph:Station {name: 'Elephant & Castle'}),
  (vic)<-[:CALLS_AT]-(s1:Stop {departs: time('11:55')}),
  (dmk)<-[:CALLS_AT]-(s2:Stop {departs: time('11:44')})-[:NEXT]->(s1),
  (pmr)<-[:CALLS_AT]-(s3:Stop {departs: time('11:40')})-[:NEXT]->(s2),
  (clp)<-[:CALLS_AT]-(s4:Stop {departs: time('11:41')}),
  (dmk)<-[:CALLS_AT]-(s5:Stop {departs: time('11:37')})-[:NEXT]->(s4),
  (pmr)<-[:CALLS_AT]-(s6:Stop {departs: time('11:33')})-[:NEXT]->(s5),
  (eph)<-[:CALLS_AT]-(s7:Stop {departs: time('11:54')}),
  (dmk)<-[:CALLS_AT]-(s8:Stop {departs: time('11:47')})-[:NEXT]->(s7),
  (pmr)<-[:CALLS_AT]-(s9:Stop {departs: time('11:44')})-[:NEXT]->(s8)
----

It creates the following graph:

image::path_pattern_example_graph.svg[width="600",role="middle"]

The graph contains a number of train `Stations` and `Stops`.
A `Stop` represents  the arrival and departure of a train that `CALLS_AT` a `Station`. 
Each `Stop` forms part of a sequence of `Stops` connected by the `NEXT` relationship type that represents the order of calling points made by a train service. 

The graph shows three chains of `Stops` that represent different train services. 
Each of these services calls at the `Station` with the name `Denmark Hill`.

To return all `Stops` that call at the `Station` `Denmark Hill`, the following _motif_ is used (the term motif is used to describe the pattern looked for in the graph):

image::path_pattern_motif.svg[width="600",role="middle"]

In this case, three path patterns in the graph match the structure of the motif (plus the predicate anchoring to the `Station` `Denmark Hill`).
The first 

image::path_pattern_solutions.svg[width="700",role="middle"]

In order to return the name of each `Stop` that calls at a `Station`, declare a variable in the `Stop` node pattern.
The results will then have a row containing the departs value of each `Stop` for each match shown above:

.Query
[source, cypher]
----
MATCH (s:Stop)-[:CALLS_AT]->(:Station {name: "Denmark Hill"})
RETURN s.departs AS departureTime
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +departureTime+

| +"11:44:00Z"+
| +"11:47:00Z"+
| +"11:37:00Z"+

1+d|Rows: 3
|===

[[patterns-shortestpath]]
== Finding the shortest path

The `shortestPath` algorithm can be used to find the shortest path between two nodes.
Using the same example graph, the following query matches the graph for the shortest path between the two `Stations` `Clapham High Street` and `Elephant & Castle`:

.Query
[source, cypher]
----
MATCH p=shortestPath(
    (clp:Station {name: 'Clapham High Street'})-[*]->(eph:Station {name: 'Elephant & Castle'})
    )
RETURN p
----

This is the returned graph:

image::patterns_shortestpath.svg[width="500",role="middle"]

[[patterns-equijoins]]
== Equijoins 

An equijoin is an operation on paths that requires more than one of the nodes or relationships of the paths to be the same.
The equality between the nodes or relationships is specified by declaring the same variable in multiple node patterns or relationship patterns.

We illustrate how equijoins work with the problem of finding a round trip between two train `Stations`.

For this example, a new code block is needed:

////
[source, cypher, role=test-setup]
----
MATCH (n)
DETACH DELETE (n)
----
Deletes the graph used in the previous example.
////

[source, cypher, role=test-setup]
----
CREATE (bhi:Station {name: "Birmingham Int'l"}),
  (cov:Station {name: 'Coventry'}),
  (eus:Station  {name: 'London Euston'}),
  (bhi)<-[:CALLS_AT]-(s1:Stop {departs: time('12:03')}),
  (cov)<-[:CALLS_AT]-(s2:Stop {departs: time('11:33')})-[:NEXT]->(s1),
  (eus)<-[:CALLS_AT]-(s3:Stop {departs: time('15:54')}),
  (cov)<-[:CALLS_AT]-(s4:Stop {departs: time('14:45')})-[:NEXT]->(s3),
  (cov)<-[:CALLS_AT]-(s5:Stop {departs: time('09:34')}),
  (eus)<-[:CALLS_AT]-(s6:Stop {departs: time('08:40')})-[:NEXT]->(s5)
----

It creates the following graph:

image::patterns_equijoins.svg[width="700",role="middle"]

In this example-scenario, a passenger starts their journey at `Euston` `Station` in London and ends at `Coventry` `Station`.
The return journey will be the reverse order of those `Stations`.

The graph has three different services, two of which would compose the desired round trip, and a third which would send the passenger to `Birmingham International`.

The desired path is a cycle.  
However, path patterns are linear by nature and do not allow for "drawing" cycles explicitly. 
To solve this, the first step is to consider a motif consisting of the correct sequence of nodes to describe the round trip:

image::patterns_equijoins_motif.svg[width="700",role="middle"]

The path pattern equivalent is:

[source, syntax, role=noheader]
----
(n:Station {name: "London Euston"})<-[:CALLS_AT]-(:Stop)-[:NEXT]->(:Stop)
  -[:CALLS_AT]->(:Station {name: "Coventry"})<-[:CALLS_AT]-(:Stop)
  -[:NEXT]->(:Stop)-[:CALLS_AT]->(:Station)
----

As the only predicate on the final node pattern is the label `Station` (represented by yellow color in the motif), the motif will match one solution too many:

image::patterns_equijoins_solution.svg[width="700",role="middle"]

One possibility for forcing the final node pattern to match on the origin `Station` `Euston` is to add a predicate matching on the `name` property of final node in the motif:

image::patterns_equijoins_motif2.svg[width="700",role="middle"]

If this is done, the path pattern equivalent is:

[source, syntax, role=noheader]
----
(n:Station {name: "London Euston"})<-[:CALLS_AT]-(:Stop)-[:NEXT]->(:Stop)
  -[:CALLS_AT]->(:Station {name: "Coventry"})<-[:CALLS_AT]-(:Stop)
  -[:NEXT]->(:Stop)-[:CALLS_AT]->(:Station {name: "London Euston"})
----

An alternative is to use an _equijoin_ to ensure that the first and last node patterns match the same node and the overall pattern matches return journeys. 
Specifically, if the same node variable `(n)` is declared in both the first and last node patterns, then the node patterns _must_ match the same node:

image::patterns_equijoins_motif3.svg[width="700",role="middle"]

Putting this path pattern with an equijoin in a query, it is possible to return the times of both the outbound and return journeys:

.Query
[source, cypher]
----
MATCH (n:Station {name: "London Euston"})<-[:CALLS_AT]-(s1:Stop)
  -[:NEXT]->(s2:Stop)-[:CALLS_AT]->(:Station {name: "Coventry"})
  <-[:CALLS_AT]-(s3:Stop)-[:NEXT]->(s4:Stop)-[:CALLS_AT]->(n)
RETURN s1.departs+"-"+s2.departs AS outboundJourney, 
  s3.departs+"-"+s4.departs AS returnJourney
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +outboundJourney+ | +returnJourney+

| +"08:40:00Z-09:34:00Z"+ | +"14:45:00Z-15:54:00Z"+

2+d|Rows: 1
|===

////
TODO: add documentation (when features are available) for:
* QPP
* Quantified Relationships
* Group variables
* Complex QPPs
* Graph patterns
////
