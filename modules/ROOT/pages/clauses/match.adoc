[[query-match]]
= MATCH
:description: The `MATCH` clause is used to search for the pattern described in it. 


* xref:clauses/match.adoc#match-introduction[Introduction]
* xref:clauses/match.adoc#basic-node-finding[Basic node finding]
 ** xref:clauses/match.adoc#get-all-nodes[Get all nodes]
 ** xref:clauses/match.adoc#get-all-nodes-with-label[Get all nodes with a label]
 ** xref:clauses/match.adoc#related-nodes[Related nodes]
 ** xref:clauses/match.adoc#match-with-labels[Match with labels]
* xref:clauses/match.adoc#relationship-basics[Relationship basics]
 ** xref:clauses/match.adoc#outgoing-relationships[Outgoing relationships]
 ** xref:clauses/match.adoc#directed-rels-and-variable[Directed relationships and variable]
 ** xref:clauses/match.adoc#match-on-rel-type[Match on relationship type]
 ** xref:clauses/match.adoc#match-on-multiple-rel-types[Match on multiple relationship types]
 ** xref:clauses/match.adoc#match-on-rel-type-use-variable[Match on relationship type and use a variable]
* xref:clauses/match.adoc#relationships-in-depth[Relationships in depth]
 ** xref:clauses/match.adoc#rel-types-with-uncommon-chars[Relationship types with uncommon characters]
 ** xref:clauses/match.adoc#multiple-rels[Multiple relationships]
 ** xref:clauses/match.adoc#varlength-rels[Variable length relationships]
 ** xref:clauses/match.adoc#rel-variable-in-varlength-rels[Relationship variable in variable length relationships]
 ** xref:clauses/match.adoc#match-props-on-varlength-path[Match with properties on a variable length path]
 ** xref:clauses/match.adoc#zero-length-paths[Zero length paths]
 ** xref:clauses/match.adoc#named-paths[Named paths]
 ** xref:clauses/match.adoc#match-on-bound-rel[Matching on a bound relationship]
* xref:clauses/match.adoc#query-shortest-path[Shortest path]
 ** xref:clauses/match.adoc#single-shortest-path[Single shortest path]
 ** xref:clauses/match.adoc#single-shortest-path-with-predicates[Single shortest path with predicates]
 ** xref:clauses/match.adoc#all-shortest-paths[All shortest paths]
* xref:clauses/match.adoc#get-node-rel-by-id[Get node or relationship by id]
 ** xref:clauses/match.adoc#match-node-by-id[Node by id]
 ** xref:clauses/match.adoc#match-rel-by-id[Relationship by id]
 ** xref:clauses/match.adoc#match-multiple-nodes-by-id[Multiple nodes by id]
      

[[match-introduction]]
== Introduction

The `MATCH` clause allows you to specify the patterns Neo4j will search for in the database.
This is the primary way of getting data into the current set of bindings.
It is worth reading up more on the specification of the patterns themselves in xref:syntax/patterns.adoc[Patterns].

`MATCH` is often coupled to a `WHERE` part which adds restrictions, or predicates, to the `MATCH` patterns, making them more specific.
The predicates are part of the pattern description, and should not be considered a filter applied only after the matching is done.
_This means that `WHERE` should always be put together with the `MATCH` clause it belongs to._

`MATCH` can occur at the beginning of the query or later, possibly after a `WITH`.
If it is the first clause, nothing will have been bound yet, and Neo4j will design a search to find the results matching the clause and any associated predicates specified in any `WHERE` part.
This could involve a scan of the database, a search for nodes having a certain label, or a search of an index to find starting points for the pattern matching.
Nodes and relationships found by this search are available as _bound pattern elements,_ and can be used for pattern matching of paths.
They can also be used in any further `MATCH` clauses, where Neo4j will use the known elements, and from there find further unknown elements.

Cypher is declarative, and so usually the query itself does not specify the algorithm to use to perform the search.
Neo4j will automatically work out the best approach to finding start nodes and matching patterns.
Predicates in `WHERE` parts can be evaluated before pattern matching, during pattern matching, or after finding matches.
However, there are cases where you can influence the decisions taken by the query compiler.
Read more about indexes in xref:schema/indexes.adoc[], and more about specifying hints to force Neo4j to solve a query in a specific way in xref:query-tuning/using.adoc[Planner hints and the USING keyword].

[TIP]
====
To understand more about the patterns used in the `MATCH` clause, read xref:syntax/patterns.adoc[Patterns]


====

The following graph is used for the examples below:

.Graph
["dot", "MATCH-3.svg", "neoviz", ""]
----
  N0 [
    label = "{Person|name = \'Charlie Sheen\'\l}"
  ]
  N0 -> N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'Bud Fox\'\l"
  ]
  N1 [
    label = "{Person|name = \'Martin Sheen\'\l}"
  ]
  N1 -> N6 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'A.J. MacInerney\'\l"
  ]
  N1 -> N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'Carl Fox\'\l"
  ]
  N2 [
    label = "{Person|name = \'Michael Douglas\'\l}"
  ]
  N2 -> N6 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'President Andrew Shepherd\'\l"
  ]
  N2 -> N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'Gordon Gekko\'\l"
  ]
  N3 [
    label = "{Person|name = \'Oliver Stone\'\l}"
  ]
  N3 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "DIRECTED\n"
  ]
  N4 [
    label = "{Person|name = \'Rob Reiner\'\l}"
  ]
  N4 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "DIRECTED\n"
  ]
  N5 [
    label = "{Movie|title = \'Wall Street\'\l}"
  ]
  N6 [
    label = "{Movie|title = \'The American President\'\l}"
  ]

----
 

[[basic-node-finding]]
== Basic node finding

[[get-all-nodes]]
=== Get all nodes

By just specifying a pattern with a single node and no labels, all nodes in the graph will be returned.


.Query
[source, cypher]
----
MATCH (n)
RETURN n
----

Returns all the nodes in the database.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n+
| +Node[0]{name:"Charlie Sheen"}+
| +Node[1]{name:"Martin Sheen"}+
| +Node[2]{name:"Michael Douglas"}+
| +Node[3]{name:"Oliver Stone"}+
| +Node[4]{name:"Rob Reiner"}+
| +Node[5]{title:"Wall Street"}+
| +Node[6]{title:"The American President"}+
1+d|7 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (n) RETURN n
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[get-all-nodes-with-label]]
=== Get all nodes with a label

Getting all nodes with a label on them is done with a single node pattern where the node has a label on it.


.Query
[source, cypher]
----
MATCH (movie:Movie)
RETURN movie.title
----

Returns all the movies in the database.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +movie.title+
| +"Wall Street"+
| +"The American President"+
1+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (movie:Movie) RETURN movie.title
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[related-nodes]]
=== Related nodes

The symbol `--` means _related to,_ without regard to type or direction of the relationship.


.Query
[source, cypher]
----
MATCH (director { name: 'Oliver Stone' })--(movie)
RETURN movie.title
----

Returns all the movies directed by *'Oliver Stone'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +movie.title+
| +"Wall Street"+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (director {name: 'Oliver Stone'})--(movie) RETURN movie.title
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-with-labels]]
=== Match with labels

To constrain your pattern with labels on nodes, you add it to your pattern nodes, using the label syntax.


.Query
[source, cypher]
----
MATCH (:Person { name: 'Oliver Stone' })--(movie:Movie)
RETURN movie.title
----

Returns any nodes connected with the `Person` *'Oliver'* that are labeled `Movie`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +movie.title+
| +"Wall Street"+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (:Person {name: 'Oliver Stone'})--(movie:Movie) RETURN movie.title
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[relationship-basics]]
== Relationship basics

[[outgoing-relationships]]
=== Outgoing relationships

When the direction of a relationship is of interest, it is shown by using `-->` or `<--`, like this:


.Query
[source, cypher]
----
MATCH (:Person { name: 'Oliver Stone' })-->(movie)
RETURN movie.title
----

Returns any nodes connected with the `Person` *'Oliver'* by an outgoing relationship.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +movie.title+
| +"Wall Street"+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (:Person {name: 'Oliver Stone'})-->(movie) RETURN movie.title
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[directed-rels-and-variable]]
=== Directed relationships and variable

If a variable is required, either for filtering on properties of the relationship, or to return the relationship, this is how you introduce the variable.


.Query
[source, cypher]
----
MATCH (:Person { name: 'Oliver Stone' })-[r]->(movie)
RETURN type(r)
----

Returns the type of each outgoing relationship from *'Oliver'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +type(r)+
| +"DIRECTED"+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (:Person {name: 'Oliver Stone'})-[r]->(movie) RETURN type(r)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-on-rel-type]]
=== Match on relationship type

When you know the relationship type you want to match on, you can specify it by using a colon together with the relationship type.


.Query
[source, cypher]
----
MATCH (wallstreet:Movie { title: 'Wall Street' })<-[:ACTED_IN]-(actor)
RETURN actor.name
----

Returns all actors that `ACTED_IN` *'Wall Street'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +actor.name+
| +"Michael Douglas"+
| +"Martin Sheen"+
| +"Charlie Sheen"+
1+d|3 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (wallstreet:Movie {title: 'Wall Street'})<-[:ACTED_IN]-(actor) RETURN actor.name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-on-multiple-rel-types]]
=== Match on multiple relationship types

To match on one of multiple types, you can specify this by chaining them together with the pipe symbol `|`.


.Query
[source, cypher]
----
MATCH (wallstreet { title: 'Wall Street' })<-[:ACTED_IN|:DIRECTED]-(person)
RETURN person.name
----

Returns nodes with an `ACTED_IN` or `DIRECTED` relationship to *'Wall Street'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +person.name+
| +"Oliver Stone"+
| +"Michael Douglas"+
| +"Martin Sheen"+
| +"Charlie Sheen"+
1+d|4 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (wallstreet {title: 'Wall Street'})<-[:ACTED_IN|:DIRECTED]-(person) RETURN person.name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-on-rel-type-use-variable]]
=== Match on relationship type and use a variable

If you both want to introduce an variable to hold the relationship, and specify the relationship type you want, just add them both, like this:


.Query
[source, cypher]
----
MATCH (wallstreet { title: 'Wall Street' })<-[r:ACTED_IN]-(actor)
RETURN r.role
----

Returns `ACTED_IN` roles for *'Wall Street'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +r.role+
| +"Gordon Gekko"+
| +"Carl Fox"+
| +"Bud Fox"+
1+d|3 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (wallstreet {title: 'Wall Street'})<-[r:ACTED_IN]-(actor) RETURN r.role
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[relationships-in-depth]]
== Relationships in depth

[NOTE]
====
Inside a single pattern, relationships will only be matched once. You can read more about this in xref:introduction/uniqueness.adoc[].


====

[[rel-types-with-uncommon-chars]]
=== Relationship types with uncommon characters

Sometimes your database will have types with non-letter characters, or with spaces in them.
 Use ``` (backtick) to quote these.
 To demonstrate this we can add an additional relationship between *'Charlie Sheen'* and *'Rob Reiner'*:


.Query
[source, cypher]
----
MATCH (charlie:Person { name: 'Charlie Sheen' }),(rob:Person { name: 'Rob Reiner' })
CREATE (rob)-[:`TYPE INCLUDING A SPACE`]->(charlie)
----

Which leads to the following graph: 

.Graph
["dot", "MATCH-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Person|name = \'Charlie Sheen\'\l}"
  ]
  N0 -> N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'Bud Fox\'\l"
  ]
  N1 [
    label = "{Person|name = \'Martin Sheen\'\l}"
  ]
  N1 -> N6 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'A.J. MacInerney\'\l"
  ]
  N1 -> N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'Carl Fox\'\l"
  ]
  N2 [
    label = "{Person|name = \'Michael Douglas\'\l}"
  ]
  N2 -> N6 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'President Andrew Shepherd\'\l"
  ]
  N2 -> N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "ACTED_IN\nrole = \'Gordon Gekko\'\l"
  ]
  N3 [
    label = "{Person|name = \'Oliver Stone\'\l}"
  ]
  N3 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "DIRECTED\n"
  ]
  N4 [
    label = "{Person|name = \'Rob Reiner\'\l}"
  ]
  N4 -> N0 [
    color = "#a40000"
    fontcolor = "#a40000"
    label = "TYPE INCLUDING A SPACE\n"
  ]
  N4 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "DIRECTED\n"
  ]
  N5 [
    label = "{Movie|title = \'Wall Street\'\l}"
  ]
  N6 [
    label = "{Movie|title = \'The American President\'\l}"
  ]

----
 

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (charlie:Person {name: 'Charlie Sheen'}), (rob:Person {name: 'Rob Reiner'})
CREATE (rob)-[:`TYPE INCLUDING A SPACE`]->(charlie)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


.Query
[source, cypher]
----
MATCH (n { name: 'Rob Reiner' })-[r:`TYPE INCLUDING A SPACE`]->()
RETURN type(r)
----

Returns a relationship type with spaces in it.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +type(r)+
| +"TYPE INCLUDING A SPACE"+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)
MATCH (charlie:Person {name: 'Charlie Sheen'}), (rob:Person {name: 'Rob Reiner'})
CREATE (rob)-[:`TYPE INCLUDING A SPACE`]->(charlie)
]]></database><command><![CDATA[
MATCH (n {name: 'Rob Reiner'})-[r:`TYPE INCLUDING A SPACE`]->() RETURN type(r)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[multiple-rels]]
=== Multiple relationships

Relationships can be expressed by using multiple statements in the form of `()--()`, or they can be strung together, like this:


.Query
[source, cypher]
----
MATCH (charlie { name: 'Charlie Sheen' })-[:ACTED_IN]->(movie)<-[:DIRECTED]-(director)
RETURN movie.title, director.name
----

Returns the movie *'Charlie Sheen'* acted in and its director.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +movie.title+ | +director.name+
| +"Wall Street"+ | +"Oliver Stone"+
2+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
match (charlie {name: 'Charlie Sheen'})-[:ACTED_IN]->(movie)<-[:DIRECTED]-(director) RETURN movie.title, director.name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[varlength-rels]]
=== Variable length relationships

Nodes that are a variable number of relationship->node hops away can be found using the following syntax:
 `-[:TYPE*minHops..maxHops]->`.
 `minHops` and `maxHops` are optional and default to 1 and infinity respectively.
 When no bounds are given the dots may be omitted.
 The dots may also be omitted when setting only one bound and this implies a fixed length pattern.


.Query
[source, cypher]
----
MATCH (martin { name: 'Charlie Sheen' })-[:ACTED_IN*1..3]-(movie:Movie)
RETURN movie.title
----

Returns all movies related to *'Charlie Sheen'* by 1 to 3 hops.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +movie.title+
| +"Wall Street"+
| +"The American President"+
| +"The American President"+
1+d|3 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
match (martin {name: 'Charlie Sheen'})-[:ACTED_IN*1..3]-(movie:Movie) return movie.title
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[rel-variable-in-varlength-rels]]
=== Relationship variable in variable length relationships

When the connection between two nodes is of variable length, the list of relationships comprising the connection can be returned using the following syntax:


.Query
[source, cypher]
----
MATCH p =(actor { name: 'Charlie Sheen' })-[:ACTED_IN*2]-(co_actor)
RETURN relationships(p)
----

Returns a list of relationships.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +relationships(p)+
| +[:ACTED_IN[0]{role:"Bud Fox"},:ACTED_IN[1]{role:"Carl Fox"}]+
| +[:ACTED_IN[0]{role:"Bud Fox"},:ACTED_IN[2]{role:"Gordon Gekko"}]+
1+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH p = (actor {name: 'Charlie Sheen'})-[:ACTED_IN*2]-(co_actor) RETURN relationships(p)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-props-on-varlength-path]]
=== Match with properties on a variable length path

A variable length relationship with properties defined on in it means that all
relationships in the path must have the property set to the given value. In this query,
there are two paths between *'Charlie Sheen'* and his father *'Martin Sheen'*. One of them includes a
*'blocked'* relationship and the other doesn't. In this case we first alter the original
graph by using the following query to add `BLOCKED` and `UNBLOCKED` relationships:


.Query
[source, cypher]
----
MATCH (charlie:Person { name: 'Charlie Sheen' }),(martin:Person { name: 'Martin Sheen' })
CREATE (charlie)-[:X { blocked: FALSE }]->(:UNBLOCKED)<-[:X { blocked: FALSE }]-(martin)
CREATE (charlie)-[:X { blocked: TRUE }]->(:BLOCKED)<-[:X { blocked: FALSE }]-(martin)
----

This means that we are starting out with the following graph: 

.Graph
["dot", "MATCH-2.svg", "neoviz", ""]
----
  N0 [
    label = "{Person|name = \'Charlie Sheen\'\l}"
  ]
  N0 -> N21 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "X\nblocked = true\l"
  ]
  N0 -> N20 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "X\nblocked = false\l"
  ]
  N0 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nrole = \'Bud Fox\'\l"
  ]
  N1 [
    label = "{Person|name = \'Martin Sheen\'\l}"
  ]
  N1 -> N21 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "X\nblocked = false\l"
  ]
  N1 -> N20 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "X\nblocked = false\l"
  ]
  N1 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nrole = \'A.J. MacInerney\'\l"
  ]
  N1 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nrole = \'Carl Fox\'\l"
  ]
  N2 [
    label = "{Person|name = \'Michael Douglas\'\l}"
  ]
  N2 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nrole = \'President Andrew Shepherd\'\l"
  ]
  N2 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\nrole = \'Gordon Gekko\'\l"
  ]
  N3 [
    label = "{Person|name = \'Oliver Stone\'\l}"
  ]
  N3 -> N5 [
    color = "#a40000"
    fontcolor = "#a40000"
    label = "DIRECTED\n"
  ]
  N4 [
    label = "{Person|name = \'Rob Reiner\'\l}"
  ]
  N4 -> N6 [
    color = "#a40000"
    fontcolor = "#a40000"
    label = "DIRECTED\n"
  ]
  N5 [
    label = "{Movie|title = \'Wall Street\'\l}"
  ]
  N6 [
    label = "{Movie|title = \'The American President\'\l}"
  ]
  N20 [
    label = "{UNBLOCKED|}"
  ]
  N21 [
    label = "{BLOCKED|}"
  ]

----
 

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (charlie:Person {name: 'Charlie Sheen'}), (martin:Person {name: 'Martin Sheen'})
CREATE (charlie)-[:X {blocked: false}]->(:UNBLOCKED)<-[:X {blocked: false}]-(martin)
CREATE (charlie)-[:X {blocked: true}]->(:BLOCKED)<-[:X {blocked: false}]-(martin)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


.Query
[source, cypher]
----
MATCH p =(charlie:Person)-[* { blocked:false }]-(martin:Person)
WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'
RETURN p
----

Returns the paths between *'Charlie Sheen'* and *'Martin Sheen'* where all relationships have the `blocked` property set to `false`.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(0)-[X,20]->(20)<-[X,21]-(1)+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)
MATCH (charlie:Person {name: 'Charlie Sheen'}), (martin:Person {name: 'Martin Sheen'})
CREATE (charlie)-[:X {blocked: false}]->(:UNBLOCKED)<-[:X {blocked: false}]-(martin)
CREATE (charlie)-[:X {blocked: true}]->(:BLOCKED)<-[:X {blocked: false}]-(martin)
]]></database><command><![CDATA[
MATCH p = (charlie:Person)-[* {blocked:false}]-(martin:Person)
 WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'
 RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[zero-length-paths]]
=== Zero length paths

Using variable length paths that have the lower bound zero means that two variables can point to the same node.
If the path length between two nodes is zero, they are by definition the same node.
Note that when matching zero length paths the result may contain a match even when matching on a relationship type not in use.


.Query
[source, cypher]
----
MATCH (wallstreet:Movie { title: 'Wall Street' })-[*0..1]-(x)
RETURN x
----

Returns the movie itself as well as actors and directors one relationship away

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +x+
| +Node[5]{title:"Wall Street"}+
| +Node[0]{name:"Charlie Sheen"}+
| +Node[1]{name:"Martin Sheen"}+
| +Node[2]{name:"Michael Douglas"}+
| +Node[3]{name:"Oliver Stone"}+
1+d|5 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (wallstreet:Movie {title: 'Wall Street'})-[*0..1]-(x) RETURN x
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[named-paths]]
=== Named paths

If you want to return or filter on a path in your pattern graph, you can a introduce a named path.


.Query
[source, cypher]
----
MATCH p =(michael { name: 'Michael Douglas' })-->()
RETURN p
----

Returns the two paths starting from *'Michael Douglas'*

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(2)-[ACTED_IN,5]->(6)+
| +(2)-[ACTED_IN,2]->(5)+
1+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH p = (michael {name: 'Michael Douglas'})-->() RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-on-bound-rel]]
=== Matching on a bound relationship

When your pattern contains a bound relationship, and that relationship pattern doesn’t
 specify direction, Cypher will try to match the relationship in both directions.


.Query
[source, cypher]
----
MATCH (a)-[r]-(b)
WHERE id(r)= 0
RETURN a,b
----

This returns the two connected nodes, once as the start node, and once as the end node

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a+ | +b+
| +Node[0]{name:"Charlie Sheen"}+ | +Node[5]{title:"Wall Street"}+
| +Node[5]{title:"Wall Street"}+ | +Node[0]{name:"Charlie Sheen"}+
2+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (a)-[r]-(b) WHERE id(r)= 0 RETURN a,b
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-shortest-path]]
== Shortest path

[[single-shortest-path]]
=== Single shortest path

Finding a single shortest path between two nodes is as easy as using the `shortestPath` function. It's done like this:


.Query
[source, cypher]
----
MATCH (martin:Person { name: 'Martin Sheen' }),(oliver:Person { name: 'Oliver Stone' }), p = shortestPath((martin)-[*..15]-(oliver))
RETURN p
----

This means: find a single shortest path between two nodes, as long as the path is max 15 relationships long.
Within the parentheses you define a single link of a path -- the starting node, the connecting relationship
and the end node. Characteristics describing the relationship like relationship type, max hops and direction
are all used when finding the shortest path. If there is a `WHERE` clause following the match of a
`shortestPath`, relevant predicates will be included in the `shortestPath`.
If the predicate is a `none()` or `all()` on the relationship elements of the path,
it will be used during the search to improve performance (see xref:execution-plans/shortestpath-planning.adoc[Shortest path planning]).

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(1)-[ACTED_IN,1]->(5)<-[DIRECTED,3]-(3)+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (martin:Person {name: 'Martin Sheen'}),
      (oliver:Person {name: 'Oliver Stone'}),
      p = shortestPath((martin)-[*..15]-(oliver))
RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[single-shortest-path-with-predicates]]
=== Single shortest path with predicates

Predicates used in the `WHERE` clause that apply to the shortest path pattern are evaluated before deciding
what the shortest matching path is.


.Query
[source, cypher]
----
MATCH (charlie:Person { name: 'Charlie Sheen' }),(martin:Person { name: 'Martin Sheen' }), p = shortestPath((charlie)-[*]-(martin))
WHERE NONE (r IN relationships(p) WHERE type(r)= 'FATHER')
RETURN p
----

This query will find the shortest path between *'Charlie Sheen'* and *'Martin Sheen'*, and the `WHERE` predicate
will ensure that we don't consider the father/son relationship between the two.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(0)-[ACTED_IN,0]->(5)<-[ACTED_IN,1]-(1)+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (charlie:Person {name: 'Charlie Sheen'}),
      (martin:Person {name: 'Martin Sheen'}),
      p = shortestPath( (charlie)-[*]-(martin) )
WHERE none(r in relationships(p) WHERE type(r) = 'FATHER')
RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[all-shortest-paths]]
=== All shortest paths

Finds all the shortest paths between two nodes.


.Query
[source, cypher]
----
MATCH (martin:Person { name: 'Martin Sheen' }),(michael:Person { name: 'Michael Douglas' }), p = allShortestPaths((martin)-[*]-(michael))
RETURN p
----

Finds the two shortest paths between *'Martin Sheen'* and *'Michael Douglas'*.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +p+
| +(1)-[ACTED_IN,1]->(5)<-[ACTED_IN,2]-(2)+
| +(1)-[ACTED_IN,4]->(6)<-[ACTED_IN,5]-(2)+
1+d|2 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (martin:Person {name: 'Martin Sheen'} ),
      (michael:Person {name: 'Michael Douglas'}),
      p = allShortestPaths((martin)-[*]-(michael))
RETURN p
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[get-node-rel-by-id]]
== Get node or relationship by id

[[match-node-by-id]]
=== Node by id

Searching for nodes by id can be done with the `id()` function in a predicate.

[NOTE]
====
Neo4j reuses its internal ids when nodes and relationships are deleted.
This means that applications using, and relying on internal Neo4j ids, are brittle or at risk of making mistakes.
It is therefore recommended to rather use application-generated ids.


====


.Query
[source, cypher]
----
MATCH (n)
WHERE id(n)= 0
RETURN n
----

The corresponding node is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n+
| +Node[0]{name:"Charlie Sheen"}+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (n) WHERE id(n) = 0 RETURN n
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-rel-by-id]]
=== Relationship by id


Search for relationships by id can be done with the `id()` function in a predicate.

This is not recommended practice. See xref:clauses/match.adoc#match-node-by-id[Node by id] for more information on the use of Neo4j ids.


.Query
[source, cypher]
----
MATCH ()-[r]->()
WHERE id(r)= 0
RETURN r
----

The relationship with id `0` is returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +r+
| +:ACTED_IN[0]{role:"Bud Fox"}+
1+d|1 row
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH ()-[r]->() WHERE id(r) = 0 RETURN r
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[match-multiple-nodes-by-id]]
=== Multiple nodes by id

Multiple nodes are selected by specifying them in an IN clause.


.Query
[source, cypher]
----
MATCH (n)
WHERE id(n) IN [0, 3, 5]
RETURN n
----

This returns the nodes listed in the `IN` expression.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n+
| +Node[0]{name:"Charlie Sheen"}+
| +Node[3]{name:"Oliver Stone"}+
| +Node[5]{title:"Wall Street"}+
1+d|3 rows
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE (charlie:Person {name: 'Charlie Sheen'}),
       (martin:Person {name: 'Martin Sheen'}),
       (michael:Person {name: 'Michael Douglas'}),
       (oliver:Person {name: 'Oliver Stone'}),
       (rob:Person {name: 'Rob Reiner'}),

       (wallStreet:Movie {title: 'Wall Street'}),

       (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
       (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
       (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
       (oliver)-[:DIRECTED]->(wallStreet),

       (thePresident:Movie {title: 'The American President'}),

       (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
       (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
       (rob)-[:DIRECTED]->(thePresident)

]]></database><command><![CDATA[
MATCH (n) WHERE id(n) IN [0, 3, 5] RETURN n
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

