:description: The `MATCH` clause is used to search for the pattern described in it.

[[query-match]]
= MATCH

[abstract]
--
The `MATCH` clause is used to search for the pattern described in it.
--

* xref::clauses/match.adoc#match-introduction[Introduction]
* xref::clauses/match.adoc#basic-node-finding[Basic node finding]
 ** xref::clauses/match.adoc#get-all-nodes[Get all nodes]
 ** xref::clauses/match.adoc#get-all-nodes-with-label[Get all nodes with a label]
 ** xref::clauses/match.adoc#related-nodes[Related nodes]
 ** xref::clauses/match.adoc#match-with-labels[Match with labels]
 ** xref::clauses/match.adoc#label-expression-match-or-expression[Match with a label expression for the node labels]
* xref::clauses/match.adoc#relationship-basics[Relationship basics]
 ** xref::clauses/match.adoc#outgoing-relationships[Outgoing relationships]
 ** xref::clauses/match.adoc#directed-rels-and-variable[Directed relationships and variable]
 ** xref::clauses/match.adoc#match-on-rel-type[Match on relationship type]
 ** xref::clauses/match.adoc#match-on-multiple-rel-types[Match on multiple relationship types]
 ** xref::clauses/match.adoc#match-on-rel-type-use-variable[Match on relationship type and use a variable]
* xref::clauses/match.adoc#relationships-in-depth[Relationships in depth]
 ** xref::clauses/match.adoc#rel-types-with-uncommon-chars[Relationship types with uncommon characters]
 ** xref::clauses/match.adoc#multiple-rels[Multiple relationships]
 ** xref::clauses/match.adoc#varlength-rels[Variable length relationships]
 ** xref::clauses/match.adoc#varlength-rels-multiple-types[Variable length relationships with multiple relationship types]
 ** xref::clauses/match.adoc#rel-variable-in-varlength-rels[Relationship variable in variable length relationships]
 ** xref::clauses/match.adoc#match-props-on-varlength-path[Match with properties on a variable length path]
 ** xref::clauses/match.adoc#zero-length-paths[Zero length paths]
 ** xref::clauses/match.adoc#named-paths[Named paths]
 ** xref::clauses/match.adoc#match-on-bound-rel[Matching on a bound relationship]
* xref::clauses/match.adoc#query-shortest-path[Shortest path]
 ** xref::clauses/match.adoc#single-shortest-path[Single shortest path]
 ** xref::clauses/match.adoc#single-shortest-path-with-predicates[Single shortest path with predicates]
 ** xref::clauses/match.adoc#all-shortest-paths[All shortest paths]
* xref::clauses/match.adoc#get-node-rel-by-id[Get node or relationship by elementId]
 ** xref::clauses/match.adoc#match-node-by-id[Node by elementId]
 ** xref::clauses/match.adoc#match-rel-by-id[Relationship by elementId]
 ** xref::clauses/match.adoc#match-multiple-nodes-by-id[Multiple nodes by elementId]


[[match-introduction]]
== Introduction

The `MATCH` clause allows you to specify the patterns Neo4j will search for in the database.
This is the primary way of getting data into the current set of bindings.
It is worth reading up more on the specification of the patterns themselves in xref::syntax/patterns.adoc[Patterns].

`MATCH` is often coupled to a `WHERE` part which adds restrictions, or predicates, to the `MATCH` patterns, making them more specific.
The predicates are part of the pattern description, and should not be considered a filter applied only after the matching is done.
_This means that `WHERE` should always be put together with the `MATCH` clause it belongs to._

`MATCH` can occur at the beginning of the query or later, possibly after a `WITH`.
If it is the first clause, nothing will have been bound yet, and Neo4j will design a search to find the results matching the clause and any associated predicates specified in any `WHERE` part.
This could involve a scan of the database, a search for nodes having a certain label, or a search of an index to find starting points for the pattern matching.
Nodes and relationships found by this search are available as _bound pattern elements,_ and can be used for pattern matching of paths.
They can also be used in any further `MATCH` clauses, where Neo4j will use the known elements, and from there find further unknown elements.

Cypher is declarative, and so usually the query itself does not specify the algorithm to use to perform the search.
Neo4j will automatically work out the best approach to finding start nodes and matching patterns.
Predicates in `WHERE` parts can be evaluated before pattern matching, during pattern matching, or after finding matches.
However, there are cases where you can influence the decisions taken by the query compiler.
Read more about indexes in xref::indexes-for-search-performance.adoc[], and more about specifying hints to force Neo4j to solve a query in a specific way in xref::query-tuning/using.adoc[Planner hints and the USING keyword].

[TIP]
====
To understand more about the patterns used in the `MATCH` clause, read the chapter on xref::syntax/patterns.adoc[Patterns].
====

The following graph is used for the examples below:

image::graph_match_clause.svg[width="600",role="middle"]


To recreate the graph, run the following query in an empty Neo4j database:

[source, cypher, role=test-setup]
----
CREATE
  (charlie:Person {name: 'Charlie Sheen'}),
  (martin:Person {name: 'Martin Sheen'}),
  (michael:Person {name: 'Michael Douglas'}),
  (oliver:Person {name: 'Oliver Stone'}),
  (rob:Person {name: 'Rob Reiner'}),
  (wallStreet:Movie {title: 'Wall Street'}),
  (charlie)-[:ACTED_IN {role: 'Bud Fox'}]->(wallStreet),
  (martin)-[:ACTED_IN {role: 'Carl Fox'}]->(wallStreet),
  (michael)-[:ACTED_IN {role: 'Gordon Gekko'}]->(wallStreet),
  (oliver)-[:DIRECTED]->(wallStreet),
  (thePresident:Movie {title: 'The American President'}),
  (martin)-[:ACTED_IN {role: 'A.J. MacInerney'}]->(thePresident),
  (michael)-[:ACTED_IN {role: 'President Andrew Shepherd'}]->(thePresident),
  (rob)-[:DIRECTED]->(thePresident),
  (martin)-[:FATHER_OF]->(charlie)
----


[[basic-node-finding]]
== Basic node finding

[[related-nodes]]
=== Related nodes

The symbol `--` means _related to,_ without regard to type or direction of the relationship.

.Query
[source, cypher, indent=0]
----
MATC (director {name: 'Oliver Stone'})--(movie)
RETURN movie.title
----

[[get-all-nodes-with-label]]
=== Get all nodes with a label

Find all nodes with a specific label:

.Query
[source, cypher, indent=0]
----
MATCH (movie:Movie)
RETURN movie.title
----

Returns all the nodes with the `Movie` label in the database.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +movie.title+
| +"Wall Street"+
1+d|Rows: 2
|===

[[get-all-nodes]]
=== Get all nodes

By specifying a pattern with a single node and no labels, all nodes in the graph will be returned.

.Query
[source, cypher, indent=0]
----
MATCH (n)
RETURN n
----

Returns all the nodes in the database.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n+
| +{"name":"Charlie Sheen"}+
| +{"name":"Martin Sheen"}+
| +{"name":"Michael Douglas"}+
| +{"title":"Wall Street"}+
| +{"title":"The American President"}+
1+d|Rows: 7
|===
