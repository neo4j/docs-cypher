[[query-call-subquery]]
= CALL {} (subquery)
:description: The `CALL {}` clause evaluates a subquery that returns some values. 

* xref:clauses/call-subquery.adoc#subquery-call-introduction[Introduction]
* xref:clauses/call-subquery.adoc#subquery-correlated-importing[Importing variables into subqueries]
* xref:clauses/call-subquery.adoc#subquery-post-union[Post-union processing]
* xref:clauses/call-subquery.adoc#subquery-aggregation[Aggregation and side-effects]
* xref:clauses/call-subquery.adoc#subquery-correlated-aggregation[Aggregation on imported variables]

[[subquery-call-introduction]]
== Introduction

CALL allows to execute subqueries, i.e. queries inside of other queries.
Subqueries allow you to compose queries, which is especially useful when working with `UNION` or aggregations.

[TIP]
====
The `CALL` clause is also used for calling procedures.
For descriptions of the `CALL` clause in this context, refer to xref:clauses/call.adoc[CALL procedure].
====

A subquery is evaluated for each incoming input row and may produce an arbitrary number of output rows.
Every output row is then combined with the input row to build the result of the subquery.
That means that a subquery will influence the number of rows.
If the subquery does not return any rows, there will be no rows available after the subquery.

There are restrictions on what queries are allowed as subqueries and how they interact with the enclosing query:

* A subquery must end with a `RETURN` clause.
* A subquery can only refer to variables from the enclosing query if they are explicitly imported.
* A subquery cannot return variables with the same names as variables in the enclosing query.
* All variables that are returned from a subquery are afterwards available in the enclosing query.

The following graph is used for the examples below:

.Graph
["dot", "CALL {} (subquery)-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Person, Child|age = 20\lname = \'Alice\'\l}"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "CHILD_OF\n"
  ]
  N0 -> N1 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "FRIEND_OF\n"
  ]
  N1 [
    label = "{Person|age = 27\lname = \'Bob\'\l}"
  ]
  N2 [
    label = "{Person, Parent|age = 65\lname = \'Charlie\'\l}"
  ]
  N3 [
    label = "{Person|age = 30\lname = \'Dora\'\l}"
  ]

----
 

[[subquery-correlated-importing]]
== Importing variables into subqueries

Variables are imported into a subquery using an importing `WITH` clause.
As the subquery is evaluated for each incoming input row, the imported variables get bound to the corresponding values from the input row in each evaluation.


.Query
[source, cypher]
----
UNWIND [0, 1, 2] AS x
CALL {
  WITH x
  RETURN x * 10 AS y
}
RETURN x, y
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +x+ | +y+
| +0+ | +0+
| +1+ | +10+
| +2+ | +20+
2+d|Rows: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a:Person:Child {age: 20, name: 'Alice'}),
  (b:Person {age: 27, name: 'Bob'}),
  (c:Person:Parent {age: 65, name: 'Charlie'}),
  (d:Person {age: 30, name: 'Dora'})
  CREATE (a)-[:FRIEND_OF]->(b)
  CREATE (a)-[:CHILD_OF]->(c)

]]></database><command><![CDATA[
UNWIND [0, 1, 2] AS x
CALL {
  WITH x
  RETURN x * 10 AS y
}
RETURN x, y
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

An importing `WITH` clause must:

* Consist only of simple references to outside variables - e.g. `WITH x, y, z`. Aliasing or expressions are not supported in importing `WITH` clauses - e.g. `WITH a AS b` or `WITH a+1 AS b`.
* Be the first clause of a subquery (or the second clause, if directly following a `USE` clause).

[[subquery-post-union]]
== Post-union processing

Subqueries can be used to process the results of a `UNION` query further.
This example query finds the youngest and the oldest person in the database and orders them by name.


.Query
[source, cypher]
----
CALL {
  MATCH (p:Person)
  RETURN p
  ORDER BY p.age ASC
  LIMIT 1
UNION
  MATCH (p:Person)
  RETURN p
  ORDER BY p.age DESC
  LIMIT 1
}
RETURN p.name, p.age
ORDER BY p.name
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +p.name+ | +p.age+
| +"Alice"+ | +20+
| +"Charlie"+ | +65+
2+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a:Person:Child {age: 20, name: 'Alice'}),
  (b:Person {age: 27, name: 'Bob'}),
  (c:Person:Parent {age: 65, name: 'Charlie'}),
  (d:Person {age: 30, name: 'Dora'})
  CREATE (a)-[:FRIEND_OF]->(b)
  CREATE (a)-[:CHILD_OF]->(c)

]]></database><command><![CDATA[
CALL {
  MATCH (p:Person)
  RETURN p
  ORDER BY p.age ASC
  LIMIT 1
UNION
  MATCH (p:Person)
  RETURN p
  ORDER BY p.age DESC
  LIMIT 1
}
RETURN p.name, p.age
ORDER BY p.name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

If different parts of a result should be matched differently, with some aggregation over the whole results, subqueries need to be used.
This example query finds friends and/or parents for each person.
Subsequently the number of friends and parents are counted together.


.Query
[source, cypher]
----
MATCH (p:Person)
CALL {
  WITH p
  OPTIONAL MATCH (p)-[:FRIEND_OF]->(other:Person)
  RETURN other
UNION
  WITH p
  OPTIONAL MATCH (p)-[:CHILD_OF]->(other:Parent)
  RETURN other
}
RETURN DISTINCT p.name, count(other)
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +p.name+ | +count(other)+
| +"Alice"+ | +2+
| +"Bob"+ | +0+
| +"Charlie"+ | +0+
| +"Dora"+ | +0+
2+d|Rows: 4
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a:Person:Child {age: 20, name: 'Alice'}),
  (b:Person {age: 27, name: 'Bob'}),
  (c:Person:Parent {age: 65, name: 'Charlie'}),
  (d:Person {age: 30, name: 'Dora'})
  CREATE (a)-[:FRIEND_OF]->(b)
  CREATE (a)-[:CHILD_OF]->(c)

]]></database><command><![CDATA[
MATCH (p:Person)
CALL {
  WITH p
  OPTIONAL MATCH (p)-[:FRIEND_OF]->(other:Person)
  RETURN other
UNION
  WITH p
  OPTIONAL MATCH (p)-[:CHILD_OF]->(other:Parent)
  RETURN other
}
RETURN DISTINCT p.name, count(other)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[subquery-aggregation]]
== Aggregation and side-effects

Subqueries can be useful to do aggregations for each row and to isolate side-effects.
This example query creates five `Clone` nodes for each existing person.
The aggregation ensures that cardinality is not changed by the subquery.
Without this, the result would be five times as many rows.


.Query
[source, cypher]
----
MATCH (p:Person)
CALL {
  UNWIND range(1, 5) AS i
  CREATE (c:Clone)
  RETURN count(c) AS numberOfClones
}
RETURN p.name, numberOfClones
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +p.name+ | +numberOfClones+
| +"Alice"+ | +5+
| +"Bob"+ | +5+
| +"Charlie"+ | +5+
| +"Dora"+ | +5+
2+d|Rows: 4 +
Nodes created: 20 +
Labels added: 20
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a:Person:Child {age: 20, name: 'Alice'}),
  (b:Person {age: 27, name: 'Bob'}),
  (c:Person:Parent {age: 65, name: 'Charlie'}),
  (d:Person {age: 30, name: 'Dora'})
  CREATE (a)-[:FRIEND_OF]->(b)
  CREATE (a)-[:CHILD_OF]->(c)

]]></database><command><![CDATA[
MATCH (p:Person)
CALL {
  UNWIND range(1, 5) AS i
  CREATE (c:Clone)
  RETURN count(c) AS numberOfClones
}
RETURN p.name, numberOfClones
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[subquery-correlated-aggregation]]
== Aggregation on imported variables

Aggregations in subqueries are scoped to the subquery evaluation, also for imported variables.
The following example counts the number of younger persons for each person in the graph:


.Query
[source, cypher]
----
MATCH (p:Person)
CALL {
  WITH p
  MATCH (other:Person)
  WHERE other.age < p.age
  RETURN count(other) AS youngerPersonsCount
}
RETURN p.name, youngerPersonsCount
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +p.name+ | +youngerPersonsCount+
| +"Alice"+ | +0+
| +"Bob"+ | +1+
| +"Charlie"+ | +3+
| +"Dora"+ | +2+
2+d|Rows: 4
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a:Person:Child {age: 20, name: 'Alice'}),
  (b:Person {age: 27, name: 'Bob'}),
  (c:Person:Parent {age: 65, name: 'Charlie'}),
  (d:Person {age: 30, name: 'Dora'})
  CREATE (a)-[:FRIEND_OF]->(b)
  CREATE (a)-[:CHILD_OF]->(c)

]]></database><command><![CDATA[
MATCH (p:Person)
CALL {
  WITH p
  MATCH (other:Person)
  WHERE other.age < p.age
  RETURN count(other) AS youngerPersonsCount
}
RETURN p.name, youngerPersonsCount
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

