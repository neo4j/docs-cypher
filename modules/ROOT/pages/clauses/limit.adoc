:description: `LIMIT` constrains the number of returned rows.

[[query-limit]]
= LIMIT

`LIMIT` constrains the number of returned rows.

`LIMIT` accepts any expression that evaluates to a positive `INTEGER` and does not refer to nodes or relationships.


[[example-graph]]
== Example graph

The following graph is used for the examples below:

image::graph_limit_clause.svg[width="600", role="middle"]

To recreate it, run the following query against an empty Neo4j database:

[source, cypher, role=test-setup]
----
CREATE
  (andy: Person {name: 'Andy'}),
  (bernard: Person {name: 'Bernard'}),
  (charlotte: Person {name: 'Charlotte'}),
  (david: Person {name: 'David'}),
  (erika: Person {name: 'Erika'}),
  (andy)-[:KNOWS]->(bernard),
  (andy)-[:KNOWS]->(charlotte),
  (andy)-[:KNOWS]->(david),
  (andy)-[:KNOWS]->(erika)
----

[[examples]]
== Examples


.Return a limited subset of the rows
====

To return a limited subset of the rows, use this syntax:

.Query
[source, cypher]
----
MATCH (n)
RETURN n.name
ORDER BY n.name
LIMIT 3
----

Limit to 3 rows by the example query.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| n.name
| "Andy"
| "Bernard"
| "Charlotte"
d|Rows: 3
|===

====

.Using an expression with `LIMIT` to return a subset of the rows
====

`LIMIT` accepts any expression that evaluates to a positive integer, as long as it can be statically calculated (i.e. calculated before the query is run).

.Query
[source, cypher]
----
MATCH (n)
RETURN n.name
ORDER BY n.name
LIMIT 1 + toInteger(3 * rand())
----

Limit 1 row plus randomly 0, 1, or 2.
So randomly limit to 1, 2, or 3 rows.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| n.name
| "Andy"
| "Bernard"
| "Charlotte"
d|Rows: 3
|===

====

[[limit-will-not-stop-side-effects]]
== `LIMIT` and side effects

The use of `LIMIT` in a query will not stop side effects, like `CREATE`, `DELETE`, or `SET`, from happening if the limit is in the same query part as the side effect.

.Query
[source, cypher]
----
CREATE (n)
RETURN n
LIMIT 0
----

This query returns nothing, but creates one node:

.Result
[role="queryresult",options="footer",cols="1*<m"]
|===
|(empty result)
d|Rows: 0 +
Nodes created: 1
|===

.Query
[source, cypher]
----
MATCH (n {name: 'A'})
SET n.age = 60
RETURN n
LIMIT 0
----

This query returns nothing, but writes one property:

.Result
[role="queryresult",options="footer",cols="1*<m"]
|===
|(empty result)
d|Rows: 0 +
Properties set: 1
|===

If we want to limit the number of updates we can split the query using the `WITH` clause:

.Query
[source, cypher]
----
MATCH (n)
WITH n ORDER BY n.name LIMIT 1
SET n.locked = true
RETURN n
----

Writes `locked` property on one node and return that node:

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| n
| {locked:true,name:"Andy",age:60}
d|Rows: 1 +
Properties set: 1
|===

[role=label--new-5.24]
[[limit-standalone-clause]]
== Using `LIMIT` as a standalone clause

`LIMIT` can be used as a standalone clause, or in conjunction with xref:clauses/order-by.adoc[`ORDER BY`] or xref:clauses/skip.adoc[`SKIP`]/xref:clauses/skip.adoc#offset-synonym[`OFFSET`].

.Standalone use of `LIMIT`
[source, cypher]
----
MATCH (n)
LIMIT 2
RETURN collect(n.name) AS names
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| names
| ["Andy", "Bernard"]
|Rows: 1
|===

The following query orders all nodes by `name` descending, skips the two first rows and limits the results to two rows.
It then xref:functions/aggregating.adoc#functions-collect[collects] the results in a list.

.`LIMIT` used in conjunction with `ORDER BY` and `SKIP`
[source, cypher]
----
MATCH (n)
ORDER BY n.name DESC
SKIP 2
LIMIT 2
RETURN collect(n.name) AS names
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| names
| ["David", "Charlotte"]
|Rows: 1
|===
