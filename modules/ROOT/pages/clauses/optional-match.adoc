[[query-optional-match]]
= OPTIONAL MATCH
:description: The `OPTIONAL MATCH` clause is used to search for the pattern described in it, while using nulls for missing parts of the pattern. 

* xref:clauses/optional-match.adoc#optional-match-introduction[Introduction]
* xref:clauses/optional-match.adoc#optional-relationships[Optional relationships]
* xref:clauses/optional-match.adoc#properties-on-optional-elements[Properties on optional elements]
* xref:clauses/optional-match.adoc#optional-typed-named-relationship[Optional typed and named relationship]

[[optional-match-introduction]]
== Introduction

`OPTIONAL MATCH` matches patterns against your graph database, just like `MATCH` does.
The difference is that if no matches are found, `OPTIONAL MATCH` will use a `null` for missing parts of the pattern.
`OPTIONAL MATCH` could be considered the Cypher equivalent of the outer join in SQL.

Either the whole pattern is matched, or nothing is matched.
Remember that `WHERE` is part of the pattern description, and the predicates will be considered while looking for matches, not after.
This matters especially in the case of multiple (`OPTIONAL`) `MATCH` clauses, where it is crucial to put `WHERE` together with the `MATCH` it belongs to.

[TIP]
====
To understand the patterns used in the `OPTIONAL MATCH` clause, read xref:syntax/patterns.adoc[Patterns].


====

The following graph is used for the examples below:

.Graph
["dot", "OPTIONAL MATCH-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Person|name = \'Charlie Sheen\'\l}"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "FATHER\n"
  ]
  N0 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N1 [
    label = "{Person|name = \'Martin Sheen\'\l}"
  ]
  N1 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N1 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N2 [
    label = "{Person|name = \'Michael Douglas\'\l}"
  ]
  N2 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N2 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N3 [
    label = "{Person|name = \'Oliver Stone\'\l}"
  ]
  N3 -> N5 [
    color = "#a40000"
    fontcolor = "#a40000"
    label = "DIRECTED\n"
  ]
  N4 [
    label = "{Person|name = \'Rob Reiner\'\l}"
  ]
  N4 -> N6 [
    color = "#a40000"
    fontcolor = "#a40000"
    label = "DIRECTED\n"
  ]
  N5 [
    label = "{Movie|title = \'Wall Street\'\l}"
  ]
  N6 [
    label = "{Movie|title = \'The American President\'\l}"
  ]

----
 

[[optional-relationships]]
== Optional relationships

If a relationship is optional, use the `OPTIONAL MATCH` clause.
This is similar to how a SQL outer join works.
If the relationship is there, it is returned.
If it's not, `null` is returned in its place.


.Query
[source, cypher]
----
MATCH (a:Movie {title: 'Wall Street'})
OPTIONAL MATCH (a)-->(x)
RETURN x
----

Returns `null`, since the node has no outgoing relationships.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +x+
| +<null>+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (charlie:Person {name: 'Charlie Sheen'}),
  (martin:Person {name: 'Martin Sheen'}),
  (michael:Person {name: 'Michael Douglas'}),
  (oliver:Person {name: 'Oliver Stone'}),
  (rob:Person {name: 'Rob Reiner'}),
  (wallStreet:Movie {title: 'Wall Street'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (oliver)-[:DIRECTED]->(wallStreet),
  (thePresident:Movie {title: 'The American President'}),
  (martin)-[:ACTED_IN]->(thePresident),
  (michael)-[:ACTED_IN]->(thePresident),
  (rob)-[:DIRECTED]->(thePresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH (a:Movie {title: 'Wall Street'})
OPTIONAL MATCH (a)-->(x)
RETURN x
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[properties-on-optional-elements]]
== Properties on optional elements

Returning a property from an optional element that is `null` will also return `null`.


.Query
[source, cypher]
----
MATCH (a:Movie {title: 'Wall Street'})
OPTIONAL MATCH (a)-->(x)
RETURN x, x.name
----

Returns the element x (`null` in this query), and `null` as its name.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +x+ | +x.name+
| +<null>+ | +<null>+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (charlie:Person {name: 'Charlie Sheen'}),
  (martin:Person {name: 'Martin Sheen'}),
  (michael:Person {name: 'Michael Douglas'}),
  (oliver:Person {name: 'Oliver Stone'}),
  (rob:Person {name: 'Rob Reiner'}),
  (wallStreet:Movie {title: 'Wall Street'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (oliver)-[:DIRECTED]->(wallStreet),
  (thePresident:Movie {title: 'The American President'}),
  (martin)-[:ACTED_IN]->(thePresident),
  (michael)-[:ACTED_IN]->(thePresident),
  (rob)-[:DIRECTED]->(thePresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH (a:Movie {title: 'Wall Street'})
OPTIONAL MATCH (a)-->(x)
RETURN x, x.name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[optional-typed-named-relationship]]
== Optional typed and named relationship

Just as with a normal relationship, you can decide which variable it goes into, and what relationship type you need.


.Query
[source, cypher]
----
MATCH (a:Movie {title: 'Wall Street'})
OPTIONAL MATCH (a)-[r:ACTS_IN]->()
RETURN a.title, r
----

This returns the title of the node, *'Wall Street'*, and, since the node has no outgoing `ACTS_IN` relationships, `null` is returned for the relationship denoted by `r`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +a.title+ | +r+
| +"Wall Street"+ | +<null>+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (charlie:Person {name: 'Charlie Sheen'}),
  (martin:Person {name: 'Martin Sheen'}),
  (michael:Person {name: 'Michael Douglas'}),
  (oliver:Person {name: 'Oliver Stone'}),
  (rob:Person {name: 'Rob Reiner'}),
  (wallStreet:Movie {title: 'Wall Street'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (oliver)-[:DIRECTED]->(wallStreet),
  (thePresident:Movie {title: 'The American President'}),
  (martin)-[:ACTED_IN]->(thePresident),
  (michael)-[:ACTED_IN]->(thePresident),
  (rob)-[:DIRECTED]->(thePresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH (a:Movie {title: 'Wall Street'})
OPTIONAL MATCH (a)-[r:ACTS_IN]->()
RETURN a.title, r
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

