[[query-merge]]
= MERGE
:description: The `MERGE` clause ensures that a pattern exists in the graph. Either the pattern already exists, or it needs to be created. 

* xref:clauses/merge.adoc#query-merge-introduction[Introduction]
* xref:clauses/merge.adoc#query-merge-node-derived[Merge nodes]
** xref:clauses/merge.adoc#merge-merge-single-node-with-a-label[Merge single node with a label]
** xref:clauses/merge.adoc#merge-merge-single-node-with-properties[Merge single node with properties]
** xref:clauses/merge.adoc#merge-merge-single-node-specifying-both-label-and-property[Merge single node specifying both label and property]
** xref:clauses/merge.adoc#merge-merge-single-node-derived-from-an-existing-node-property[Merge single node derived from an existing node property]
* xref:clauses/merge.adoc#query-merge-on-create-on-match[Use `ON CREATE` and `ON MATCH`]
** xref:clauses/merge.adoc#merge-merge-with-on-create[Merge with `ON CREATE`]
** xref:clauses/merge.adoc#merge-merge-with-on-match[Merge with `ON MATCH`]
** xref:clauses/merge.adoc#merge-merge-with-on-create-and-on-match[Merge with `ON CREATE` and `ON MATCH`]
** xref:clauses/merge.adoc#merge-merge-with-on-match-setting-multiple-properties[Merge with `ON MATCH` setting multiple properties]
* xref:clauses/merge.adoc#query-merge-relationships[Merge relationships]
** xref:clauses/merge.adoc#merge-merge-on-a-relationship[Merge on a relationship]
** xref:clauses/merge.adoc#merge-merge-on-multiple-relationships[Merge on multiple relationships]
** xref:clauses/merge.adoc#merge-merge-on-an-undirected-relationship[Merge on an undirected relationship]
** xref:clauses/merge.adoc#merge-merge-on-a-relationship-between-two-existing-nodes[Merge on a relationship between two existing nodes]
** xref:clauses/merge.adoc#merge-merge-on-a-relationship-between-an-existing-node-and-a-merged-node-derived-from-a-node-property[Merge on a relationship between an existing node and a merged node derived from a node property]
* xref:clauses/merge.adoc#query-merge-using-unique-constraints[Using unique constraints with `MERGE`]
** xref:clauses/merge.adoc#merge-merge-using-unique-constraints-creates-a-new-node-if-no-node-is-found[Merge using unique constraints creates a new node if no node is found]
** xref:clauses/merge.adoc#merge-merge-using-unique-constraints-matches-an-existing-node[Merge using unique constraints matches an existing node]
** xref:clauses/merge.adoc#merge-merge-with-unique-constraints-and-partial-matches[Merge with unique constraints and partial matches]
** xref:clauses/merge.adoc#merge-merge-with-unique-constraints-and-conflicting-matches[Merge with unique constraints and conflicting matches]
* xref:clauses/merge.adoc#merge-using-map-parameters-with-merge[Using map parameters with `MERGE`]

[[query-merge-introduction]]
== Introduction

`MERGE` either matches existing nodes and binds them, or it creates new data and binds that.
It's like a combination of `MATCH` and `CREATE` that additionally allows you to specify what happens if the data was matched or created.

For example, you can specify that the graph must contain a node for a user with a certain name.
If there isn't a node with the correct name, a new node will be created and its name property set.

[NOTE]
====
For performance reasons, creating a schema index on the label or property is highly recommended when using `MERGE`.
See xref:indexes-for-search-performance.adoc[] for more information.


====

When using `MERGE` on full patterns, the behavior is that either the whole pattern matches, or the whole pattern is created.
`MERGE` will not partially use existing patterns -- it is all or nothing.
If partial matches are needed, this can be accomplished by splitting a pattern up into multiple `MERGE` clauses.

[IMPORTANT]
====
Under concurrent updates, `MERGE` only guarantees existence of the `MERGE` pattern, but not uniqueness.
To guarantee uniqueness of nodes with certain properties, a xref:constraints/index.adoc[unique constraint] should be used.
See xref:clauses/merge.adoc#query-merge-using-unique-constraints[Using unique constraints with `MERGE`] to see how `MERGE` can be used in combination with a unique constraint.


====

As with `MATCH`, `MERGE` can match multiple occurrences of a pattern.
If there are multiple matches, they will all be passed on to later stages of the query.

The last part of `MERGE` is the `ON CREATE` and `ON MATCH`.
These allow a query to express additional changes to the properties of a node or relationship, depending on if the element was matched (`MATCH`) in the database or if it was created (`CREATE`).

The following graph is used for the examples below:

.Graph
["dot", "MERGE-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Person|bornIn = \'New York\'\lchauffeurName = \'John Brown\'\lname = \'Charlie Sheen\'\l}"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "FATHER\n"
  ]
  N0 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N1 [
    label = "{Person|bornIn = \'Ohio\'\lchauffeurName = \'Bob Brown\'\lname = \'Martin Sheen\'\l}"
  ]
  N1 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N1 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N2 [
    label = "{Person|name = \'Michael Douglas\'\lchauffeurName = \'John Brown\'\lbornIn = \'New Jersey\'\l}"
  ]
  N2 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N2 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N3 [
    label = "{Person|bornIn = \'New York\'\lchauffeurName = \'Bill White\'\lname = \'Oliver Stone\'\l}"
  ]
  N3 -> N5 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N4 [
    label = "{Person|bornIn = \'New York\'\lchauffeurName = \'Ted Green\'\lname = \'Rob Reiner\'\l}"
  ]
  N4 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "ACTED_IN\n"
  ]
  N5 [
    label = "{Movie|title = \'Wall Street\'\l}"
  ]
  N6 [
    label = "{Movie|title = \'The American President\'\l}"
  ]

----
 

[[query-merge-node-derived]]
== Merge nodes

[[merge-merge-single-node-with-a-label]]
=== Merge single node with a label

Merging a single node with the given label.


.Query
[source, cypher]
----
MERGE (robert:Critic)
RETURN robert, labels(robert)
----

A new node is created because there are no nodes labeled `Critic` in the database.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +robert+ | +labels(robert)+
| +Node[7]{}+ | +["Critic"]+
2+d|Rows: 1 +
Nodes created: 1 +
Labels added: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (robert:Critic)
RETURN robert, labels(robert)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-single-node-with-properties]]
=== Merge single node with properties

Merging a single node with properties where not all properties match any existing node.


.Query
[source, cypher]
----
MERGE (charlie {name: 'Charlie Sheen', age: 10})
RETURN charlie
----

A new node with the name *'Charlie Sheen'* will be created since not all properties matched the existing *'Charlie Sheen'* node.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +charlie+
| +Node[7]{age:10,name:"Charlie Sheen"}+
1+d|Rows: 1 +
Nodes created: 1 +
Properties set: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (charlie {name: 'Charlie Sheen', age: 10})
RETURN charlie
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-single-node-specifying-both-label-and-property]]
=== Merge single node specifying both label and property

Merging a single node with both label and property matching an existing node.


.Query
[source, cypher]
----
MERGE (michael:Person {name: 'Michael Douglas'})
RETURN michael.name, michael.bornIn
----

*'Michael Douglas'* will be matched and the `name` and  `bornIn` properties returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +michael.name+ | +michael.bornIn+
| +"Michael Douglas"+ | +"New Jersey"+
2+d|Rows: 1
|===

As mentioned previously, `MERGE` queries can greatly benefit from schema indexes.
In this example, the following would significantly improve the performance of the `MERGE` clause:

`CREATE INDEX PersonIndex FOR (n:Person) ON (n.name)`

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (michael:Person {name: 'Michael Douglas'})
RETURN michael.name, michael.bornIn
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-single-node-derived-from-an-existing-node-property]]
=== Merge single node derived from an existing node property

For some property 'p' in each bound node in a set of nodes, a single new node is created for each unique value for 'p'.


.Query
[source, cypher]
----
MATCH (person:Person)
MERGE (city:City {name: person.bornIn})
RETURN person.name, person.bornIn, city
----

Three nodes labeled `City` are created, each of which contains a `name` property with the value of *'New York'*, *'Ohio'*, and *'New Jersey'*, respectively.
Note that even though the `MATCH` clause results in three bound nodes having the value *'New York'* for the `bornIn` property, only a single *'New York'* node (i.e. a `City` node with a name of *'New York'*) is created.
As the *'New York'* node is not matched for the first bound node, it is created.
However, the newly-created *'New York'* node is matched and bound for the second and third bound nodes.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.bornIn+ | +city+
| +"Charlie Sheen"+ | +"New York"+ | +Node[7]{name:"New York"}+
| +"Martin Sheen"+ | +"Ohio"+ | +Node[8]{name:"Ohio"}+
| +"Michael Douglas"+ | +"New Jersey"+ | +Node[9]{name:"New Jersey"}+
| +"Oliver Stone"+ | +"New York"+ | +Node[7]{name:"New York"}+
| +"Rob Reiner"+ | +"New York"+ | +Node[7]{name:"New York"}+
3+d|Rows: 5 +
Nodes created: 3 +
Properties set: 3 +
Labels added: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH (person:Person)
MERGE (city:City {name: person.bornIn})
RETURN person.name, person.bornIn, city
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-merge-on-create-on-match]]
== Use `ON CREATE` and `ON MATCH`

[[merge-merge-with-on-create]]
=== Merge with `ON CREATE`

Merge a node and set properties if the node needs to be created.


.Query
[source, cypher]
----
MERGE (keanu:Person {name: 'Keanu Reeves'})
ON CREATE
  SET keanu.created = timestamp()
RETURN keanu.name, keanu.created
----

The query creates the *'keanu'* node and sets a timestamp on creation time.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +keanu.name+ | +keanu.created+
| +"Keanu Reeves"+ | +1668159308277+
2+d|Rows: 1 +
Nodes created: 1 +
Properties set: 2 +
Labels added: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (keanu:Person {name: 'Keanu Reeves'})
ON CREATE
  SET keanu.created = timestamp()
RETURN keanu.name, keanu.created
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-with-on-match]]
=== Merge with `ON MATCH`

Merging nodes and setting properties on found nodes.


.Query
[source, cypher]
----
MERGE (person:Person)
ON MATCH
  SET person.found = true
RETURN person.name, person.found
----

The query finds all the `Person` nodes, sets a property on them, and returns them.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +person.found+
| +"Charlie Sheen"+ | +true+
| +"Martin Sheen"+ | +true+
| +"Michael Douglas"+ | +true+
| +"Oliver Stone"+ | +true+
| +"Rob Reiner"+ | +true+
2+d|Rows: 5 +
Properties set: 5
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (person:Person)
ON MATCH
  SET person.found = true
RETURN person.name, person.found
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-with-on-create-and-on-match]]
=== Merge with `ON CREATE` and `ON MATCH`


.Query
[source, cypher]
----
MERGE (keanu:Person {name: 'Keanu Reeves'})
ON CREATE
  SET keanu.created = timestamp()
ON MATCH
  SET keanu.lastSeen = timestamp()
RETURN keanu.name, keanu.created, keanu.lastSeen
----

The query creates the *'keanu'* node, and sets a timestamp on creation time.
If *'keanu'* had already existed, a different property would have been set.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +keanu.name+ | +keanu.created+ | +keanu.lastSeen+
| +"Keanu Reeves"+ | +1668159309958+ | +<null>+
3+d|Rows: 1 +
Nodes created: 1 +
Properties set: 2 +
Labels added: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (keanu:Person {name: 'Keanu Reeves'})
ON CREATE
  SET keanu.created = timestamp()
ON MATCH
  SET keanu.lastSeen = timestamp()
RETURN keanu.name, keanu.created, keanu.lastSeen
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-with-on-match-setting-multiple-properties]]
=== Merge with `ON MATCH` setting multiple properties

If multiple properties should be set, simply separate them with commas.


.Query
[source, cypher]
----
MERGE (person:Person)
ON MATCH
  SET
    person.found = true,
    person.lastAccessed = timestamp()
RETURN person.name, person.found, person.lastAccessed
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.found+ | +person.lastAccessed+
| +"Charlie Sheen"+ | +true+ | +1668159310891+
| +"Martin Sheen"+ | +true+ | +1668159310891+
| +"Michael Douglas"+ | +true+ | +1668159310891+
| +"Oliver Stone"+ | +true+ | +1668159310891+
| +"Rob Reiner"+ | +true+ | +1668159310891+
3+d|Rows: 5 +
Properties set: 10
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (person:Person)
ON MATCH
  SET
    person.found = true,
    person.lastAccessed = timestamp()
RETURN person.name, person.found, person.lastAccessed
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-merge-relationships]]
== Merge relationships

[[merge-merge-on-a-relationship]]
=== Merge on a relationship

`MERGE` can be used to match or create a relationship.


.Query
[source, cypher]
----
MATCH
  (charlie:Person {name: 'Charlie Sheen'}),
  (wallStreet:Movie {title: 'Wall Street'})
MERGE (charlie)-[r:ACTED_IN]->(wallStreet)
RETURN charlie.name, type(r), wallStreet.title
----

*'Charlie Sheen'* had already been marked as acting in *'Wall Street'*, so the existing relationship is found and returned.
Note that in order to match or create a relationship when using `MERGE`, at least one bound node must be specified, which is done via the `MATCH` clause in the above example.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +charlie.name+ | +type(r)+ | +wallStreet.title+
| +"Charlie Sheen"+ | +"ACTED_IN"+ | +"Wall Street"+
3+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH
  (charlie:Person {name: 'Charlie Sheen'}),
  (wallStreet:Movie {title: 'Wall Street'})
MERGE (charlie)-[r:ACTED_IN]->(wallStreet)
RETURN charlie.name, type(r), wallStreet.title
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-on-multiple-relationships]]
=== Merge on multiple relationships


.Query
[source, cypher]
----
MATCH
  (oliver:Person {name: 'Oliver Stone'}),
  (reiner:Person {name: 'Rob Reiner'})
MERGE (oliver)-[:DIRECTED]->(movie:Movie)<-[:ACTED_IN]-(reiner)
RETURN movie
----

In our example graph, *'Oliver Stone'* and *'Rob Reiner'* have never worked together.
When we try to `MERGE` a "movie between them, Neo4j will not use any of the existing movies already connected to either person.
Instead, a new *'movie'* node is created.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +movie+
| +Node[7]{}+
1+d|Rows: 1 +
Nodes created: 1 +
Relationships created: 2 +
Labels added: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH
  (oliver:Person {name: 'Oliver Stone'}),
  (reiner:Person {name: 'Rob Reiner'})
MERGE (oliver)-[:DIRECTED]->(movie:Movie)<-[:ACTED_IN]-(reiner)
RETURN movie
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-on-an-undirected-relationship]]
=== Merge on an undirected relationship

`MERGE` can also be used with an undirected relationship.
When it needs to create a new one, it will pick a direction.


.Query
[source, cypher]
----
MATCH
  (charlie:Person {name: 'Charlie Sheen'}),
  (oliver:Person {name: 'Oliver Stone'})
MERGE (charlie)-[r:KNOWS]-(oliver)
RETURN r
----

As *'Charlie Sheen'* and *'Oliver Stone'* do not know each other this `MERGE` query will create a `KNOWS` relationship between them.
The direction of the created relationship is arbitrary.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +r+
| +:KNOWS[8]{}+
1+d|Rows: 1 +
Relationships created: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH
  (charlie:Person {name: 'Charlie Sheen'}),
  (oliver:Person {name: 'Oliver Stone'})
MERGE (charlie)-[r:KNOWS]-(oliver)
RETURN r
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-on-a-relationship-between-two-existing-nodes]]
=== Merge on a relationship between two existing nodes

`MERGE` can be used in conjunction with preceding `MATCH` and `MERGE` clauses to create a relationship between two bound nodes 'm' and 'n', where 'm' is returned by `MATCH` and 'n' is created or matched by the earlier `MERGE`.


.Query
[source, cypher]
----
MATCH (person:Person)
MERGE (city:City {name: person.bornIn})
MERGE (person)-[r:BORN_IN]->(city)
RETURN person.name, person.bornIn, city
----

This builds on the example from xref:clauses/merge.adoc#merge-merge-single-node-derived-from-an-existing-node-property[Merge single node derived from an existing node property].
The second `MERGE` creates a `BORN_IN` relationship between each person and a city corresponding to the value of the personâ€™s `bornIn` property. *'Charlie Sheen'*, *'Rob Reiner'* and *'Oliver Stone'* all have a `BORN_IN` relationship to the 'same' `City` node (*'New York'*).

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.bornIn+ | +city+
| +"Charlie Sheen"+ | +"New York"+ | +Node[7]{name:"New York"}+
| +"Martin Sheen"+ | +"Ohio"+ | +Node[8]{name:"Ohio"}+
| +"Michael Douglas"+ | +"New Jersey"+ | +Node[9]{name:"New Jersey"}+
| +"Oliver Stone"+ | +"New York"+ | +Node[7]{name:"New York"}+
| +"Rob Reiner"+ | +"New York"+ | +Node[7]{name:"New York"}+
3+d|Rows: 5 +
Nodes created: 3 +
Relationships created: 5 +
Properties set: 3 +
Labels added: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH (person:Person)
MERGE (city:City {name: person.bornIn})
MERGE (person)-[r:BORN_IN]->(city)
RETURN person.name, person.bornIn, city
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-on-a-relationship-between-an-existing-node-and-a-merged-node-derived-from-a-node-property]]
=== Merge on a relationship between an existing node and a merged node derived from a node property

`MERGE` can be used to simultaneously create both a new node 'n' and a relationship between a bound node 'm' and 'n'.


.Query
[source, cypher]
----
MATCH (person:Person)
MERGE (person)-[r:HAS_CHAUFFEUR]->(chauffeur:Chauffeur {name: person.chauffeurName})
RETURN person.name, person.chauffeurName, chauffeur
----

As `MERGE` found no matches -- in our example graph, there are no nodes labeled with `Chauffeur` and no `HAS_CHAUFFEUR` relationships -- `MERGE` creates five nodes labeled with `Chauffeur`, each of which contains a `name` property whose value corresponds to each matched `Person` node's `chauffeurName` property value.
`MERGE` also creates a `HAS_CHAUFFEUR` relationship between each `Person` node and the newly-created corresponding `Chauffeur` node.
As *'Charlie Sheen'* and *'Michael Douglas'* both have a chauffeur with the same name -- *'John Brown'* -- a new node is created in each case, resulting in 'two' `Chauffeur` nodes having a `name` of *'John Brown'*, correctly denoting the fact that even though the `name` property may be identical, these are two separate people.
This is in contrast to the example shown above in xref:clauses/merge.adoc#merge-merge-on-a-relationship-between-two-existing-nodes[Merge on a relationship between two existing nodes], where we used the first `MERGE` to bind the `City` nodes to prevent them from being recreated (and thus duplicated) in the second `MERGE`.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.chauffeurName+ | +chauffeur+
| +"Charlie Sheen"+ | +"John Brown"+ | +Node[7]{name:"John Brown"}+
| +"Martin Sheen"+ | +"Bob Brown"+ | +Node[8]{name:"Bob Brown"}+
| +"Michael Douglas"+ | +"John Brown"+ | +Node[9]{name:"John Brown"}+
| +"Oliver Stone"+ | +"Bill White"+ | +Node[10]{name:"Bill White"}+
| +"Rob Reiner"+ | +"Ted Green"+ | +Node[11]{name:"Ted Green"}+
3+d|Rows: 5 +
Nodes created: 5 +
Relationships created: 5 +
Properties set: 5 +
Labels added: 5
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MATCH (person:Person)
MERGE (person)-[r:HAS_CHAUFFEUR]->(chauffeur:Chauffeur {name: person.chauffeurName})
RETURN person.name, person.chauffeurName, chauffeur
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[query-merge-using-unique-constraints]]
== Using unique constraints with `MERGE`

Cypher prevents getting conflicting results from `MERGE` when using patterns that involve unique constraints.
In this case, there must be at most one node that matches that pattern.

For example, given two unique constraints on `:Person(id)` and `:Person(ssn)`, a query such as `MERGE (n:Person {id: 12, ssn: 437})` will fail, if there are two different nodes (one with `id` 12 and one with `ssn` 437) or if there is only one node with only one of the properties.
In other words, there must be exactly one node that matches the pattern, or no matching nodes.

Note that the following examples assume the existence of unique constraints that have been created using:

[source,cypher]
----
CREATE CONSTRAINT ON (n:Person) ASSERT n.name IS UNIQUE;
CREATE CONSTRAINT ON (n:Person) ASSERT n.role IS UNIQUE;
----

[[merge-merge-using-unique-constraints-creates-a-new-node-if-no-node-is-found]]
=== Merge using unique constraints creates a new node if no node is found

Merge using unique constraints creates a new node if no node is found.


.Query
[source, cypher]
----
MERGE (laurence:Person {name: 'Laurence Fishburne'})
RETURN laurence.name
----

The query creates the *'laurence'* node.
If *'laurence'* had already existed, `MERGE` would just match the existing node.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +laurence.name+
| +"Laurence Fishburne"+
1+d|Rows: 1 +
Nodes created: 1 +
Properties set: 1 +
Labels added: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (laurence:Person {name: 'Laurence Fishburne'})
RETURN laurence.name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-using-unique-constraints-matches-an-existing-node]]
=== Merge using unique constraints matches an existing node

Merge using unique constraints matches an existing node.


.Query
[source, cypher]
----
MERGE (oliver:Person {name: 'Oliver Stone'})
RETURN oliver.name, oliver.bornIn
----

The *'oliver'* node already exists, so `MERGE` just matches it.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +oliver.name+ | +oliver.bornIn+
| +"Oliver Stone"+ | +"New York"+
2+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (oliver:Person {name: 'Oliver Stone'})
RETURN oliver.name, oliver.bornIn
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-with-unique-constraints-and-partial-matches]]
=== Merge with unique constraints and partial matches

Merge using unique constraints fails when finding partial matches.


.Query
[source, cypher]
----
MERGE (michael:Person {name: 'Michael Douglas', role: 'Gordon Gekko'})
                #RETURN michael
----

While there is a matching unique *'michael'* node with the name *'Michael Douglas'*, there is no unique node with the role of *'Gordon Gekko'* and `MERGE` fails to match.

.Error message
[source]
----
Merge did not find a matching node michael and can not create a new node due to
conflicts with existing unique nodes
----

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (michael:Person {name: 'Michael Douglas', role: 'Gordon Gekko'})
                #RETURN michael
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

If we want to give Michael Douglas the role of Gordon Gekko, we can use the `SET` clause instead:


.Query
[source, cypher]
----
MERGE (michael:Person {name: 'Michael Douglas'})
SET michael.role = 'Gordon Gekko'
----

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (michael:Person {name: 'Michael Douglas'})
SET michael.role = 'Gordon Gekko'
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-merge-with-unique-constraints-and-conflicting-matches]]
=== Merge with unique constraints and conflicting matches

Merge using unique constraints fails when finding conflicting matches.


.Query
[source, cypher]
----
MERGE (oliver:Person {name: 'Oliver Stone', role: 'Gordon Gekko'})
RETURN oliver
----

While there is a matching unique *'oliver'* node with the name *'Oliver Stone'*, there is also another  unique node with the role of *'Gordon Gekko'* and `MERGE` fails to match.

.Error message
[source]
----
Merge did not find a matching node oliver and can not create a new node due to
conflicts with existing unique nodes
----

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (oliver:Person {name: 'Oliver Stone', role: 'Gordon Gekko'})
RETURN oliver
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[merge-using-map-parameters-with-merge]]
=== Using map parameters with `MERGE`

`MERGE` does not support map parameters the same way `CREATE` does.
To use map parameters with `MERGE`, it is necessary to explicitly use the expected properties, such as in the following example.
For more information on parameters, see xref:syntax/parameters.adoc[].


.Parameters
[source,javascript]
----
{
  "param" : {
    "name" : "Keanu Reeves",
    "role" : "Neo"
  }
}
----


.Query
[source, cypher]
----
MERGE (person:Person {name: $param.name, role: $param.role})
RETURN person.name, person.role
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +person.role+
| +"Keanu Reeves"+ | +"Neo"+
2+d|Rows: 1 +
Nodes created: 1 +
Properties set: 2 +
Labels added: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE CONSTRAINT ON (person:Person) ASSERT person.name IS UNIQUE
CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person  {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person  {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person     {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie           {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)

]]></database><command><![CDATA[
MERGE (person:Person {name: $param.name, role: $param.role})
RETURN person.name, person.role
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

