:description: The `MERGE` clause ensures that a pattern exists in the graph.

[[query-merge]]
= MERGE

[abstract]
--
The `MERGE` clause ensures that a pattern exists in the graph.
Either the pattern already exists, or it needs to be created.
--

* xref::clauses/merge.adoc#query-merge-introduction[Introduction]
* xref::clauses/merge.adoc#query-merge-node-derived[Merge nodes]
** xref::clauses/merge.adoc#merge-merge-single-node-with-a-label[Merge single node with a label]
** xref::clauses/merge.adoc#merge-merge-single-node-with-properties[Merge single node with properties]
** xref::clauses/merge.adoc#merge-merge-single-node-specifying-both-label-and-property[Merge single node specifying both label and property]
** xref::clauses/merge.adoc#merge-merge-single-node-derived-from-an-existing-node-property[Merge single node derived from an existing node property]
* xref::clauses/merge.adoc#query-merge-on-create-on-match[Use `ON CREATE` and `ON MATCH`]
** xref::clauses/merge.adoc#merge-merge-with-on-create[Merge with `ON CREATE`]
** xref::clauses/merge.adoc#merge-merge-with-on-match[Merge with `ON MATCH`]
** xref::clauses/merge.adoc#merge-merge-with-on-create-and-on-match[Merge with `ON CREATE` and `ON MATCH`]
** xref::clauses/merge.adoc#merge-merge-with-on-match-setting-multiple-properties[Merge with `ON MATCH` setting multiple properties]
* xref::clauses/merge.adoc#query-merge-relationships[Merge relationships]
** xref::clauses/merge.adoc#merge-merge-on-a-relationship[Merge on a relationship]
** xref::clauses/merge.adoc#merge-merge-on-multiple-relationships[Merge on multiple relationships]
** xref::clauses/merge.adoc#merge-merge-on-an-undirected-relationship[Merge on an undirected relationship]
** xref::clauses/merge.adoc#merge-merge-on-a-relationship-between-two-existing-nodes[Merge on a relationship between two existing nodes]
** xref::clauses/merge.adoc#merge-merge-on-a-relationship-between-an-existing-node-and-a-merged-node-derived-from-a-node-property[Merge on a relationship between an existing node and a merged node derived from a node property]
* xref::clauses/merge.adoc#query-merge-using-unique-constraints[Using property uniqueness constraints with `MERGE`]
** xref::clauses/merge.adoc#merge-merge-using-unique-constraints-creates-a-new-node-if-no-node-is-found[Merge using property uniqueness constraints creates a new node if no node is found]
** xref::clauses/merge.adoc#merge-merge-using-unique-constraints-matches-an-existing-node[Merge using property uniqueness constraints matches an existing node]
** xref::clauses/merge.adoc#merge-merge-with-unique-constraints-and-partial-matches[Merge with property uniqueness constraints and partial matches]
** xref::clauses/merge.adoc#merge-merge-with-unique-constraints-and-conflicting-matches[Merge with property uniqueness constraints and conflicting matches]
* xref::clauses/merge.adoc#merge-using-map-parameters-with-merge[Using map parameters with `MERGE`]

[[query-merge-introduction]]
== Introduction

`MERGE` either matches existing nodes and binds them, or it creates new data and binds that.
It's like a combination of `MATCH` and `CREATE` that additionally allows you to specify what happens if the data was matched or created.

For example, you can specify that the graph must contain a node for a user with a certain name.
If there isn't a node with the correct name, a new node will be created and its name property set.

[NOTE]
====
For performance reasons, creating a schema index on the label or property is highly recommended when using `MERGE`.
See xref::indexes-for-search-performance.adoc[] for more information.
====

When using `MERGE` on full patterns, the behavior is that either the whole pattern matches, or the whole pattern is created.
`MERGE` will not partially use existing patterns -- it is all or nothing.
If partial matches are needed, this can be accomplished by splitting a pattern up into multiple `MERGE` clauses.

[IMPORTANT]
====
Under concurrent updates, `MERGE` only guarantees existence of the `MERGE` pattern, but not uniqueness.
To guarantee uniqueness of nodes with certain properties, a xref::constraints/index.adoc[property uniqueness constraint] should be used.
See xref::clauses/merge.adoc#query-merge-using-unique-constraints[Using property uniqueness constraints with `MERGE`] to see how `MERGE` can be used in combination with a property uniqueness constraint.
====

As with `MATCH`, `MERGE` can match multiple occurrences of a pattern.
If there are multiple matches, they will all be passed on to later stages of the query.

The last part of `MERGE` is the `ON CREATE` and `ON MATCH`.
These allow a query to express additional changes to the properties of a node or relationship, depending on if the element was matched (`MATCH`) in the database or if it was created (`CREATE`).

== Example graph

The following graph is used for the examples below:

image:graph_merge_clause.svg[]

To recreate the graph, run the following query in an empty Neo4j database:

[source, cypher, role=test-setup]
----
CREATE
  (charlie:Person {name: 'Charlie Sheen', bornIn: 'New York', chauffeurName: 'John Brown'}),
  (martin:Person {name: 'Martin Sheen', bornIn: 'Ohio', chauffeurName: 'Bob Brown'}),
  (michael:Person {name: 'Michael Douglas', bornIn: 'New Jersey', chauffeurName: 'John Brown'}),
  (oliver:Person {name: 'Oliver Stone', bornIn: 'New York', chauffeurName: 'Bill White'}),
  (rob:Person {name: 'Rob Reiner', bornIn: 'New York', chauffeurName: 'Ted Green'}),
  (wallStreet:Movie {title: 'Wall Street'}),
  (theAmericanPresident:Movie {title: 'The American President'}),
  (charlie)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(wallStreet),
  (michael)-[:ACTED_IN]->(wallStreet),
  (martin)-[:ACTED_IN]->(theAmericanPresident),
  (michael)-[:ACTED_IN]->(theAmericanPresident),
  (oliver)-[:ACTED_IN]->(wallStreet),
  (rob)-[:ACTED_IN]->(theAmericanPresident),
  (charlie)-[:FATHER]->(martin)
----

[[query-merge-node-derived]]
== Merge nodes

[[merge-merge-single-node-with-a-label]]
=== Merge single node with a label

Merging a single node with the given label.

.Query
[source, cypher]
----
MERGE (robert:Critic)
RETURN robert, labels(robert)
----

A new node is created because there are no nodes labeled `Critic` in the database.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +robert+ | +labels(robert)+
| +{}+ | +["Critic"]+
|===


[[merge-merge-single-node-with-properties]]
=== Merge single node with properties

Merging a single node with properties where not all properties match any existing node.

.Query
[source, cypher]
----
MERGE (charlie {name: 'Charlie Sheen', age: 10})
RETURN charlie
----

A new node with the name `'Charlie Sheen'` will be created since not all properties matched the existing `'Charlie Sheen'` node.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +charlie+
| +{"name":"Charlie Sheen","age":10}+
|===


[[merge-merge-single-node-specifying-both-label-and-property]]
=== Merge single node specifying both label and property

Merging a single node with both label and property matching an existing node.

.Query
[source, cypher]
----
MERGE (michael:Person {name: 'Michael Douglas'})
RETURN michael.name, michael.bornIn
----

`'Michael Douglas'` will be matched and the `name` and  `bornIn` properties returned.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +michael.name+ | +michael.bornIn+
| +"Michael Douglas"+ | +"New Jersey"+
|===

[[merge-merge-single-node-derived-from-an-existing-node-property]]
=== Merge single node derived from an existing node property

For some property `p` in each bound node in a set of nodes, a single new node is created for each unique value for `p`.

.Query
[source, cypher]
----
MATCH (person:Person)
MERGE (city:City {name: person.bornIn})
RETURN person.name, person.bornIn, city
----

Three nodes labeled `City` are created, each of which contains a `name` property with the value of `'New York'`, `'Ohio'`, and `'New Jersey'`, respectively.
Note that even though the `MATCH` clause results in three bound nodes having the value `'New York'` for the `bornIn` property, only a single `'New York'` node (i.e. a `City` node with a name of `'New York'`) is created.
As the `'New York'` node is not matched for the first bound node, it is created.
However, the newly-created `'New York'` node is matched and bound for the second and third bound nodes.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.bornIn+ | +city+
| +"Charlie Sheen"+ | +"New York"+ | +{name:"New York"}+
| +"Martin Sheen"+ | +"Ohio"+ | +{name:"Ohio"}+
| +"Michael Douglas"+ | +"New Jersey"+ | +{name:"New Jersey"}+
| +"Oliver Stone"+ | +"New York"+ | +{name:"New York"}+
| +"Rob Reiner"+ | +"New York"+ | +{name:"New York"}+
|===


[[query-merge-on-create-on-match]]
== Use `ON CREATE` and `ON MATCH`

[[merge-merge-with-on-create]]
=== Merge with `ON CREATE`

Merge a node and set properties if the node needs to be created.

.Query
[source, cypher, role=test-result-skip]
----
MERGE (keanu:Person {name: 'Keanu Reeves', bornIn: 'Beirut', chauffeurName: 'Eric Brown'})
ON CREATE
  SET keanu.created = timestamp()
RETURN keanu.name, keanu.created
----

The query creates the `Person` node named `Keanu Reeves`, with a `bornIn` property set to `Beirut` and a `chauffeurName` property set to `Eric Brown`.
It also sets a timestamp for the `created` property.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +keanu.name+ | +keanu.created+
| +"Keanu Reeves"+ | +1655200898563+
|===


[[merge-merge-with-on-match]]
=== Merge with `ON MATCH`

Merging nodes and setting properties on found nodes.

.Query
[source, cypher, indent=0]
----
MERGE (person:Person)
ON MATCH
  SET person.found = true
RETURN person.name, person.found
----

The query finds all the `Person` nodes, sets a property on them, and returns them.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +person.found+
| +"Charlie Sheen"+ | +true+
| +"Martin Sheen"+ | +true+
| +"Michael Douglas"+ | +true+
| +"Oliver Stone"+ | +true+
| +"Rob Reiner"+ | +true+
| +"Keanu Reeves"+ | +true+
|===


[[merge-merge-with-on-create-and-on-match]]
=== Merge with `ON CREATE` and `ON MATCH`

.Query
[source, cypher, role=test-result-skip]
----
MERGE (keanu:Person {name: 'Keanu Reeves'})
ON CREATE
  SET keanu.created = timestamp()
ON MATCH
  SET keanu.lastSeen = timestamp()
RETURN keanu.name, keanu.created, keanu.lastSeen
----

Because the `Person` node named `Keanu Reeves` already exists, this query does not create a new node.
Instead, it adds a timestamp on the `lastSeen` property.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +keanu.name+ | +keanu.created+ | +keanu.lastSeen+
| +"Keanu Reeves"+ | +1655200902354+ | +1674655352124+
|===


[[merge-merge-with-on-match-setting-multiple-properties]]
=== Merge with `ON MATCH` setting multiple properties

If multiple properties should be set, simply separate them with commas.

.Query
[source, cypher, role=test-result-skip]
----
MERGE (person:Person)
ON MATCH
  SET
    person.found = true,
    person.lastAccessed = timestamp()
RETURN person.name, person.found, person.lastAccessed
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.found+ | +person.lastAccessed+
| +"Charlie Sheen"+ | +true+ | +1655200903558+
| +"Martin Sheen"+ | +true+ | +1655200903558+
| +"Michael Douglas"+ | +true+ | +1655200903558+
| +"Oliver Stone"+ | +true+ | +1655200903558+
| +"Rob Reiner"+ | +true+ | +1655200903558+
| +"Keanu Reeves"+ | +true+ | +1655200903558+
|===


[[query-merge-relationships]]
== Merge relationships

[[merge-merge-on-a-relationship]]
=== Merge on a relationship

`MERGE` can be used to match or create a relationship.

.Query
[source, cypher]
----
MATCH
  (charlie:Person {name: 'Charlie Sheen'}),
  (wallStreet:Movie {title: 'Wall Street'})
MERGE (charlie)-[r:ACTED_IN]->(wallStreet)
RETURN charlie.name, type(r), wallStreet.title
----

`'Charlie Sheen'` had already been marked as acting in `'Wall Street'`, so the existing relationship is found and returned.
Note that in order to match or create a relationship when using `MERGE`, at least one bound node must be specified, which is done via the `MATCH` clause in the above example.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +charlie.name+ | +type(r)+ | +wallStreet.title+
| +"Charlie Sheen"+ | +"ACTED_IN"+ | +"Wall Street"+
|===


[[merge-merge-on-multiple-relationships]]
=== Merge on multiple relationships

.Query
[source, cypher]
----
MATCH
  (oliver:Person {name: 'Oliver Stone'}),
  (reiner:Person {name: 'Rob Reiner'})
MERGE (oliver)-[:DIRECTED]->(movie:Movie)<-[:ACTED_IN]-(reiner)
RETURN movie
----

In our example graph, `'Oliver Stone'` and `'Rob Reiner'` have never worked together.
When we try to `MERGE` a "movie between them, Neo4j will not use any of the existing movies already connected to either person.
Instead, a new `'movie'` node is created.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +movie+
| +{}+
|===


[[merge-merge-on-an-undirected-relationship]]
=== Merge on an undirected relationship

`MERGE` can also be used with an undirected relationship.
When it needs to create a new one, it will pick a direction.

.Query
[source, cypher, indent=0]
----
MATCH
  (charlie:Person {name: 'Charlie Sheen'}),
  (oliver:Person {name: 'Oliver Stone'})
MERGE (charlie)-[r:KNOWS]-(oliver)
RETURN r
----

As `'Charlie Sheen'` and `'Oliver Stone'` do not know each other this `MERGE` query will create a `KNOWS` relationship between them.
The direction of the created relationship is arbitrary.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +r+
| +{}+
|===


[[merge-merge-on-a-relationship-between-two-existing-nodes]]
=== Merge on a relationship between two existing nodes

`MERGE` can be used in conjunction with preceding `MATCH` and `MERGE` clauses to create a relationship between two bound nodes `m` and `n`, where `m` is returned by `MATCH` and `n` is created or matched by the earlier `MERGE`.

.Query
[source, cypher]
----
MATCH (person:Person)
MERGE (city:City {name: person.bornIn})
MERGE (person)-[r:BORN_IN]->(city)
RETURN person.name, person.bornIn, city
----

This builds on the example from xref::clauses/merge.adoc#merge-merge-single-node-derived-from-an-existing-node-property[Merge single node derived from an existing node property].
The second `MERGE` creates a `BORN_IN` relationship between each person and a city corresponding to the value of the person’s `bornIn` property.
`'Charlie Sheen'`, `'Rob Reiner'` and `'Oliver Stone'` all have a `BORN_IN` relationship to the _same_ `City` node (`'New York'`).

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.bornIn+ | +city+
| +"Charlie Sheen"+ | +"New York"+ | +{name:"New York"}+
| +"Martin Sheen"+ | +"Ohio"+ | +{name:"Ohio"}+
| +"Michael Douglas"+ | +"New Jersey"+ | +{name:"New Jersey"}+
| +"Oliver Stone"+ | +"New York"+ | +{name:"New York"}+
| +"Rob Reiner"+ | +"New York"+ | +{name:"New York"}+
| +"Keanu Reeves"+ | +"Beirut"+ | +{name:"Beirut"}+
|===


[[merge-merge-on-a-relationship-between-an-existing-node-and-a-merged-node-derived-from-a-node-property]]
=== Merge on a relationship between an existing node and a merged node derived from a node property

`MERGE` can be used to simultaneously create both a new node `n` and a relationship between a bound node `m` and `n`.

.Query
[source, cypher]
----
MATCH (person:Person)
MERGE (person)-[r:HAS_CHAUFFEUR]->(chauffeur:Chauffeur {name: person.chauffeurName})
RETURN person.name, person.chauffeurName, chauffeur
----

As `MERGE` found no matches -- in our example graph, there are no nodes labeled with `Chauffeur` and no `HAS_CHAUFFEUR` relationships -- `MERGE` creates five nodes labeled with `Chauffeur`, each of which contains a `name` property whose value corresponds to each matched `Person` node's `chauffeurName` property value.
`MERGE` also creates a `HAS_CHAUFFEUR` relationship between each `Person` node and the newly-created corresponding `Chauffeur` node.
As `'Charlie Sheen'` and `'Michael Douglas'` both have a chauffeur with the same name -- `'John Brown'` -- a new node is created in each case, resulting in _two_ `Chauffeur` nodes having a `name` of `'John Brown'`, correctly denoting the fact that even though the `name` property may be identical, these are two separate people.
This is in contrast to the example shown above in xref::clauses/merge.adoc#merge-merge-on-a-relationship-between-two-existing-nodes[Merge on a relationship between two existing nodes], where we used the first `MERGE` to bind the `City` nodes to prevent them from being recreated (and thus duplicated) in the second `MERGE`.

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| +person.name+ | +person.chauffeurName+ | +chauffeur+
| +"Charlie Sheen"+ | +"John Brown"+ | +{name:"John Brown"}+
| +"Martin Sheen"+ | +"Bob Brown"+ | +{name:"Bob Brown"}+
| +"Michael Douglas"+ | +"John Brown"+ | +{name:"John Brown"}+
| +"Oliver Stone"+ | +"Bill White"+ | +{name:"Bill White"}+
| +"Rob Reiner"+ | +"Ted Green"+ | +{name:"Ted Green"}+
| +"Keanu Reeves"+ | +"Eric Brown"+ | +{name:"Eric Brown"}+
|===


[[query-merge-using-unique-constraints]]
== Using property uniqueness constraints with `MERGE`

Cypher prevents getting conflicting results from `MERGE` when using patterns that involve property uniqueness constraints.
In this case, there must be at most one node that matches that pattern.

For example, given two property uniqueness constraints on `:Person(id)` and `:Person(ssn)`, a query such as `MERGE (n:Person {id: 12, ssn: 437})` will fail, if there are two different nodes (one with `id` 12 and one with `ssn` 437), or if there is only one node with only one of the properties.
In other words, there must be exactly one node that matches the pattern, or no matching nodes.

Note that the following examples assume the existence of property uniqueness constraints that have been created using:

[source, cypher]
----
CREATE CONSTRAINT FOR (n:Person) REQUIRE n.name IS UNIQUE;
CREATE CONSTRAINT FOR (n:Person) REQUIRE n.role IS UNIQUE;
----


[[merge-merge-using-unique-constraints-creates-a-new-node-if-no-node-is-found]]
=== Merge using property uniqueness constraints creates a new node if no node is found

Merge using property uniqueness constraints creates a new node if no node is found.

.Query
[source, cypher]
----
MERGE (laurence:Person {name: 'Laurence Fishburne'})
RETURN laurence.name
----

The query creates the `'laurence'` node.
If `'laurence'` had already existed, `MERGE` would just match the existing node.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +laurence.name+
| +"Laurence Fishburne"+
|===


[[merge-merge-using-unique-constraints-matches-an-existing-node]]
=== Merge using property uniqueness constraints matches an existing node

Merge using property uniqueness constraints matches an existing node.

.Query
[source, cypher]
----
MERGE (oliver:Person {name: 'Oliver Stone'})
RETURN oliver.name, oliver.bornIn
----

The `'oliver'` node already exists, so `MERGE` just matches it.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +oliver.name+ | +oliver.bornIn+
| +"Oliver Stone"+ | +"New York"+
|===


[[merge-merge-with-unique-constraints-and-partial-matches]]
=== Merge with property uniqueness constraints and partial matches

Merge using property uniqueness constraints fails when finding partial matches.

.Query
[source, cypher, role=test-fail]
----
MERGE (michael:Person {name: 'Michael Douglas', role: 'Gordon Gekko'})
RETURN michael
----

While there is a matching unique `'michael'` node with the name `'Michael Douglas'`, there is no unique node with the role of `'Gordon Gekko'` and `MERGE` fails to match.

.Error message
----
Node already exists with label `Person` and property `name` = 'Michael Douglas'
----

If we want to give Michael Douglas the role of Gordon Gekko, we can use the `SET` clause instead:

.Query
[source, cypher]
----
MERGE (michael:Person {name: 'Michael Douglas'})
SET michael.role = 'Gordon Gekko'
----

.Result
----
Set 1 property
----


[[merge-merge-with-unique-constraints-and-conflicting-matches]]
=== Merge with property uniqueness constraints and conflicting matches

Merge using property uniqueness constraints fails when finding conflicting matches.

.Query
[source, cypher, role=test-fail]
----
MERGE (oliver:Person {name: 'Oliver Stone', role: 'Gordon Gekko'})
RETURN oliver
----

While there is a matching unique `'oliver'` node with the name `'Oliver Stone'`, there is also another  unique node with the role of `'Gordon Gekko'` and `MERGE` fails to match.

.Error message
----
Node already exists with label `Person` and property `name` = 'Oliver Stone'
----

[[merge-using-map-parameters-with-merge]]
=== Using map parameters with `MERGE`

`MERGE` does not support map parameters the same way `CREATE` does.
To use map parameters with `MERGE`, it is necessary to explicitly use the expected properties, such as in the following example.
For more information on parameters, see xref::syntax/parameters.adoc[].

.Parameters
[source,javascript, indent=0]
----
{
  "param": {
    "name": "Keanu Reeves",
    "role": "Neo"
  }
}
----

.Query
[source, cypher, role=test-skip]
----
MERGE (person:Person {name: $param.name, role: $param.role})
RETURN person.name, person.role
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +person.role+
| +"Keanu Reeves"+ | +"Neo"+
|===

