[[query-foreach]]
= FOREACH
:description: The `FOREACH` clause is used to update data within a collection whether components of a path, or result of aggregation. 

[[query-foreach-introduction]]
== Introduction

Lists and paths are key concepts in Cypher.
The `FOREACH` clause can be used to update data, such as executing update commands on elements in a path, or on a list created by aggregation.

The variable context within the `FOREACH` parenthesis is separate from the one outside it.
This means that if you `CREATE` a node variable within a `FOREACH`, you will _not_ be able to use it outside of the foreach statement, unless you match to find it.

Within the `FOREACH` parentheses, you can do any of the updating commands -- `SET`, `REMOVE`, `CREATE`, `MERGE`, `DELETE`, and `FOREACH`.

If you want to execute an additional `MATCH` for each element in a list then the xref:clauses/unwind.adoc[`UNWIND`] clause would be a more appropriate command.

.Graph
["dot", "FOREACH-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Person|name = \'A\'\l}"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "{Person|name = \'B\'\l}"
  ]
  N1 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N2 [
    label = "{Person|name = \'C\'\l}"
  ]
  N2 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "{Person|name = \'D\'\l}"
  ]

----
 

[[foreach-mark-all-nodes-along-a-path]]
== Mark all nodes along a path

This query will set the property `marked` to `true` on all nodes along a path.


.Query
[source, cypher]
----
MATCH p=(start)-[*]->(finish)
WHERE start.name = 'A' AND finish.name = 'D'
FOREACH (n IN nodes(p) | SET n.marked = true)
----

.Result
[role="queryresult",options="footer",cols="1*<m"]
|===
1+|(empty result)
1+d|Rows: 0 +
Properties set: 4
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a:Person {name: 'A'}),
  (b:Person {name: 'B'}),
  (c:Person {name: 'C'}),
  (d:Person {name: 'D'}),
  (a)-[:KNOWS]->(b),
  (b)-[:KNOWS]->(c),
  (c)-[:KNOWS]->(d)

]]></database><command><![CDATA[
MATCH p=(start)-[*]->(finish)
WHERE start.name = 'A' AND finish.name = 'D'
FOREACH (n IN nodes(p) | SET n.marked = true)
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

