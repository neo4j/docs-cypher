[[query-skip]]
= SKIP
:description: `SKIP` defines from which row to start including the rows in the output. 

* xref:clauses/skip.adoc#skip-introduction[Introduction]
* xref:clauses/skip.adoc#skip-first-three-rows[Skip first three rows]
* xref:clauses/skip.adoc#skip-return-middle-rows[Return middle two rows]
* xref:clauses/skip.adoc#skip-using-expression[Using an expression with `SKIP` to return a subset of the rows]

[[skip-introduction]]
== Introduction

By using `SKIP`, the result set will get trimmed from the top.
Please note that no guarantees are made on the order of the result unless the query specifies the `ORDER BY` clause.
`SKIP` accepts any expression that evaluates to a positive integer -- however the expression cannot refer to nodes or relationships.

.Graph
["dot", "SKIP-1.svg", "neoviz", ""]
----
  N0 [
    label = "name = \'A\'\l"
  ]
  N0 -> N4 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "name = \'B\'\l"
  ]
  N2 [
    label = "name = \'C\'\l"
  ]
  N3 [
    label = "name = \'D\'\l"
  ]
  N4 [
    label = "name = \'E\'\l"
  ]

----
 

[[skip-first-three-rows]]
== Skip first three rows

To return a subset of the result, starting from the fourth result, use the following syntax:


.Query
[source, cypher]
----
MATCH (n)
RETURN n.name
ORDER BY n.name
SKIP 3
----

The first three nodes are skipped, and only the last two are returned in the result.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n.name+
| +"D"+
| +"E"+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a {name: 'A'}),
  (b {name: 'B'}),
  (c {name: 'C'}),
  (d {name: 'D'}),
  (e {name: 'E'}),
  (a)-[:KNOWS]->(b),
  (a)-[:KNOWS]->(c),
  (a)-[:KNOWS]->(d),
  (a)-[:KNOWS]->(e)

]]></database><command><![CDATA[
MATCH (n)
RETURN n.name
ORDER BY n.name
SKIP 3
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[skip-return-middle-rows]]
== Return middle two rows

To return a subset of the result, starting from somewhere in the middle, use this syntax:


.Query
[source, cypher]
----
MATCH (n)
RETURN n.name
ORDER BY n.name
SKIP 1
LIMIT 2
----

Two nodes from the middle are returned.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n.name+
| +"B"+
| +"C"+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a {name: 'A'}),
  (b {name: 'B'}),
  (c {name: 'C'}),
  (d {name: 'D'}),
  (e {name: 'E'}),
  (a)-[:KNOWS]->(b),
  (a)-[:KNOWS]->(c),
  (a)-[:KNOWS]->(d),
  (a)-[:KNOWS]->(e)

]]></database><command><![CDATA[
MATCH (n)
RETURN n.name
ORDER BY n.name
SKIP 1
LIMIT 2
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[skip-using-expression]]
== Using an expression with `SKIP` to return a subset of the rows

Skip accepts any expression that evaluates to a positive integer as long as it is not referring to any external variables:


.Query
[source, cypher]
----
MATCH (n)
RETURN n.name
ORDER BY n.name
SKIP 1 + toInteger(3*rand())
----

Skip the firs row plus randomly 0, 1, or 2. So randomly skip 1, 2, or 3 rows.

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n.name+
| +"D"+
| +"E"+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (a {name: 'A'}),
  (b {name: 'B'}),
  (c {name: 'C'}),
  (d {name: 'D'}),
  (e {name: 'E'}),
  (a)-[:KNOWS]->(b),
  (a)-[:KNOWS]->(c),
  (a)-[:KNOWS]->(d),
  (a)-[:KNOWS]->(e)

]]></database><command><![CDATA[
MATCH (n)
RETURN n.name
ORDER BY n.name
SKIP 1 + toInteger(3*rand())
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

