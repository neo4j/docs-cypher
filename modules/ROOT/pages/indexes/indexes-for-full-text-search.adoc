:description: This chapter describes how to use full-text indexes, to enable full-text search.

[[indexes-fulltext-search]]
= Full-text search indexes

A full-text index is used to index nodes and relationships by `STRING` properties.
Unlike xref:indexes/indexes-for-search-performance.adoc#indexes-create-range-index[range] and xref:indexes/indexes-for-search-performance.adoc#indexes-create-text-index[text] indexes, which can only perform limited `STRING` matching (exact, prefix, substring, or suffix matches), full-text indexes index individual words in any given `STRING` property.
This means that full-text indexes can be used to match within the content of a `STRING` property, which can be very useful to obtain more fine-grained query results.

Full-text indexes are powered by the link:https://lucene.apache.org/[Apache Lucene] indexing and search library.

== Example graph

The following graph is used for the examples below:

To recreate it, run the following query against an empty Neo4j database:

[source, cypher, role=test-setup]
----
CREATE (andersC:Employee {name: "Anders Carlsson", position: "Engineer", team: "Delivery Operations"}),
(bridget:Manager {name: "Bridget Daniels", position: "Manager"}),
(andersE::Employee {name: "Anders Ericsson", position: "Engineer", team: "Administration"}),
(bridget)-[:REVIEWED {feedback: "Anders is often late and must improve soon."}]->(andersC)
(bridget)-[:REVIEWED {feedback: "Anders is never late has improved a lot."}]->(andersE)
(andersC)-[:EMAILED {message:'Hi Bridget. Sorry I have been late. I will try to improve.'}]->(bridget)
----

== Create full-text indexes

Full-text indexes are created with the `CREATE FULLTEXT INDEX` command.
An index can be given a unique name when created (or get a generated one), which is used to reference the specific index when querying or dropping it.
A full-text index applies to a list of labels or a list of relationship types, for node and relationship indexes respectively, and then a list of property names.

Creating a full-text index requires the link:{neo4j-docs-base-uri}/operations-manual/{page-version}/database-administration/standard-databases/manage-databases/#manage-databases-stop/authentication-authorization/database-administration/#access-control-database-administration-index[`CREATE INDEX` privilege].

.Syntax for creating full-text indexes
[options="header", width="100%", cols="5a, 3"]
|===
| Command | Description

| [source, syntax, role=noplay, indent=0]
----
CREATE FULLTEXT INDEX [index_name] [IF NOT EXISTS]
FOR (n:LabelName["\|" ...])
ON EACH "[" n.propertyName[, ...] "]"
[OPTIONS "{" option: value[, ...] "}"]
----
| Create a full-text index on nodes.

| [source, syntax, role=noplay, indent=0]
----
CREATE FULLTEXT INDEX [index_name] [IF NOT EXISTS]
FOR ()-"["r:TYPE_NAME["\|" ...]"]"-()
ON EACH "[" r.propertyName[, ...] "]"
[OPTIONS "{" option: value[, ...] "}"]
----
| Create a full-text index on relationships.

|===

This query creates a full-text index named `titlesAndDescriptions` on each `title` and `description` property for all `Movie` and `Book` nodes in the graph:

.Query
[source, cypher]
----
CREATE FULLTEXT INDEX positionAndTeams FOR (n:Employee|Manager) ON EACH [n.position, n.team]
----

This query highlights two key differences between full-text and xref:indexes/indexes-for-search-performance.adoc[]:

* Full-text indexes can be applied to more than one node label.
* Full-text indexes can be applied to more than one property, but unlike xref:indexes/indexes-for-search-performance.adoc#indexes-create-a-composite-range-index-for-nodes[composite search performance indexes], a full-text index indexes entities that have _at least_ one of the indexed labels or relationship types, and _at least_ one of the indexed properties.

Similarly, though a relationship can only have one type, a full-text index can index multiple relationship types, and all relationships will be included that match one of the relationship types, and at least one of the indexed properties.

Full-text indexes follow the same naming rules and best-practices as search performance indexes.
More information can be read in the section about xref:indexes/index.adoc#naming-rules-and-recommendations[Index naming rules].

=== Tokenization and analyzers

As previously mentioned, full-text indexes index individual words in a `STRING` property.
This is achieved by tokenizer, which breaks up a stream of characters (usually individual words) into individual tokens.
How a string is tokenized is determined by what analyzer the full-text index is configured with.
For example, the _swedish_ analyzer knows how to tokenize Swedish words, and will avoid indexing Swedish stop words.

A complete list of all available analyzers is included in the result of the link:{neo4j-docs-base-uri}/operations-manual/{page-version}/reference/procedures/#procedure_db_index_fulltext_listavailableanalyzers[`db.index.fulltext.listAvailableAnalyzers`] procedure.

=== Configuration settings

The `CREATE FULLTEXT INDEX` command take an optional clause, called `options`.
This has two parts, the `indexProvider` and `indexConfig`.
The provider can only have the default value, `'fulltext-1.0'`.
The `indexConfig` is a map from string to string and booleans, and can be used to set index-specific configuration settings.

The `fulltext.analyzer` setting can be used to configure an index-specific analyzer.
The possible values for the `fulltext.analyzer` setting can be listed with the `db.index.fulltext.listAvailableAnalyzers` procedure.

The `fulltext.eventually_consistent` setting, if set to `true`, will put the index in an _eventually consistent_ update mode.
This means that updates will be applied in a background thread "as soon as possible", instead of during transaction commit like other indexes.

In the below example, an eventually consistent relationship full-text index is created for the `EMAILED` relationship type, and the `message` property, and the index uses the `url_or_email` analyzer.
This could, for instance, be a system where people are assigning tags to documents, and where the index on the `taggedByUser` property will allow them to quickly find all of the documents they have tagged.
Had it not been for the relationship index, one would have had to add artificial connective nodes between the tags and the documents in the data model, just so these nodes could be indexed.

.Query
[source, cypher]
----
CREATE FULLTEXT INDEX emails FOR ()-[r:EMAILED]-() ON EACH [r.message]
OPTIONS {
  indexConfig: {
    `fulltext.analyzer`: 'url_or_email',
    `fulltext.eventually_consistent`: true
  }
}
----

For more information on how to configure full-text indexes, refer to the link:{neo4j-docs-base-uri}/operations-manual/{page-version}/performance/index-configuration#index-configuration-fulltext[Operations Manual -> Indexes to support full-text search].

== Querying full-text indexes

To query a full-text index, use either the link:{neo4j-docs-base-uri}/operations-manual/{page-version}/reference/procedures/#procedure_db_index_fulltext_querynodes[`db.index.fulltext.queryNodes`] or the link:{neo4j-docs-base-uri}/operations-manual/{page-version}/reference/procedures/#procedure_db_index_fulltext_relationships[`db.index.fulltext.queryRelationships`] procedures.


This query uses the `db.index.fulltext.queryNodes` to query the previously created full-text index for any titles and descriptions `STRING` properties in the graph containing "matrix":

.Query
[source, cypher]
----
CALL db.index.fulltext.queryNodes("titlesAndDescriptions", "matrix") YIELD node, score
RETURN node.title, node.description, score
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===

| node.title | node.description | score
| "The Matrix" | <null> | 0.13076457381248474
3+d|Rows: 1

|===


In addition to any exact matches, full-text indexes also return _approximate_ matches to a given query.
Both the property values that are indexed, and the queries to the index, are processed through the analyzer such that the index can find data entities which do not exactly match the provided string.
The `score` that is returned alongside each result entry, represents how well the index thinks that entry matches the given query.
The results are always returned in _descending score order_, where the best matching result entry is put first.


To illustrate, in the example below, we search our movie database for `"Full Metal Jacket"`, and even though there is an exact match as the first result, we also get three other less interesting results:

.Query
[source, cypher]
----
CALL db.index.fulltext.queryNodes("titlesAndDescriptions", "Full Metal Jacket") YIELD node, score
RETURN node.title, score
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| +node.title+ | +score+
| +"Full Metal Jacket"+ | +1.411118507385254+
| +"Full Moon High"+ | +0.44524085521698+
| +"Yellow Jacket"+ | +0.3509605824947357+
| +"The Jacket"+ | +0.3509605824947357+
2+d|Rows: 4

|===

To only obtain exact matches, can quote the string you are searching for.

.Query
[source, cypher]
----
CALL db.index.fulltext.queryNodes("titlesAndDescriptions", '"Full Metal Jacket"') YIELD node, score
RETURN node.title, score
----

When we put "Full Metal Jacket" in quotes, Lucene only gives us exact matches:

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +node.title+ | +score+
| +"Full Metal Jacket"+ | +1.411118507385254+
2+d|Rows: 1
|===

Lucene also allows the use of logical operators, such as `AND` and `OR`, to search for terms.

.Query
[source, cypher]
----
CALL db.index.fulltext.queryNodes("titlesAndDescriptions", 'full AND metal') YIELD node, score
RETURN node.title, score
----

Only the `Full Metal Jacket` movie in our database has both the words `full` and `metal`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| +node.title+ | +score+
| +"Full Metal Jacket"+ | +1.1113792657852173+
2+d|Rows: 1

|===


It is possible to limit the search to specific properties, by putting the property name and a colon in front of the text being searched for.


.Query
[source, cypher, indent=0]
----
CALL db.index.fulltext.queryNodes("titlesAndDescriptions", 'description:"surreal adventure"') YIELD node, score
RETURN node.title, node.description, score
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===

| +node.title+ | +node.description+ | +score+
| +"Metallica Through The Never"+ | +"The movie follows the young roadie Trip through his surreal adventure with the band."+ | +0.2615291476249695+
3+d|Rows: 1

|===

A complete description of the Lucene query syntax can be found in the link:https://lucene.apache.org/core/8_2_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description[Lucene documentation].


[[indexes-fulltext-search-text-array-properties]]
=== Text Array properties

If the indexed property contains a text array, each element of this array is analyzed independently and all produced terms are associated with the same property name.
This means that when querying such an indexed node or relationship, there is a match if any of the array elements match the query.
For scoring purposes, the full-text index treats it as a single-property value, and the score will represent how close the query is to matching the entire array.


For example, both of the following queries match the same node while referring different elements:

.Query
[source, cypher]
----
CALL db.index.fulltext.queryNodes('reviews', 'best') YIELD node, score
RETURN
  node.title AS title,
  node.reviews AS reviews,
  score
----


.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===

| +title+ | +reviews+ | +score+ 
| +'The Matrix'+ | +['The best movie ever.', 'The movie is nonsense.']+ | + 0.13076457381248474 +

3+d|Rows: 1

|===

.Query
[source, cypher]
----
CALL db.index.fulltext.queryNodes("reviews", 'nonsense') YIELD node, score
RETURN
  node.title AS title,
  node.reviews AS reviews,
  score
----

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===

| +title+ | +reviews+ | +score+ 
| +'The Matrix'+ | +['The best movie ever.', 'The movie is nonsense.']+ | + 0.13076457381248474 +

3+d|Rows: 1

|===

== List full-text indexes 



[[indexes-fulltext-search-drop]]
== Drop full-text indexes

A full-text node index is dropped by using the xref:indexes/indexes-for-search-performance.adoc#indexes-drop-an-index[same command as for other indexes], `DROP INDEX`.

In the following example, we will drop the `taggedByRelationshipIndex` that we created previously:

.Query
[source, cypher]
----
DROP INDEX taggedByRelationshipIndex
----



[[indexes-fulltext-search-manage]]
== List of procedures

Full-text indexes are managed through commands and used through built-in procedures, see link:{neo4j-docs-base-uri}/operations-manual/{page-version}/reference/procedures[Operations Manual -> Procedures] for a complete reference.

The procedures for full-text indexes are listed in the table below:

[options="header"]
|===
| Usage | Procedure/Command | Description

| List available analyzers.
| https://neo4j.com/docs/operations-manual/current/reference/procedures/#procedure_db_index_fulltext_listavailableanalyzers[`db.index.fulltext.listAvailableAnalyzers`]
| List the available analyzers that the full-text indexes can be configured with.

| Use full-text node index.
| https://neo4j.com/docs/operations-manual/current/reference/procedures/#procedure_db_index_fulltext_querynodes[`db.index.fulltext.queryNodes`]
| Query the given full-text index. Returns the matching nodes and their Lucene query score, ordered by score.

| Use full-text relationship index.
| https://neo4j.com/docs/operations-manual/current/reference/procedures/#procedure_db_index_fulltext_queryrelationships[`db.index.fulltext.queryRelationships`]
| Query the given full-text index. Returns the matching relationships and their Lucene query score, ordered by score.

| Eventually consistent indexes.
| https://neo4j.com/docs/operations-manual/current/reference/procedures/#procedure_db_index_fulltext_awaiteventuallyconsistentindexrefresh[`db.index.fulltext.awaitEventuallyConsistentIndexRefresh`]
| Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.


|===


== Rules

The following is true for full-text indexes:

* Full-text indexes support the indexing of both nodes and relationships.
* Full-text indexes support configuring custom analyzers, including analyzers that are not included with Lucene itself.
* Full-text indexes can be queried using the Lucene query language.
* Full-text indexes can return the _score_ for each result from a query.
* Full-text indexes are kept up to date automatically, as nodes and relationships are added, removed, and modified.
* Full-text indexes will automatically populate newly created indexes with the existing data in a store.
* Full-text indexes can be checked by the consistency checker, and they can be rebuilt if there is a problem with them.
* Full-text indexes are a projection of the store, and can only index nodes and relationships by the contents of their properties.
* Full-text indexes include only property values of types `STRING` or `LIST<STRING>`.
* Full-text indexes can support any number of documents in a single index.
* Full-text indexes are created, dropped, and updated transactionally, and are automatically replicated throughout a cluster.
* Full-text indexes can be accessed via Cypher procedures.
* Full-text indexes can be configured to be _eventually consistent_, in which index updating is moved from the commit path to a background thread.
Using this feature, it is possible to work around the slow Lucene writes from the performance critical commit process, thus removing the main bottlenecks for Neo4j write performance.