:description: Query options available in Cypher.

[[cypher-query-options]]
= Cypher query options

[abstract]
--
This section describes the query options available in Cypher.
--

Query execution can be fine-tuned through the use of query options.
In order to use one or more of these options, the query must be prepended with `CYPHER`, followed by the query option(s), as exemplified thus: `CYPHER query-option [further-query-options] query`.


[[cypher-version]]
== Cypher version

Occasionally, there is a requirement to use a previous version of the Cypher compiler when running a query.

Here we detail the available versions:

[options="header",cols="1m,3a,^1a"]
|===
| Query option | Description | Default

| 3.5
| This will force the query to use Neo4j Cypher 3.5.
|

| 4.2
| This will force the query to use Neo4j Cypher 4.2.
|

| 4.3
| This will force the query to use Neo4j Cypher 4.3.
| 

| 4.4
|
This will force the query to use Neo4j Cypher 4.4.
As this is the default version, it is not necessary to use this option explicitly.

| {check-mark}

|===


[WARNING]
====
In Neo4j {neo4j-version}, the support for Cypher 3.5 is provided only at the parser level.
The consequence is that some underlying features available in Neo4j 3.5 are no longer available and will result in runtime errors.

Please refer to the discussion in xref::deprecations-additions-removals-compatibility.adoc#cypher-compatibility[Cypher Compatibility] for more information on which features are affected.
====


[[cypher-runtime]]
== Cypher runtime

Using the execution plan, the query is executed -- and records returned -- by the Cypher _runtime_.
Depending on whether Neo4j Enterprise Edition or Neo4j Community Edition is used, there are three different runtimes available:

Interpreted::
In this runtime, the operators in the execution plan are chained together in a tree, where each non-leaf operator feeds from one or two child operators.
The tree thus comprises nested iterators, and the records are streamed in a pipelined manner from the top iterator, which pulls from the next iterator and so on.

[enterprise-edition]#Slotted#::
This is very similar to the interpreted runtime, except that there are additional optimizations regarding the way in which the records are streamed through the iterators.
This results in improvements to both the performance and memory usage of the query.
In effect, this can be thought of as the 'faster interpreted' runtime.

[enterprise-edition]#Pipelined#::
The pipelined runtime was introduced in Neo4j 4.0 as a replacement for the older compiled runtime used in the Neo4j 3.x versions.
It combines some of the advantages of the compiled runtime in a new architecture that allows for support of a wider range of queries.
+
Algorithms are employed to intelligently group the operators in the execution plan in order to generate new combinations and orders of execution which are optimised for performance and memory usage.
While this should lead to superior performance in most cases (over both the interpreted and slotted runtimes), it is still under development and does not support all possible operators or queries (the slotted runtime covers all operators and queries).

[options="header",cols="2m,2a,^1a"]
|===
| Option | Description | Default

| runtime=interpreted
| This will force the query planner to use the interpreted runtime.
|
This is not used in Enterprise Edition unless explicitly asked for.
It is the only option for all queries in Community Edition--it is not necessary to specify this option in Community Edition.

| [enterprise-edition]#runtime=slotted#
| This will cause the query planner to use the slotted runtime.
| This is the default option for all queries which are not supported by `runtime=pipelined` in Enterprise Edition.

| [enterprise-edition]#runtime=pipelined#
|
This will cause the query planner to use the pipelined runtime if it supports the query.
If the pipelined runtime does not support the query, the planner will fall back to the slotted runtime.

| This is the default option for some queries in Enterprise Edition.

|===

In Enterprise Edition, the Cypher query planner selects the runtime, falling back to alternative runtimes as follows:

* Try the pipelined runtime first.
* If the pipelined runtime does not support the query, then fall back to use the slotted runtime.
* Finally, if the slotted runtime does not support the query, fall back to the interpreted runtime.
  The interpreted runtime supports all queries, and is the only option in Neo4j Community Edition.


[[cypher-planner]]
== Cypher planner

The Cypher planner takes a Cypher query and computes an execution plan that solves it.
For any given query there is likely a number of execution plan candidates that each solve the query in a different way.
The planner uses a search algorithm to find the execution plan with the lowest estimated execution cost.

This table describes the available planner options:

[options="header",cols="2m,3a,^1a"]
|===
| Query option | Description | Default

| planner=cost
| Use cost based planning with default limits on plan search space and time.
| {check-mark}

| planner=idp
| Synonym for `planner=cost`.
|

| planner=dp
|
Use cost based planning without limits on plan search space and time to perform an exhaustive search for the best execution plan.

[NOTE]
====
Using this option can significantly _increase_ the planning time of the query.
====

|

|===


[[cypher-connect-components-planner]]
== Cypher connect-components planner

One part of the Cypher planner is responsible for combining sub-plans for separate patterns into larger plans - a task referred to as _connecting components_.

This table describes the available query options for the connect-components planner:

[options="header",cols="2m,3a,^1a"]
|===
| Query option | Description | Default

| connectComponentsPlanner=greedy
|
Use a greedy approach when combining sub-plans.

[NOTE]
====
Using this option can significantly _reduce_ the planning time of the query.
====

| 

| connectComponentsPlanner=idp
|
Use the cost based IDP search algorithm when combining sub-plans.

[NOTE]
====
Using this option can significantly _increase_ the planning time of the query but usually finds better plans.
====

| {check-mark}

|===


[[cypher-update-strategy]]
== Cypher update strategy
This option affects the eagerness of updating queries.

The possible values are:

[options="header",cols="2m,3a,^1a"]
|===
| Query option | Description | Default

| updateStrategy=default
| Update queries are executed eagerly when needed.
| {check-mark}

| updateStrategy=eager
| Update queries are always executed eagerly.
|

|===


[[cypher-expression-engine]]
== Cypher expression engine

This option affects how the runtime evaluates expressions.

The possible values are:

[options="header",cols="2m,3a,^1a"]
|===
| Query option | Description | Default

| expressionEngine=default
| Compile expressions and use the compiled expression engine when needed.
| {check-mark}

| expressionEngine=interpreted
| Always use the _interpreted_ expression engine.
|

| expressionEngine=compiled
|
Always compile expressions and use the _compiled_ expression engine.

Cannot be used together with `runtime=interpreted`.

|

|===


[[cypher-operator-engine]]
== Cypher operator engine

This query option affects whether the pipelined runtime attempts to generate compiled code for groups of operators.

The possible values are:

[options="header",cols="2m,3a,^1a"]
|===
| Query option | Description | Default

| operatorEngine=default
| Attempt to generate compiled operators when applicable.
| {check-mark}

| operatorEngine=interpreted
| Never attempt to generate compiled operators.
|

| operatorEngine=compiled
|
Always attempt to generate _compiled_ operators.

Cannot be used together with `runtime=interpreted` or `runtime=slotted`.

|

|===


[[cypher-interpreted-pipes-fallback]]
== Cypher interpreted pipes fallback

This query option affects how the pipelined runtime behaves for operators it does not directly support.

The available options are:

[options="header",cols="2m,3a,^1a"]
|===
| Query option | Description | Default

| interpretedPipesFallback=default
| Equivalent to `interpretedPipesFallback=whitelisted_plans_only`.
| {check-mark}

| interpretedPipesFallback=disabled
|
If the plan contains any operators not supported by the pipelined runtime then another runtime is chosen to execute the entire plan.

Cannot be used together with `runtime=interpreted` or `runtime=slotted`.

|

| interpretedPipesFallback=whitelisted_plans_only
|
Parts of the execution plan can be executed on another runtime.
Only certain operators are allowed to execute on another runtime.

Cannot be used together with `runtime=interpreted` or `runtime=slotted`.

|

| interpretedPipesFallback=all
|
Parts of the execution plan may be executed on another runtime.
Any operator is allowed to execute on another runtime.
Queries with this option set might produce incorrect results, or fail.

Cannot be used together with `runtime=interpreted` or `runtime=slotted`.

[WARNING]
====
This setting is experimental, and using it in a production environment is discouraged.
====

|

|===


[[cypher-replanning]]
== Cypher replanning

Cypher replanning occurs in the following circumstances:

* When the query is not in the cache.
This can either be when the server is first started or restarted, if the cache has recently been cleared, or if xref:4.4@operations-manual:ROOT:reference/configuration-settings/index.adoc#config_dbms.query_cache_size[dbms.query_cache_size] was exceeded.
* When the time has past the xref:4.4@operations-manual:ROOT:reference/configuration-settings/index.adoc#config_cypher.min_replan_interval[cypher.min_replan_interval] value, and the database statistics have changed more than the xref:4.4@operations-manual:ROOT:reference/configuration-settings/index.adoc#config_cypher.statistics_divergence_threshold[cypher.statistics_divergence_threshold] value.

There may be situations where xref::execution-plans/index.adoc[Cypher query planning] can occur at a non-ideal time.
For example, when a query must be as fast as possible and a valid plan is already in place.

[NOTE]
====
Replanning is not performed for all queries at once; it is performed in the same thread as running the query, and can block the query.
However, replanning one query does not replan any other queries.
====

There are three different replan options available:

[options="header",cols="2m,3a,^1a"]
|===
| Option | Description | Default

| replan=default
| This is the planning and replanning option as described above.
| {check-mark}

| replan=force
| This will force a replan, even if the plan is valid according to the planning rules.
Once the new plan is complete, it replaces the existing one in the query cache.
|

| replan=skip
| If a valid plan already exists, it will be used even if the planning rules would normally dictate that it should be replanned.
|

|===

The replan option is prepended to queries.

For example:

[source, cypher, role=noplay, indent=0]
----
CYPHER replan=force MATCH ...
----

In a mixed workload, you can force replanning by using the Cypher `EXPLAIN` commands.
This can be useful to schedule replanning of queries which are expensive to plan, at known times of low load.
Using `EXPLAIN` will make sure the query is only planned, but not executed.

For example:

[source, cypher, role=noplay, indent=0]
----
CYPHER replan=force EXPLAIN MATCH ...
----

During times of known high load, `replan=skip` can be useful to not introduce unwanted latency spikes.

