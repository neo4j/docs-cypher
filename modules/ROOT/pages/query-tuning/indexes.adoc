[[query-tuning-indexes]]
= The use of indexes
:description: This section describes the query plans when indexes are used in various scenarios. 

The task of tuning calls for different indexes depending on what the queries look like.
Therefore, it is important to have a fundamental understanding of how the indexes operate.
This section describes the query plans that result from different index scenarios.

Node indexes and relationship indexes operate in the same way.
Therefore, node and relationship indexes are used interchangeably in this section.

Please refer to xref:indexes-for-search-performance.adoc[] for instructions on how to create and maintain the indexes themselves.


[[administration-indexes-node-index-example]]
== Node index example ==
In the example below, the query uses a `Person(firstname)` node index, if it exists. 

.Query
[source,cypher]
----
MATCH (person:Person {firstname: 'Andy'}) RETURN person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | person                                                   |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +----------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeek  | person:Person(firstname) WHERE firstname = $autostring_0 |              1 |    1 |       2 |             72 |                    2/1 |     0.976 | Fused in Pipeline 0 |
+-----------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----

[[administration-indexes-relationship-index-example]]
== Relationship index example ==
In this example, the query uses a `KNOWS(since)` relationship index, if it exists. 

.Query
[source,cypher]
----
MATCH (person)-[relationship:KNOWS { since: 1992 } ]->(friend) RETURN person, friend
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+--------------------------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                       | Details                                                                 | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+--------------------------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                | person, friend                                                          |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                              +-------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +DirectedRelationshipIndexSeek | (person)-[relationship:KNOWS(since)]->(friend) WHERE since = $autoint_0 |              1 |    1 |       3 |             72 |                    2/1 |     0.473 | Fused in Pipeline 0 |
+--------------------------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 136

----

[[administration-indexes-equality-check-using-where-single-property-index]]
== Equality check using `WHERE` (single-property index) ==
A query containing equality comparisons of a single indexed property in the `WHERE` clause is backed automatically by the index. It is also possible for a query with multiple `OR` predicates to use multiple indexes, if indexes exist on the properties. For example, if indexes exist on both `:Label(p1)` and `:Label(p2)`, `MATCH (n:Label) WHERE n.p1 = 1 OR n.p2 = 2 RETURN n` will use both indexes. 

.Query
[source,cypher]
----
MATCH (person:Person) WHERE person.firstname = 'Andy' RETURN person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                  | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | person                                                   |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +----------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeek  | person:Person(firstname) WHERE firstname = $autostring_0 |              1 |    1 |       2 |             72 |                    2/1 |     0.514 | Fused in Pipeline 0 |
+-----------------+----------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----

[[administration-indexes-equality-check-using-where-composite-index]]
== Equality check using `WHERE` (composite index) ==
A query containing equality comparisons for all the properties of a composite index will automatically be backed by the same index. However, the query does not need to have equality on all properties. It can have ranges and existence predicates as well. But in these cases rewrites might happen depending on which properties have which predicates, see xref:indexes-for-search-performance.adoc#administration-indexes-single-vs-composite-index[composite index limitations]. The following query will use the composite index defined xref:indexes-for-search-performance.adoc#administration-indexes-create-a-composite-index-for-nodes[earlier]: 

.Query
[source,cypher]
----
MATCH (n:Person) WHERE n.age = 35 AND n.country = 'UK' RETURN n
----


However, the query `MATCH (n:Person) WHERE n.age = 35 RETURN n` will not be backed by the composite index, as the query does not contain a predicate on the `country` property. It will only be backed by an index on the `Person` label and `age` property defined thus: `:Person(age)`; i.e. a single-property index. 

.Result
[queryresult]
----
+-------------------------------------------------------------------------------------------+
| n                                                                                         |
+-------------------------------------------------------------------------------------------+
| Node[0]{country:"UK",firstname:"John",highScore:54321,surname:"Smith",name:"john",age:35} |
+-------------------------------------------------------------------------------------------+
1 row
----


.Try this query live
[console]
----
create index `index_58a1c03e` for (n:`Person`) ON (n.`location`);
create index `index_d7c12ba3` for (n:`Person`) ON (n.`highScore`);
create index `index_deeafdb2` for (n:`Person`) ON (n.`firstname`);
create (_0:`Person` {`age`:35, `country`:"UK", `firstname`:"John", `highScore`:54321, `name`:"john", `surname`:"Smith"})
create (_1:`Person` {`age`:40, `country`:"Sweden", `firstname`:"Andy", `highScore`:12345, `name`:"andy", `surname`:"Jones"})
create (_2:`Person`)
create (_3:`Person`)
create (_4:`Person`)
create (_5:`Person`)
create (_6:`Person`)
create (_7:`Person`)
create (_8:`Person`)
create (_9:`Person`)
create (_10:`Person`)
create (_11:`Person`)
create (_12:`Person`)
create (_13:`Person`)
create (_14:`Person`)
create (_15:`Person`)
create (_16:`Person`)
create (_17:`Person`)
create (_18:`Person`)
create (_19:`Person`)
create (_20:`Person`)
create (_21:`Person`)
create (_22:`Person`)
create (_23:`Person`)
create (_24:`Person`)
create (_25:`Person`)
create (_26:`Person`)
create (_27:`Person`)
create (_28:`Person`)
create (_29:`Person`)
create (_30:`Person`)
create (_31:`Person`)
create (_32:`Person`)
create (_33:`Person`)
create (_34:`Person`)
create (_35:`Person`)
create (_36:`Person`)
create (_37:`Person`)
create (_38:`Person`)
create (_39:`Person`)
create (_40:`Person`)
create (_41:`Person`)
create (_42)
create (_43)
create (_1)-[:`KNOWS`]->(_0)
create (_2)-[:`KNOWS`]->(_3)
create (_4)-[:`KNOWS`]->(_5)
create (_6)-[:`KNOWS`]->(_7)
create (_8)-[:`KNOWS`]->(_9)
create (_10)-[:`KNOWS`]->(_11)
create (_12)-[:`KNOWS`]->(_13)
create (_14)-[:`KNOWS`]->(_15)
create (_16)-[:`KNOWS`]->(_17)
create (_18)-[:`KNOWS`]->(_19)
create (_20)-[:`KNOWS`]->(_21)
create (_22)-[:`KNOWS`]->(_23)
create (_24)-[:`KNOWS`]->(_25)
create (_26)-[:`KNOWS`]->(_27)
create (_28)-[:`KNOWS`]->(_29)
create (_30)-[:`KNOWS`]->(_31)
create (_32)-[:`KNOWS`]->(_33)
create (_34)-[:`KNOWS`]->(_35)
create (_36)-[:`KNOWS`]->(_37)
create (_38)-[:`KNOWS`]->(_39)
create (_40)-[:`KNOWS`]->(_41)
create (_42)-[:`KNOWS` {`lastMet`:2021, `lastMetIn`:"Stockholm", `metIn`:"Malmo", `since`:1992}]->(_43)
;


MATCH (n:Person) WHERE n.age = 35 AND n.country = 'UK' RETURN n
----


[[administration-indexes-range-comparisons-using-where-single-property-index]]
== Range comparisons using `WHERE` (single-property index) ==
Single-property indexes are also automatically used for inequality (range) comparisons of an indexed property in the `WHERE` clause.

.Query
[source,cypher]
----
MATCH (friend)<-[r:KNOWS]-(person) WHERE r.since < 2011 RETURN friend, person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+---------------------------------------+--------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                              | Details                                                      | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+---------------------------------------+--------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                       | friend, person                                               |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                                     +--------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +DirectedRelationshipIndexSeekByRange | (person)-[r:KNOWS(since)]->(friend) WHERE since < $autoint_0 |              1 |    1 |       3 |             72 |                    2/1 |     0.543 | Fused in Pipeline 0 |
+---------------------------------------+--------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 136

----

[[administration-indexes-range-comparisons-using-where-composite-index]]
== Range comparisons using `WHERE` (composite index) ==
Composite indexes are also automatically used for inequality (range) comparisons of indexed properties in the `WHERE` clause. Equality or list membership check predicates may precede the range predicate. However, predicates after the range predicate may be rewritten as an existence check predicate and a filter as described in xref:indexes-for-search-performance.adoc#administration-indexes-single-vs-composite-index[composite index limitations].

.Query
[source,cypher]
----
MATCH ()-[r:KNOWS]-() WHERE r.since < 2011 AND r.lastMet > 2019 RETURN r.since
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+----------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                         | Details                                                                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+----------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                  | `r.since`                                                                                            |              4 |    2 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                                +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +Projection                      | cache[r.since] AS `r.since`                                                                          |              4 |    2 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                                +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +Filter                          | cache[r.lastMet] > $autoint_1                                                                        |              4 |    2 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                                +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +UndirectedRelationshipIndexSeek | (anon_0)-[r:KNOWS(since, lastMet)]-(anon_1) WHERE since < $autoint_0 AND lastMet IS NOT NULL, cache[ |              7 |    2 |       3 |             72 |                    1/1 |     1.207 | Fused in Pipeline 0 |
|                                  | r.since], cache[r.lastMet]                                                                           |                |      |         |                |                        |           |                     |
+----------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 136

----

[[administration-indexes-multiple-range-comparisons-using-where-single-property-index]]
== Multiple range comparisons using `WHERE` (single-property index) ==
When the `WHERE` clause contains multiple inequality (range) comparisons for the same property, these can be combined in a single index range seek.

.Query
[source,cypher]
----
MATCH (person:Person) WHERE 10000 < person.highScore < 20000 RETURN person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator              | Details                                                                          | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults       | person                                                                           |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                     +----------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeekByRange | person:Person(highScore) WHERE highScore > $autoint_0 AND highScore < $autoint_1 |              1 |    1 |       2 |             72 |                    2/1 |     0.471 | Fused in Pipeline 0 |
+-----------------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----

[[administration-indexes-multiple-range-comparisons-using-where-composite-index]]
== Multiple range comparisons using `WHERE` (composite index) ==
When the `WHERE` clause contains multiple inequality (range) comparisons for the same property, these can be combined in a single index range seek. That single range seek created in the following query will then use the composite index `Person(highScore, name)` if it exists.

.Query
[source,cypher]
----
MATCH (person:Person) WHERE 10000 < person.highScore < 20000 AND person.name IS NOT NULL RETURN
  person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | person                                                                                               |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeek  | person:Person(highScore, name) WHERE highScore > $autoint_0 AND highScore < $autoint_1 AND name IS N |              1 |    1 |       2 |             72 |                    2/1 |    13.696 | Fused in Pipeline 0 |
|                 | OT NULL                                                                                              |                |      |         |                |                        |           |                     |
+-----------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----

[[administration-indexes-list-membership-check-using-in-single-property-index]]
== List membership check using `IN` (single-property index) ==
The `IN` predicate on `r.since` in the following query will use the single-property index `KNOWS(since)` if it exists. 

.Query
[source,cypher]
----
MATCH (person)-[r:KNOWS]->(friend) WHERE r.since IN [1992, 2017] RETURN person, friend
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+--------------------------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                       | Details                                                        | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+--------------------------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                | person, friend                                                 |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                              +----------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +DirectedRelationshipIndexSeek | (person)-[r:KNOWS(since)]->(friend) WHERE since IN $autolist_0 |              1 |    1 |       4 |             72 |                    3/1 |     1.206 | Fused in Pipeline 0 |
+--------------------------------+----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 4, total allocated memory: 136

----

[[administration-indexes-list-membership-check-using-in-composite-index]]
== List membership check using `IN` (composite index) ==
The `IN` predicates on `r.since` and `r.lastMet` in the following query will use the composite index `KNOWS(since, lastMet)` if it exists. 

.Query
[source,cypher]
----
MATCH (person)-[r:KNOWS]->(friend) WHERE r.since IN [1992, 2017] AND r.lastMet IN [2002,
  2021] RETURN person, friend
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+--------------------------------+----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                       | Details                                                                                            | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+--------------------------------+----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                | person, friend                                                                                     |              5 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                              +----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +DirectedRelationshipIndexSeek | (person)-[r:KNOWS(since, lastMet)]->(friend) WHERE since IN $autolist_0 AND lastMet IN $autolist_1 |              5 |    1 |       6 |             72 |                    5/1 |     5.452 | Fused in Pipeline 0 |
+--------------------------------+----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 6, total allocated memory: 136

----

[[administration-indexes-prefix-search-using-starts-with-single-property-index]]
== Prefix search using `STARTS WITH` (single-property index) ==
The `STARTS WITH` predicate on `person.firstname` in the following query will use the `Person(firstname)` index, if it exists.

.Query
[source,cypher]
----
MATCH (person:Person) WHERE person.firstname STARTS WITH 'And' RETURN person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------------+--------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator              | Details                                                            | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------------+--------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults       | person                                                             |              2 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                     +--------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeekByRange | person:Person(firstname) WHERE firstname STARTS WITH $autostring_0 |              2 |    1 |       2 |             72 |                    3/0 |     0.514 | Fused in Pipeline 0 |
+-----------------------+--------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----

[[administration-indexes-prefix-search-using-starts-with-composite-index]]
== Prefix search using `STARTS WITH` (composite index) ==
The `STARTS WITH` predicate on `person.firstname` in the following query will use the `Person(firstname,surname)` index, if it exists. Any (non-existence check) predicate on `person.surname` will be rewritten as existence check with a filter. However, if the predicate on `person.firstname` is a equality check then a `STARTS WITH` on `person.surname` would also use the index (without rewrites). More information about how the rewriting works can be found in xref:indexes-for-search-performance.adoc#administration-indexes-single-vs-composite-index[composite index limitations].

.Query
[source,cypher]
----
MATCH (person:Person) WHERE person.firstname STARTS WITH 'And' AND person.surname IS NOT NULL RETURN
  person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------+-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                                                             | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------+-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | person                                                                                              |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeek  | person:Person(firstname, surname) WHERE firstname STARTS WITH $autostring_0 AND surname IS NOT NULL |              1 |    1 |       2 |             72 |                    3/0 |     2.998 | Fused in Pipeline 0 |
+-----------------+-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----

[[administration-indexes-suffix-search-using-ends-with-single-property-index]]
== Suffix search using `ENDS WITH` (single-property index) ==
The `ENDS WITH` predicate on `r.metIn` in the following query uses the `KNOWS(metIn)` index, if it exists. All values stored in the `KNOWS(metIn)` index are searched, and entries ending with `'mo'` are returned. This means that although the search is not optimized to the extent of queries using `=`, `IN`, `>`, `<` or `STARTS WITH`, it is still faster than not using an index in the first place.

.Query
[source,cypher]
----
MATCH (person)-[r:KNOWS]->(friend) WHERE r.metIn ENDS WITH 'mo' RETURN person, friend
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+----------------------------------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                               | Details                                                                 | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+----------------------------------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                        | person, friend                                                          |              0 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                                      +-------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +DirectedRelationshipIndexEndsWithScan | (person)-[r:KNOWS(metIn)]->(friend) WHERE metIn ENDS WITH $autostring_0 |              0 |    1 |       3 |             72 |                    2/1 |     0.517 | Fused in Pipeline 0 |
+----------------------------------------+-------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 136

----

[[administration-indexes-suffix-search-using-ends-with-composite-index]]
== Suffix search using `ENDS WITH` (composite index) ==
The `ENDS WITH` predicate on `r.metIn` in the following query uses the `KNOWS(metIn,lastMetIn)` index, if it exists. However, it is rewritten as existence check and a filter due to the index not supporting actual suffix searches for composite indexes, this is still faster than not using an index in the first place. Any (non-existence check) predicate on `KNOWS.lastMetIn` is also rewritten as existence check with a filter. More information about how the rewriting works can be found in xref:indexes-for-search-performance.adoc#administration-indexes-single-vs-composite-index[composite index limitations].

.Query
[source,cypher]
----
MATCH (person)-[r:KNOWS]->(friend) WHERE r.metIn ENDS WITH 'mo' AND r.lastMetIn IS NOT NULL RETURN
  person,
  friend
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+--------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                       | Details                                                                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+--------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                | person, friend                                                                                       |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                              +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +Filter                        | cache[r.metIn] ENDS WITH $autostring_0                                                               |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                              +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +DirectedRelationshipIndexScan | (person)-[r:KNOWS(metIn, lastMetIn)]->(friend) WHERE metIn IS NOT NULL AND lastMetIn IS NOT NULL, ca |              6 |    1 |       3 |             72 |                    2/1 |     0.490 | Fused in Pipeline 0 |
|                                | che[r.metIn]                                                                                         |                |      |         |                |                        |           |                     |
+--------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 136

----

[[administration-indexes-substring-search-using-contains-single-property-index]]
== Substring search using `CONTAINS` (single-property index) ==
The `CONTAINS` predicate on `person.firstname` in the following query will use the `Person(firstname)` index, if it exists. All values stored in the `Person(firstname)` index will be searched, and entries containing `'h'` will be returned. This means that although the search will not be optimized to the extent of queries using `=`, `IN`, `>`, `<` or `STARTS WITH`, it is still faster than not using an index in the first place. Composite indexes are currently not able to support `CONTAINS`. 

.Query
[source,cypher]
----
MATCH (person:Person) WHERE person.firstname CONTAINS 'h' RETURN person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+------------------------+-----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator               | Details                                                         | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+------------------------+-----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults        | person                                                          |              2 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                      +-----------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexContainsScan | person:Person(firstname) WHERE firstname CONTAINS $autostring_0 |              2 |    1 |       2 |             72 |                    3/0 |     0.953 | Fused in Pipeline 0 |
+------------------------+-----------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----

[[administration-indexes-substring-search-using-contains-composite-index]]
== Substring search using `CONTAINS` (composite index) ==
The `CONTAINS` predicate on `person.surname` in the following query will use the `Person(surname,age)` index, if it exists. However, it will be rewritten as existence check and a filter due to the index not supporting actual suffix searches for composite indexes, this is still faster than not using an index in the first place. Any (non-existence check) predicate on `person.age` will also be rewritten as existence check with a filter. More information about how the rewriting works can be found in xref:indexes-for-search-performance.adoc#administration-indexes-single-vs-composite-index[composite index limitations].

.Query
[source,cypher]
----
MATCH (person:Person) WHERE person.surname CONTAINS '300' AND person.age IS NOT NULL RETURN person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------+--------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                                                          | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------+--------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | person                                                                                           |             11 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +--------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +Filter         | cache[person.surname] CONTAINS $autostring_0                                                     |             11 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +--------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexScan  | person:Person(surname, age) WHERE surname IS NOT NULL AND age IS NOT NULL, cache[person.surname] |            111 |  303 |     304 |             72 |                    5/0 |     2.546 | Fused in Pipeline 0 |
+-----------------+--------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 304, total allocated memory: 136

----

[[administration-indexes-existence-check-using-is-not-null-single-property-index]]
== Existence check using `IS NOT NULL` (single-property index) ==
The `r.since IS NOT NULL` predicate in the following query uses the `KNOWS(since)` index, if it exists. 

.Query
[source,cypher]
----
MATCH (person)-[r:KNOWS]->(friend) WHERE r.since IS NOT NULL RETURN person, friend
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+--------------------------------+-------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                       | Details                                                     | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+--------------------------------+-------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                | person, friend                                              |              1 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                              +-------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +DirectedRelationshipIndexScan | (person)-[r:KNOWS(since)]->(friend) WHERE since IS NOT NULL |              1 |    1 |       3 |             72 |                    2/1 |     0.417 | Fused in Pipeline 0 |
+--------------------------------+-------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 136

----

[[administration-indexes-existence-check-using-is-not-null-composite-index]]
== Existence check using `IS NOT NULL` (composite index) ==
The `p.firstname IS NOT NULL` and `p.surname IS NOT NULL` predicates in the following query will use the `Person(firstname,surname)` index, if it exists. Any (non-existence check) predicate on `person.surname` will be rewritten as existence check with a filter.

.Query
[source,cypher]
----
MATCH (p:Person) WHERE p.firstname IS NOT NULL AND p.surname IS NOT NULL RETURN p
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                                          | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | p                                                                                |              1 |    2 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +----------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexScan  | p:Person(firstname, surname) WHERE firstname IS NOT NULL AND surname IS NOT NULL |              1 |    2 |       3 |             72 |                    2/1 |     0.633 | Fused in Pipeline 0 |
+-----------------+----------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 3, total allocated memory: 136

----

[[administration-indexes-spatial-distance-searches-single-property-index]]
== Spatial distance searches (single-property index) ==
If a property with point values is indexed, the index is used for spatial distance searches as well as for range queries.

.Query
[source,cypher]
----
MATCH ()-[r:KNOWS]->() WHERE distance(r.lastMetPoint, point({x: 1, y: 2})) < 2 RETURN r.lastMetPoint
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+---------------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator                              | Details                                                                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+---------------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults                       | `r.lastMetPoint`                                                                                     |             13 |    9 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                                     +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +Projection                           | cache[r.lastMetPoint] AS `r.lastMetPoint`                                                            |             13 |    9 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                                     +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +Filter                               | distance(cache[r.lastMetPoint], point({x: $autoint_0, y: $autoint_1})) < $autoint_2                  |             13 |    9 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                                     +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +DirectedRelationshipIndexSeekByRange | (anon_0)-[r:KNOWS(lastMetPoint)]->(anon_1) WHERE distance(lastMetPoint, point($autoint_0, $autoint_1 |             13 |    9 |      19 |             72 |                    5/3 |     1.774 | Fused in Pipeline 0 |
|                                       | )) < $autoint_2, cache[r.lastMetPoint]                                                               |                |      |         |                |                        |           |                     |
+---------------------------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 19, total allocated memory: 136

----

[[administration-indexes-spatial-distance-searches-composite-index]]
== Spatial distance searches (composite index) ==
If a property with point values is indexed, the index is used for spatial distance searches as well as for range queries. Any following (non-existence check) predicates (here on property `p.name` for index `:Person(place,name)`) will be rewritten as existence check with a filter.

.Query
[source,cypher]
----
MATCH (p:Person) WHERE distance(p.place, point({x: 1,
  y: 2})) < 2 AND p.name IS NOT NULL RETURN p.place
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------+-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                                                             | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------+-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | `p.place`                                                                                           |             72 |    9 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +Projection     | cache[p.place] AS `p.place`                                                                         |             72 |    9 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +Filter         | distance(cache[p.place], point({x: $autoint_0, y: $autoint_1})) < $autoint_2                        |             72 |    9 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeek  | p:Person(place, name) WHERE distance(place, point($autoint_0, $autoint_1)) < $autoint_2 AND name IS |             72 |    9 |      10 |             72 |                    6/0 |     2.964 | Fused in Pipeline 0 |
|                 | NOT NULL, cache[p.place]                                                                            |                |      |         |                |                        |           |                     |
+-----------------+-----------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 10, total allocated memory: 136

----

[[administration-indexes-spatial-bounding-box-searches-single-property-index]]
== Spatial bounding box searches (single-property index) ==
The ability to do index seeks on bounded ranges works even with the 2D and 3D spatial `Point` types.

.Query
[source,cypher]
----
MATCH (person:Person) WHERE point({x: 1, y: 5}) < person.location < point({x: 2, y: 6}) RETURN person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator              | Details                                                                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults       | person                                                                                               |              0 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |                     +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeekByRange | person:Person(location) WHERE location > point({x: $autoint_0, y: $autoint_1}) AND location < point( |              0 |    1 |       2 |             72 |                    8/0 |    11.041 | Fused in Pipeline 0 |
|                       | {x: $autoint_2, y: $autoint_3})                                                                      |                |      |         |                |                        |           |                     |
+-----------------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----

[[administration-indexes-spatial-bounding-box-searches-composite-index]]
== Spatial bounding box searches (composite index) ==
The ability to do index seeks on bounded ranges works even with the 2D and 3D spatial `Point` types. Any following (non-existence check) predicates (here on property `p.firstname` for index `:Person(place,firstname)`) will be rewritten as existence check with a filter. For index `:Person(firstname,place)`, if the predicate on `firstname` is equality or list membership then the bounded range is handled as a range itself. If the predicate on `firstname` is anything else then the bounded range is rewritten to existence and filter.

.Query
[source,cypher]
----
MATCH (person:Person) WHERE point({x: 1, y: 5}) < person.place < point({x: 2,
  y: 6}) AND person.firstname IS NOT NULL RETURN person
----



.Query Plan
[source]
----
Compiler CYPHER 4.3

Planner COST

Runtime PIPELINED

Runtime version 4.3

+-----------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| Operator        | Details                                                                                              | Estimated Rows | Rows | DB Hits | Memory (Bytes) | Page Cache Hits/Misses | Time (ms) | Other               |
+-----------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+
| +ProduceResults | person                                                                                               |              0 |    1 |       0 |                |                        |           | Fused in Pipeline 0 |
| |               +------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+                        |           +---------------------+
| +NodeIndexSeek  | person:Person(place, firstname) WHERE place > point({x: $autoint_0, y: $autoint_1}) AND place < poin |              0 |    1 |       2 |             72 |                    8/0 |     1.554 | Fused in Pipeline 0 |
|                 | t({x: $autoint_2, y: $autoint_3}) AND firstname IS NOT NULL                                          |                |      |         |                |                        |           |                     |
+-----------------+------------------------------------------------------------------------------------------------------+----------------+------+---------+----------------+------------------------+-----------+---------------------+

Total database accesses: 2, total allocated memory: 136

----
