:description: This section contains an overview of expressions in Cypher with examples.

[[cypher-expressions]]
= Expressions

[abstract]
--
This section contains an overview of expressions in Cypher with examples.
--

[[cypher-expressions-general]]
== Expressions in general

[NOTE]
====
Most expressions in Cypher evaluate to `null` if any of their inner expressions are `null`.
Notable exceptions are the operators `IS NULL`, `IS NOT NULL`, and the type predicate expression.
====

An expression in Cypher can be:

* A decimal (integer or float) literal: `13`, `-40000`, `3.14`.
* A decimal (integer or float) literal in scientific notation: `6.022E23`.
* A hexadecimal integer literal (starting with `0x`): `0x13af`, `0xFC3A9`, `-0x66eff`.
* An octal integer literal (starting with `0o`): `0o1372`, `-0o5671`.
* A string literal: `'Hello'`, `"World"`.
* A float literal: `Inf`, `Infinity`, `NaN`
* A boolean literal: `true`, `false`.
* A variable: `n`, `x`, `rel`, `myFancyVariable`, `++`A name with weird stuff in it[]!`++`.
* A property: `n.prop`, `x.prop`, `rel.thisProperty`, `++myFancyVariable.`(weird property name)`++`.
* A dynamic property: `n["prop"]`, `rel[n.city + n.zip]`, `map[coll[0]]`.
* A parameter: `$param`, `$0`.
* A list of expressions: `['a', 'b']`, `[1, 2, 3]`, `['a', 2, n.property, $param]`, `[]`.
* A function call: `length(p)`, `nodes(p)`.
* An aggregate function: `avg(x.prop)`, `+count(*)+`.
* A path-pattern: `+(a)-[r]->(b)+`, `+(a)-[r]-(b)+`, `+(a)--(b)+`, `+(a)-->()<--(b)+`.
* An operator application: `1 + 2`, `3 < 4`.
* A predicate expression is an expression that returns `true` or `false`: `a.prop = 'Hello'`, `length(p) > 10`, `a.name IS NOT NULL`.
* A special case of predicates are label and relationship type expressions: `(n:A|B)`, `()-[r:R1|R2]->()`.
* A subquery expression. For example:
`EXISTS {
  MATCH (n)-[r]->(p)
  WHERE p.name = 'Sven'
}`.
* A regular expression: `a.name =~ 'Tim.*'`.
* A case-sensitive string matching expression: `a.surname STARTS WITH 'Sven'`, `a.surname ENDS WITH 'son'` or `a.surname CONTAINS 'son'`.
* A `CASE` expression.


[[cypher-expressions-string-literals]]
== Note on string literals

String literals can contain the following escape sequences:

[options="header", cols=">1,<2"]
|===================
|Escape sequence|Character
|`\t`|Tab
|`\b`|Backspace
|`\n`|Newline
|`\r`|Carriage return
|`\f`|Form feed
|`\'`|Single quote
|`\"`|Double quote
|`\\`|Backslash
|`\uxxxx`|Unicode UTF-16 code point (4 hex digits must follow the `\u`)
|===================

[NOTE]
====
Using regular expressions with unsanitized user input makes you vulnerable to Cypher injection.
Consider using xref:syntax/parameters.adoc[parameters] instead.
====

[[cypher-expressions-number-literals]]
== Note on number literals

Any number literal may contain an underscore `_` between digits.
There may be an underscore between the `0x` or `0o` and the digits for hexadecimal and octal literals.

[[query-syntax-case]]
== `CASE` expressions

Generic conditional expressions may be expressed using the `CASE` construct.
Two variants of `CASE` exist within Cypher: the simple form, which allows an expression to be compared against multiple values, and the generic form, which allows multiple conditional statements to be expressed.

[NOTE]
====
CASE can only be used as part of RETURN or WITH if you want to use the result in the succeeding clause or statement.
====

The following graph is used for the examples below:

////
[source, cypher, role=test-setup]
----
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)
----
////

image:graph3.svg[]

[[syntax-simple-case]]
=== Simple `CASE` form: comparing an expression against multiple values

The expression is calculated, and compared in order with the `WHEN` clauses until a match is found.
If no match is found, the expression in the `ELSE` clause is returned.
However, if there is no `ELSE` case and no match is found, `null` will be returned.


[source, syntax]
----
CASE test
  WHEN value THEN result
  [WHEN ...]
  [ELSE default]
END
----


*Arguments:*
[options="header"]
|===
| Name | Description

| `test`
| A valid expression.

| `value`
| An expression whose result will be compared to `test`.

| `result`
| This is the expression returned as output if `value` matches `test`.

| `default`
| If no match is found, `default` is returned.
|===


[source, cypher]
----
MATCH (n)
RETURN
CASE n.eyes
  WHEN 'blue'  THEN 1
  WHEN 'brown' THEN 2
  ELSE 3
END AS result
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +2+
| +1+
| +3+
| +2+
| +1+
1+d|Rows: 5
|===


[[syntax-generic-case]]
=== Generic `CASE` form: allowing for multiple conditionals to be expressed

The predicates are evaluated in order until a `true` value is found, and the result value is used.
If no match is found, the expression in the `ELSE` clause is returned.
However, if there is no `ELSE` case and no match is found, `null` will be returned.


[source, syntax]
----
CASE
  WHEN predicate THEN result
  [WHEN ...]
  [ELSE default]
END
----


*Arguments:*
[options="header"]
|===
| Name | Description
| `predicate`
| A predicate that is tested to find a valid alternative.

| `result`
| This is the expression returned as output if `predicate` evaluates to `true`.

| `default`
| If no match is found, `default` is returned.
|===

[source, cypher]
----
MATCH (n)
RETURN
CASE
  WHEN n.eyes = 'blue' THEN 1
  WHEN n.age < 40      THEN 2
  ELSE 3
END AS result
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +2+
| +1+
| +3+
| +3+
| +1+
1+d|Rows: 5
|===


[[syntax-distinguish-case]]
=== Distinguishing between when to use the simple and generic `CASE` forms

Owing to the close similarity between the syntax of the two forms, sometimes it may not be clear at the outset as to which form to use.
We illustrate this scenario by means of the following query, in which there is an expectation that `age_10_years_ago` is `-1` if `n.age` is `null`:

[source, cypher]
----
MATCH (n)
RETURN n.name,
CASE n.age
  WHEN n.age IS NULL THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
----

However, as this query is written using the simple `CASE` form, instead of `age_10_years_ago` being `-1` for the node named `Daniel`, it is `null`.
This is because a comparison is made between `n.age` and `n.age IS NULL`.
As `n.age IS NULL` is a boolean value, and `n.age` is an integer value, the `WHEN n.age IS NULL THEN -1` branch is never taken.
This results in the `ELSE n.age - 10` branch being taken instead, returning `null`.

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +age_10_years_ago+
| +"Alice"+ | +28+
| +"Bob"+ | +15+
| +"Charlie"+ | +43+
| +"Daniel"+ | +<null>+
| +"Eskil"+ | +31+
2+d|Rows: 5
|===

The corrected query, behaving as expected, is given by the following generic `CASE` form:

[source, cypher]
----
MATCH (n)
RETURN n.name,
CASE
  WHEN n.age IS NULL THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
----

We now see that the `age_10_years_ago` correctly returns `-1` for the node named `Daniel`.

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +age_10_years_ago+
| +"Alice"+ | +28+
| +"Bob"+ | +15+
| +"Charlie"+ | +43+
| +"Daniel"+ | +-1+
| +"Eskil"+ | +31+
2+d|Rows: 5
|===


[[syntax-use-case-result]]
=== Using the result of `CASE` in the succeeding clause or statement

You can use the result of `CASE` to set properties on a node or relationship.
For example, instead of specifying the node directly, you can set a property for a node selected by an expression:


[source, cypher]
----
MATCH (n)
WITH n,
CASE n.eyes
  WHEN 'blue'  THEN 1
  WHEN 'brown' THEN 2
  ELSE 3
END AS colourCode
SET n.colourCode = colourCode
----

For more information about using the `SET` clause, see xref::clauses/set.adoc[SET].

[role="queryresult",options="footer",cols="1*<m"]
|===
1+|(empty result)
1+d|Rows: 0 +
Properties set: 5
|===


[[syntax-use-case-with-null]]
=== Using `CASE` with null values

When using the simple `CASE` form, it is useful to remember that in Cypher `null = null` yields `null`.


.+CASE+
======

For example, you might expect `age_10_years_ago` to be `-1` for the node named `Daniel`:

[source, cypher]
----
MATCH (n)
RETURN n.name,
CASE n.age
  WHEN null THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
----

However, as `null = null` does not yield `true`, the `WHEN null THEN -1` branch is never taken, resulting in the `ELSE n.age - 10` branch being taken instead, returning `null`.

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +age_10_years_ago+
| +"Alice"+ | +28+
| +"Bob"+ | +15+
| +"Charlie"+ | +43+
| +"Daniel"+ | +<null>+
| +"Eskil"+ | +31+
2+d|Rows: 5
|===

======


[[cypher-subquery-expressions]]
== Subquery expressions

Subquery expressions can appear anywhere that an expression is valid.
A subquery has a scope, as indicated by the opening and closing braces, `{` and `}`.
Any variable that is defined in the outside scope can be referenced inside the subquery's own scope.
Variables introduced inside the subquery are not part of the outside scope and therefore can't be accessed on the outside.


The following graph is used for the examples below:

////
[source, cypher, role=test-setup]
----
MATCH (n:A|B|C|D|E) DETACH DELETE n;
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', nickname: 'Tim', age: 25}),
(peter:Person {name: 'Peter', nickname: 'Pete', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(timothy)-[:HAS_CAT {since: 2019}]->(:Cat {name:'Mittens'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})
----
////

image:graph_expression_subqueries.svg[]

[[existential-subqueries]]
=== `EXISTS` subqueries

An `EXISTS` subquery can be used to find out if a specified pattern exists at least once in the data.
It serves the same purpose as a xref::clauses/where.adoc#filter-on-patterns[path pattern] but is more powerful because it allows you to use `MATCH` and `WHERE` clauses internally.
Moreover, it can appear in any expression position, unlike path patterns.
If the subquery evaluates to at least one row, the whole expression will become `true`.
This also means that the system only needs to evaluate if there is at least one row and can skip the rest of the work.

Any non-writing query is allowed. `EXISTS` subqueries differ from regular queries in that the final `RETURN` clause may be omitted,
as any variable defined within the subquery will not be available outside of the expression, even if a final `RETURN` clause is used.

It is worth noting that the `MATCH` keyword can be omitted in subqueries in cases where the `EXISTS` consists of only
a pattern and an optional `WHERE` clause.

[[existential-subquery-simple-case]]
==== Simple `EXISTS` subquery

Variables introduced by the outside scope can be used in the `EXISTS` subquery without importing them.
In this regard, `EXISTS` subqueries are different from `CALL` subqueries, xref::clauses/call-subquery.adoc#subquery-correlated-importing[which do require importing].
The following example shows this:


[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
    (person)-[:HAS_DOG]->(:Dog)
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
| +"Peter"+
1+d|Rows: 2
|===

[[existential-subquery-with-where]]
==== `EXISTS` subquery with `WHERE` clause

A `WHERE` clause can be used in conjunction to the `MATCH`.
Variables introduced by the `MATCH` clause and the outside scope can be used in this scope.

[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===


[[existential-subquery-nesting]]
==== Nesting `EXISTS` subqueries

`EXISTS` subqueries can be nested like the following example shows.
The nesting also affects the scopes.
That means that it is possible to access all variables from inside the subquery which are either from the outside scope or defined in the very same subquery.


[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE EXISTS {
    MATCH (dog)-[:HAS_TOY]->(toy:Toy)
    WHERE toy.name = 'Banana'
  }
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===

[[existential-subquery-outside-where]]
==== `EXISTS` subquery outside of a `WHERE` clause

`EXISTS` subquery expressions can appear anywhere that an expression is valid.
Here the result is a boolean that shows whether the subquery can find the given pattern.


[source, cypher]
----
MATCH (person:Person)
RETURN person.name AS name, EXISTS {
  MATCH (person)-[:HAS_DOG]->(:Dog)
} AS hasDog
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+ | +hasDog+
| +"Andy"+ | +true+
| +"Timothy"+ | +false+
| +"Peter"+ | +true+
2+d|Rows: 3
|===


[[existential-subquery-with-union]]
==== `EXISTS` subquery with a `UNION`

_This feature was introduced in Neo4j 5.3._

`Exists` can be used with a `UNION` clause, and the `RETURN` clauses are not required.
It is worth noting that if one branch has a `RETURN` clause, then all branches require one.
The below example demonstrates that if one of the `UNION` branches was to return at least one row, the entire `EXISTS` expression will evaluate to true.

[source, cypher]
----
MATCH (person:Person)
RETURN
    person.name AS name,
    EXISTS {
        MATCH (person)-[:HAS_DOG]->(:Dog)
        UNION
        MATCH (person)-[:HAS_CAT]->(:Cat)
    } AS hasPet
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +hasPet+
| +"Andy"+      | +true+
| +"Timothy"+   | +true+
| +"Peter"+     | +true+
2+d|Rows: 3
|===


[[existential-subquery-with-with]]
==== `EXISTS` subquery with `WITH`

_This feature was introduced in Neo4j 5.3._

Variables from the outside scope are visible for the entire subquery, even when using a `WITH` clause.
To avoid confusion, shadowing of these variables is not allowed.
An outside scope variable is shadowed when a newly introduced variable within the inner scope is defined with the same variable.
In the example below, the outer variable `name` is shadowed and will therefore throw an error.

[source, cypher, role=test-fail]
----
WITH 'Peter' as name
MATCH (person:Person {name: name})
WHERE EXISTS {
    WITH "Ozzy" AS name
    MATCH (person)-[:HAS_DOG]->(d:Dog)
    WHERE d.name = name
}
RETURN person.name AS name
----

.Error message
[source, output, role="noheader"]
----
The variable `name` is shadowing a variable with the same name from the outer scope and needs to be renamed (line 4, column 20 (offset: 90))
----

New variables can be introduced into the subquery, as long as they use a different identifier.
In the example below, a `WITH` clause introduces a new variable.
Note that the outer scope variable `person` referenced in the main query is still available after the `WITH` clause.

[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
    WITH "Ozzy" AS dogName
    MATCH (person)-[:HAS_DOG]->(d:Dog)
    WHERE d.name = dogName
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===


[[existential-subquery-with-return]]
==== `EXISTS` subquery with `RETURN`

_This feature was introduced in Neo4j 5.3._

`EXISTS` subqueries do not require a `RETURN` clause at the end of the subquery. If one is present, it does not
need to be aliased, which is different compared to xref::clauses/call-subquery.adoc[`CALL` subqueries].
Any variables returned in an `EXISTS` subquery will not be available after the subquery.

[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
    MATCH (person)-[:HAS_DOG]->(:Dog)
    RETURN person.name
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
| +"Peter"+
1+d|Rows: 2
|===


[[count-subqueries]]
=== `COUNT` subqueries

A `COUNT` subquery expression can be used to count the number of rows returned by the subquery.

Any non-writing query is allowed. `COUNT` subqueries differ from regular queries in that the final `RETURN` clause may be omitted,
as any variable defined within the subquery will not be available outside of the expression,
even if a final `RETURN` clause is used. One exception to this is that for a `DISTINCT UNION` clause, the `RETURN` clause is still mandatory.

It is worth noting that the `MATCH` keyword can be omitted in subqueries in cases where the `COUNT` consists of only a pattern and an optional `WHERE` clause.

[[count-subquery-simple-case]]
==== Simple `COUNT` subquery

Variables introduced by the outside scope can be used in the `COUNT` subquery without importing them.
In this regard, `COUNT` subqueries are different from `CALL` subqueries, xref::clauses/call-subquery.adoc#subquery-correlated-importing[which do require importing].
The following query exemplifies this and outputs the owners of more than one dog:


[source, cypher]
----
MATCH (person:Person)
WHERE COUNT { (person)-[:HAS_DOG]->(:Dog) } > 1
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===


[[count-subquery-with-where]]
==== `COUNT` subquery with `WHERE` clause

A `WHERE` clause can be used inside the `COUNT` pattern.
Variables introduced by the `MATCH` clause and the outside scope can be used in this scope.


[source, cypher]
----
MATCH (person:Person)
WHERE COUNT {
  (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
} = 1
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===

[[count-subquery-with-union]]
==== `COUNT` subquery with a `UNION`

_This feature was introduced in Neo4j 5.3._

`COUNT` can be used with a `UNION` clause. If the `UNION` clause is distinct, the `RETURN` clause is required.
`UNION ALL` clauses do not require the `RETURN` clause. However, it is worth noting that if one branch has a `RETURN` clause, then all require one.
The below example shows the count of pets each person has by using a `UNION` clause:

[source, cypher]
----
MATCH (person:Person)
RETURN
    person.name AS name,
    COUNT {
        MATCH (person)-[:HAS_DOG]->(dog:Dog)
        RETURN dog.name AS petName
        UNION
        MATCH (person)-[:HAS_CAT]->(cat:Cat)
        RETURN cat.name AS petName
    } AS numPets
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +numPets+
| +"Andy"+      | +1+
| +"Timothy"+   | +1+
| +"Peter"+     | +2+
2+d|Rows: 3
|===


[[count-subquery-with-with]]
==== `COUNT` subquery with `WITH`

_This feature was introduced in Neo4j 5.3._

Variables from the outside scope are visible for the entire subquery, even when using a `WITH` clause.
To avoid confusion, shadowing of these variables is not allowed.
An outside scope variable is shadowed when a newly introduced variable within the inner scope is defined with the same variable.
In the example below, the outer variable `name` is shadowed and will therefore throw an error.

[source, cypher, role=test-fail]
----
WITH 'Peter' as name
MATCH (person:Person {name: name})
WHERE COUNT {
    WITH "Ozzy" AS name
    MATCH (person)-[:HAS_DOG]->(d:Dog)
    WHERE d.name = name
} = 1
RETURN person.name AS name
----

.Error message
[source, output, role="noheader"]
----
The variable `name` is shadowing a variable with the same name from the outer scope and needs to be renamed (line 4, column 20 (offset: 90))
----

New variables can be introduced into the subquery, as long as they use a different identifier.
In the example below, a `WITH` clause introduces a new variable.
Note that the outer scope variable `person` referenced in the main query is still available after the `WITH` clause.

[source, cypher]
----
MATCH (person:Person)
WHERE COUNT {
    WITH "Ozzy" AS dogName
    MATCH (person)-[:HAS_DOG]->(d:Dog)
    WHERE d.name = dogName
} = 1
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===


[[count-subqueries-other-clauses]]
==== Using `COUNT` subqueries inside other clauses

`COUNT` can be used in any position in a query, with the exception of administration commands, where it is restricted.
See a few examples below:

[[count-subqueries-with-return]]
===== Using `COUNT` in `RETURN`


[source, cypher]
----
MATCH (person:Person)
RETURN person.name, COUNT { (person)-[:HAS_DOG]->(:Dog) } as howManyDogs

----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +howManyDogs+
| +"Andy"+ | +1+
| +"Timothy"+ | +0+
| +"Peter"+ | +2+
2+d|Rows: 3
|===


[[count-subqueries-with-set]]
===== Using `COUNT` in `SET`


[source, cypher]
----
MATCH (person:Person) WHERE person.name ="Andy"
SET person.howManyDogs = COUNT { (person)-[:HAS_DOG]->(:Dog) }
RETURN person.howManyDogs as howManyDogs

----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +howManyDogs+
| +1+
1+d|Rows: 1 +
Properties set: 1
|===


[[count-subqueries-with-case]]
===== Using `COUNT` in `CASE`


[source, cypher]
----
MATCH (person:Person)
RETURN
   CASE
     WHEN COUNT { (person)-[:HAS_DOG]->(:Dog) } > 1 THEN "Doglover " + person.name
     ELSE person.name
   END AS result

----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +"Andy"+
| +"Timothy"+
| +"Doglover Peter"+
1+d|Rows: 3
|===


[[count-subqueries-as-grouping-key]]
===== Using `COUNT` as a grouping key

The following query groups all persons by how many dogs they own,
and then calculates the average age for each group.


[source, cypher]
----
MATCH (person:Person)
RETURN COUNT { (person)-[:HAS_DOG]->(:Dog) } AS numDogs,
       avg(person.age) AS averageAge
 ORDER BY numDogs

----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +numDogs+ | +averageAge+
| +0+ | +25.0+
| +1+ | +36.0+
| +2+ | +35.0+
2+d|Rows: 3
|===


[[count-subquery-with-return]]
==== `COUNT` subquery with `RETURN`

_This feature was introduced in Neo4j 5.3._

`COUNT` subqueries do not require a `RETURN` clause at the end of the subquery. If one is present, it does not need to be aliased.
This is a difference compared to from xref::clauses/call-subquery.adoc[`CALL` subqueries].
Any variables returned in a `COUNT` subquery will not be available after the subquery.

[source, cypher]
----
MATCH (person:Person)
WHERE COUNT {
    MATCH (person)-[:HAS_DOG]->(:Dog)
    RETURN person.name
} = 1
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===


[[collect-subqueries]]
=== `COLLECT` subqueries

_This feature was introduced in Neo4j 5.6._

A `COLLECT` subquery expression can be used to create a list with the rows returned by a given subquery.

Any non-writing query is allowed.
`COLLECT` subqueries differ from `COUNT` and `EXISTS` subqueries in that the final `RETURN` clause is mandatory.
The `RETURN` clause must return exactly one column.

[[collect-subquery-simple-case]]
==== Simple `COLLECT` subquery

Variables introduced by the outside scope can be used in the `COLLECT` subquery without importing them.
In this regard, `COLLECT` subqueries are different from `CALL` subqueries, xref::clauses/call-subquery.adoc#subquery-correlated-importing[which do require importing].
The following query exemplifies this and outputs the owners of the dog named `Ozzy`:

[source, cypher]
----
MATCH (person:Person)
WHERE 'Ozzy' IN COLLECT { MATCH (person)-[:HAS_DOG]->(dog:Dog) RETURN dog.name }
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===


[[collect-subquery-with-where]]
==== `COLLECT` subquery with `WHERE` clause

A `WHERE` clause can be used inside the `COLLECT` pattern.
Variables introduced by the `MATCH` clause and the outside scope can be used in the inner scope.

[source, cypher]
----
MATCH (person:Person)
RETURN person.name as name, COLLECT {
  MATCH (person)-[r:HAS_DOG]->(dog:Dog)
  WHERE r.since > 2017
  RETURN dog.name
} as youngDogs
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +youngDogs+
| +"Andy"+      | +[]+
| +"Timothy"+   | +[]+
| +"Peter"+     | +["Ozzy"]+
2+d|Rows: 3
|===


[[collect-subquery-with-union]]
==== `COLLECT` subquery with a `UNION`

`COLLECT` can be used with a `UNION` clause.
The below example shows the collection of pet names each person has by using a `UNION` clause:

[source, cypher]
----
MATCH (person:Person)
RETURN
    person.name AS name,
    COLLECT {
        MATCH (person)-[:HAS_DOG]->(dog:Dog)
        RETURN dog.name AS petName
        UNION
        MATCH (person)-[:HAS_CAT]->(cat:Cat)
        RETURN cat.name AS petName
    } AS petNames
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +petNames+
| +"Andy"+      | +["Andy"]+
| +"Timothy"+   | +["Mittens"]+
| +"Peter"+     | +["Ozzy", "Fido"]+
2+d|Rows: 3
|===


[[collect-subquery-with-with]]
==== `COLLECT` subquery with `WITH`

Variables from the outside scope are visible for the entire subquery, even when using a `WITH` clause.
To avoid confusion, shadowing of these variables is not allowed.
An outside scope variable is shadowed when a newly introduced variable within the inner scope is defined with the same variable.
In the example below, the outer variable `name` is shadowed and will therefore throw an error.

[source, cypher, role=test-fail]
----
WITH 'Peter' as name
MATCH (person:Person {name: name})
RETURN COLLECT {
    WITH 'Ozzy' AS name
    MATCH (person)-[r:HAS_DOG]->(d:Dog {name: name})
    RETURN d.name
} as dogsOfTheYear
----

.Error message
[source, output, role="noheader"]
----
The variable `name` is shadowing a variable with the same name from the outer scope and needs to be renamed (line 4, column 20 (offset: 92))
----

New variables can be introduced into the subquery, as long as they use a different identifier.
In the example below, a `WITH` clause introduces a new variable.
Note that the outer scope variable `person` referenced in the main query is still available after the `WITH` clause.

[source, cypher]
----
MATCH (person:Person)
RETURN person.name AS name, COLLECT {
    WITH 2018 AS yearOfTheDog
    MATCH (person)-[r:HAS_DOG]->(d:Dog)
    WHERE r.since = yearOfTheDog
    RETURN d.name
} as dogsOfTheYear
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +dogsOfTheYear+
| +"Andy"+      | +[]+
| +"Timothy"+   | +[]+
| +"Peter"+     | +["Ozzy"]+
2+d|Rows: 3
|===


[[collect-subqueries-other-clauses]]
==== Using `COLLECT` subqueries inside other clauses

`COLLECT` can be used in any position in a query, with the exception of administration commands, where the `COLLECT` expression is restricted.
See a few examples below of how `COLLECT` can be used in different positions within a query:


[[collect-subqueries-with-return]]
===== Using `COLLECT` in `RETURN`

[source, cypher]
----
MATCH (person:Person)
RETURN person.name,
       COLLECT {
            MATCH (person)-[:HAS_DOG]->(d:Dog)
            MATCH (d)-[:HAS_TOY]->(t:Toy)
            RETURN t.name
       } as toyNames
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +toyNames+
| +"Andy"+      | +[]+
| +"Timothy"+   | +[]+
| +"Peter"+     | +["Banana"]+
2+d|Rows: 3
|===


[[collect-subqueries-with-set]]
===== Using `COLLECT` in `SET`

[source, cypher]
----
MATCH (person:Person) WHERE person.name = "Peter"
SET person.dogNames = COLLECT { MATCH (person)-[:HAS_DOG]->(d:Dog) RETURN d.name }
RETURN person.dogNames as dogNames
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +dogNames+
| +["Ozzy", "Fido"]+
1+d|Rows: 1 +
Properties set: 1
|===


[[collect-subqueries-with-case]]
===== Using `COLLECT` in `CASE`

[source, cypher]
----
MATCH (person:Person)
RETURN
   CASE
     WHEN COLLECT { MATCH (person)-[:HAS_DOG]->(d:Dog) RETURN d.name } = []  THEN "No Dogs " + person.name
     ELSE person.name
   END AS result
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +"Andy"+
| +"No Dogs Timothy"+
| +"Peter"+
1+d|Rows: 3
|===


[[collect-subqueries-as-grouping-key]]
===== Using `COLLECT` as a grouping key

The following query collects all persons by their dogs' names,
and then calculates the average age for each group.

[source, cypher]
----
MATCH (person:Person)
RETURN COLLECT { MATCH (person)-[:HAS_DOG]->(d:Dog) RETURN d.name } AS dogNames,
       avg(person.age) AS averageAge
 ORDER BY dogNames
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +dogNames+         | +averageAge+
| +[]+               | +25.0+
| +["Andy"]+         | +36.0+
| +["Ozzy", "Fido"]+ | +35.0+
2+d|Rows: 3
|===


[[collect-subqueries-vs-collect-function]]
===== Using `COLLECT` vs `collect()`

`COLLECT` does not handle `null` values in the same way that function `collect()` does.
The `collect()` function automatically removes `null` values.
`COLLECT` will not remove `null` values automatically.
However, they can be removed by adding a filtering step in the subquery.

The following queries illustrate these differences:

[source, cypher]
----
MATCH (p:Person)
RETURN collect(p.nickname) AS names
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +names+
| +["Pete", "Tim"]+
1+d|Rows: 1
|===

[source, cypher]
----
RETURN COLLECT {
        MATCH (p:Person)
        RETURN p.nickname ORDER BY p.nickname
      } AS names
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +names+
| +["Pete", "Tim", null]+
1+d|Rows: 1
|===

[source, cypher]
----
RETURN COLLECT {
        MATCH (p:Person)
        WHERE p.nickname IS NOT NULL
        RETURN p.nickname ORDER BY p.nickname
      } AS names
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +["Pete", "Tim"]+
1+d|Rows: 1
|===

[[type-predicate-expressions]]
== Type predicate expressions

_This feature was introduced in Neo4j 5.9._

A type predicate expression can be used to verify the type of a variable, literal, property or other Cypher expression.

[source, syntax, role="noheader", indent=0]
----
<expr> IS :: <TYPE>
----

Where `<expr>` is any Cypher expression and `<TYPE>` is a Cypher Type.
For all available Cypher types, see the section on xref::values-and-types/property-structural-constructed.adoc#types-synonyms[types and their synonyms].

[source, cypher]
----
UNWIND [42, true, 'abc'] AS val
RETURN val, val IS :: INTEGER AS isInteger
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| val | isInteger
| 42 | true
| true | false
| 'abc' | false
2+d|Rows: 3
|===

[[type-predicate-expressions-not]]
=== Type predicate expressions with NOT

It is also possible to verify that a Cypher expression is not of a certain type, using the negated type predicate expression `IS NOT ::`.

[source, cypher]
----
UNWIND [42, true, 'abc'] AS val
RETURN val, val IS NOT :: STRING AS notString
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| val | notString
| 42 | true
| true | true
| 'abc' | false
2+d|Rows: 3
|===

[[type-predicate-expressions-null]]
=== Type predicate expressions for null

As of Neo4j 5.10, a Cypher type includes the `null` value unless it is explicitly appended with `NOT NULL`.
Therefore, `IS ::` returns `true` for all expressions evaluating to `null`, unless they explicitly remove it.

[source, cypher]
----
WITH toFloat(null) AS nullValue
RETURN nullValue IS :: BOOLEAN AS isBoolean, nullValue IS :: BOOLEAN NOT NULL AS isNotNullBoolean
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| isBoolean | isNotNullBoolean
| true      | false
2+d|Rows: 1
|===

Likewise, `IS NOT ::` returns `false` for all expressions evaluating to `null`, unless the type is appended with `NOT NULL`.

[source, cypher]
----
WITH (null + 1) AS nullValue
RETURN nullValue IS NOT :: DATE AS isNotDate, nullValue IS NOT :: DATE NOT NULL AS isNotNotNullDate
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| isNotDate | isNotNotNullDate
| false     | true
2+d|Rows: 1
|===

It is also possible to check whether a value is the only `null` value using the `NULL` type.

[source, cypher]
----
WITH toFloat(null) AS nullValue
RETURN nullValue IS :: NULL AS isNull
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| isNull
| true
1+d|Rows: 1
|===

[[type-predicate-expressions-properties]]
=== Type predicate expression for properties

Type predicate expressions can also be used to filter out nodes or relationships with properties of a certain type.

A graph containing the following nodes is used for the example below:

////
[source, cypher, role=test-setup]
----
MATCH (n) DETACH DELETE n;
CREATE (:Person {name: 'Alice', age:14}),
(:Person {name:'Bob', age:'20'}),
(:Person {name:'Charlie', age:21}),
----
////

image:graph_expression_type_predicate.svg[]

The following query finds all `Person` nodes with an `age` property that is an `INTEGER` with a greater value than `18`.

[source, cypher]
----
MATCH (n:Person)
WHERE n.age IS :: INTEGER AND n.age > 18
RETURN n.name AS name, n.age AS age
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| name | age
| Charlie | 21
2+d|Rows: 1
|===

The type `PROPERTY VALUE` can also be used to check whether a type is storable as a property.
Types not storable in properties, such as `MAP`, will return `false` when checked with `IS :: PROPERTY VALUE`.

[[type-predicate-expressions-number-sizes]]
=== Type predicate expressions for numbers of different sizes

For numerical values passed in as parameters, Cypher does not take the size of the number into account.
Cypher will therefore regard any exact numerical parameter as an `INTEGER` regardless of its declared size.
For example, an `INT16` or an `INT32` passed through from a client programming language will both be treated by Cypher as an `INTEGER`.
Note that any exact numerical parameter used must fit within the range of an `INT 64`. 

[source, cypher, role=test-skip]
----
RETURN $int16param IS :: INTEGER AS isInteger
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| isInteger
| true
1+d|Rows: 1
|===

More information about parameters can be found xref::syntax/parameters.adoc[here].

[[type-predicate-expressions-variations]]
=== Syntactical variations of type predicate expressions

Type predicate expressions allow for some alternative syntax:

[source, syntax, role="noheader", indent=0]
----
<expr> IS TYPED <TYPE>
----

[source, syntax, role="noheader", indent=0]
----
<expr> :: <TYPE>
----

For verifying that an expression is not of a certain type, the following alternative syntax is supported:

[source, syntax, role="noheader", indent=0]
----
<expr> IS NOT TYPED <TYPE>
----

[[type-predicate-expressions-any-and-nothing]]
=== Use of `ANY` and `NOTHING` types

_This feature was introduced in Neo4j 5.10._

`ANY` is a supertype which matches values of all types.
`NOTHING` is a type containing an empty set of values.
This means that it returns `false` for all values.

[source, cypher]
----
RETURN 42 IS :: ANY AS isOfTypeAny, 42 IS :: NOTHING AS isOfTypeNothing
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| isOfTypeAny | isOfTypeNothing
| true        | false
2+d|Rows: 1
|===

[[type-predicate-expressions-lists]]
=== List Types

_This feature was introduced in Neo4j 5.10._

Type predicate expressions can be used for `LIST` types, where the inner type of the elements in the list must be specified.
If the inner type is not relevant, then the `ANY` type may be used.

For a `LIST` type check to return `true`, all values in the list must match the inner type.

[source, cypher]
----
UNWIND [[42], [42, null], [42, 42.0]] as val
RETURN val, val IS :: LIST<INTEGER> AS isIntList
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| val         | isIntList
| [42]        | true
| [42, null]  | true
| [42, 42.0]  | false
2+d|Rows: 3
|===

An empty list will match on all inner types, even the `NOTHING` type.

[source, cypher]
----
RETURN
    [] IS :: LIST<NOTHING> AS isNothingList,
    [] IS :: LIST<INTEGER> AS isIntList,
    [] IS :: LIST<FLOAT NOT NULL> AS isFloatNotNullList
----

[role="queryresult",options="header,footer",cols="3*<m"]
|===
| isNothingList | isIntList | isFloatNotNullList
| true          | true      | true
3+d|Rows: 1
|===

[[label-expressions]]
== Label expressions

In earlier versions of Neo4j, label expressions for nodes had a single colon operator that represented the `AND` operator.
With the release of version 5.0, a new label expression with an extended set of logical operators is being introduced, in addition to the single colon operator.
It is important to note that you cannot mix these different types of label expression syntax.
For more information, see <<syntax-restrictions-label, Restrictions on using the different types of label expression syntax>>.

Label expressions evaluate to `true` or `false` when applied to the set of labels for a node.

Assuming no other filters are applied, then a label expression evaluating to `true` means the node is matched.

The following table displays whether the label expression matches the relationship:

.Label expression matches
[cols="^3,^2,^2,^2,^2,^2,^2,^2,^2"]
|===
|
8+^|*Node*

|*Label expression* | `()` | `(:A)` | `(:B)` | `(:C)` | `(:A:B)` | `(:A:C)` | `(:B:C)` | `(:A:B:C)`
| `()`
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:A)`
|
| {check-mark}
|
|
| {check-mark}
| {check-mark}
|
| {check-mark}

| `(:A&B)`
|
|
|
|
| {check-mark}
|
|
| {check-mark}

| `(:A\|B)`
|
| {check-mark}
| {check-mark}
|
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:!A)`
| {check-mark}
|
| {check-mark}
| {check-mark}
|
|
| {check-mark}
|

| `(:!!A)`
|
| {check-mark}
|
|
| {check-mark}
| {check-mark}
|
| {check-mark}

| `(:A&!A)`
|
|
|
|
|
|
|
|

| `(:A\|!A)`
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:%)`
|
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:!%)`
| {check-mark}
|
|
|
|
|
|
|

| `(:%\|!%)`
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:%&!%)`
|
|
|
|
|
|
|
|

| `(:A&%)`
|
| {check-mark}
|
|
| {check-mark}
| {check-mark}
|
| {check-mark}

| `(:A\|%)`
|
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:(A&B)&!(B&C))`
|
|
|
|
| {check-mark}
|
|
|

| `(:!(A&%)&%)`
|
|
| {check-mark}
| {check-mark}
|
|
| {check-mark}
|

|===


[[syntax-restrictions-label]]
=== Restrictions on using the different types of label expression syntax

Neo4j version 5.0 introduced an ampersand operator, which is equivalent to the colon conjunction operator.
Mixing the colon conjunction operator with any of the new label expression operators in the same clause will raise a syntax error.

For example, each of the following clauses will raise syntax errors:

* `MATCH (n:A|B:C)`
* `MATCH (n:A:B)-[]-(m:(A&B)|C)`
* `MATCH (n:A:B)--(m), (n)-->(o:(A&B)|C)`
* `RETURN n:A&B, n:A:B`
* `MATCH (n:A:B)-[]-(m) WHERE m:(A&B)|C`

In earlier versions of Neo4j (version 4.4 and earlier), relationship type expressions only had the pipe operator.
As the pipe operator will continue to act as an `OR` operator, it can continue to be used alongside the new operators.

To make it easier to use the new syntax when extending existing queries, using the different syntax types in separate clauses will be supported.

For example, the following query will not raise a syntax error:

[source, cypher, role=noplay]
----
MATCH (m:A:B:C)-[]->()
MATCH (n:(A&B)|C)-[]->(m)
RETURN m,n
----

Queries that exclusively use syntax from earlier versions of Neo4j (version 4.4 and earlier) will continue to be supported.

For example, the following will not raise a syntax error:

[source, cypher, role=noplay]
----
MATCH (m:A:B:C)-[:S|T]->()
RETURN
  CASE
    WHEN m:D:E THEN m.p
    ELSE null
  END AS result
----

[[label-expressions-examples]]
==== Examples

The following graph is used for the examples below:

////
[source, cypher, role=test-setup]
----
MATCH (n:Toy|Cat|Dog|Person|Swedish) DETACH DELETE n;

CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
----
////

image:graph_label_expressions.svg[]

* xref:syntax/expressions.adoc#label-expressions-node-pattern-without-label-expressions[]
* xref:syntax/expressions.adoc#label-expressions-node-pattern-with-single-node-label[]
* xref:syntax/expressions.adoc#label-expressions-node-pattern-with-and-expression[]
* xref:syntax/expressions.adoc#label-expressions-note-pattern-with-or-expression[]
* xref:syntax/expressions.adoc#label-expressions-node-pattern-with-not-expressions[]
* xref:syntax/expressions.adoc#label-expressions-node-pattern-with-wildcard-expression[]
* xref:syntax/expressions.adoc#label-expressions-node-pattern-with-nested-label-expressions[]
* xref:syntax/expressions.adoc#label-expressions-where-clause-with-label-expression-as-predicate[]
* xref:syntax/expressions.adoc#label-expressions-with-return-clauses[]


[discrete]
[[label-expressions-node-pattern-without-label-expressions]]
=== Node pattern without label expressions

A node pattern without a label expression returns all nodes in the graph, including nodes without labels.

.+Label expression+
======

[source, cypher]
----
MATCH (n)
RETURN n.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Bob"+
| +"Charlie"+
| +"Daniel"+
| +"Eskil"+
| +"Frank"+
| +"George"+
| +"Henry"+
1+d|Rows: 8
|===

======


[discrete]
[[label-expressions-node-pattern-with-single-node-label]]
=== Node pattern with a single node label

A node pattern with a single label returns the nodes that contain the specified label.


.+Label expression+
======

[source, cypher]
----
MATCH (n:A)
RETURN n.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Daniel"+
| +"Eskil"+
| +"George"+
1+d|Rows: 4
|===

======


[discrete]
[[label-expressions-node-pattern-with-and-expression]]
=== Node pattern with an `AND` expression for the node labels

A node pattern with an `AND` expression for the node label returns the nodes that contain both of the specified labels.


.+Label expression+
======

[source, cypher]
----
MATCH (n:A&B)
RETURN n.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Daniel"+
| +"George"+
1+d|Rows: 2
|===

======


[discrete]
[[label-expressions-note-pattern-with-or-expression]]
=== Node pattern with an `OR` expression for the node labels

A match with `OR` expressions for the node label returns the nodes that contain either of the specified labels.


.+Label expression+
======

[source, cypher]
----
MATCH (n:A|B)
RETURN n.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Bob"+
| +"Daniel"+
| +"Eskil"+
| +"Frank"+
| +"George"+
1+d|Rows: 6
|===

======


[discrete]
[[label-expressions-node-pattern-with-not-expressions]]
=== Node pattern with `NOT` expressions for the node labels

A node pattern with a `NOT` expression for the node label returns the nodes that do not contain the specified label.


.+Label expression+
======

[source, cypher]
----
MATCH (n:!A)
RETURN n.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Bob"+
| +"Charlie"+
| +"Frank"+
| +"Henry"+
1+d|Rows: 4
|===

======


[discrete]
[[label-expressions-node-pattern-with-wildcard-expression]]
=== Node pattern with a `Wildcard` expression for the node labels

A node pattern with a `Wildcard` expression for the node label returns all the nodes that contain at least one label.


.+Label expression+
======

[source, cypher]
----
MATCH (n:%)
RETURN n.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Bob"+
| +"Charlie"+
| +"Daniel"+
| +"Eskil"+
| +"Frank"+
| +"George"+
1+d|Rows: 7
|===

======


[discrete]
[[label-expressions-node-pattern-with-nested-label-expressions]]
=== Node pattern with nested label expressions

A node pattern with nested label expressions returns the nodes for which the full expression is `true`.


.+Label expression+
======

[source, cypher]
----
MATCH (n:(!A&!B)|C)
RETURN n.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Charlie"+
| +"Eskil"+
| +"Frank"+
| +"George"+
| +"Henry"+
1+d|Rows: 5
|===

======


[discrete]
[[label-expressions-where-clause-with-label-expression-as-predicate]]
=== `WHERE` clause with label expressions as a predicate

A label expression can also be used as a predicate in the `WHERE` clause.


.+Label expression+
======

[source, cypher]
----
MATCH (n)
WHERE n:A|B
RETURN n.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Bob"+
| +"Daniel"+
| +"Eskil"+
| +"Frank"+
| +"George"+
1+d|Rows: 6
|===

======


[discrete]
[[label-expressions-with-return-clauses]]
=== Label expressions in the `WITH` and `RETURN` clauses

A label expression can also be used in a `WITH` or a `RETURN` clause.


.+Label expression+
======

[source, cypher]
----
MATCH (n)
RETURN n:A&B
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n:A&B+
| +false+
| +false+
| +false+
| +true+
| +false+
| +false+
| +true+
| +false+
1+d|Rows: 8
|===

======


[[relationship-type-expressions]]
== Relationship type expressions

Relationship type expressions evaluate to `true` or `false` when applied to the type of a relationship.

Assuming no other filters are applied, then a relationship type expression evaluating to `true` means the relationship is matched.

[NOTE]
====
Relationships must have exactly one type.
For example, the pattern `(a)-[r:R&Q]-(b)` or `(a)-[r:!%]-(b)` will never return any results.
====

xref:patterns/reference.adoc#variable-length-relationships[Variable-length relationships] may only have relationship type expressions consisting of `|`.
This means that `()-[r:!R*]-()` is not allowed, whereas `()-[r:Q|R*]-()` is allowed.

The following table displays whether the relationship type expression matches the relationship:

[cols="^3,^2,^2,^2"]
|===
|
3+^|*Relationship*

|*Relationship type expression* |  `[:A]` | `[:B]` | `[:C]`

| `[]`
| {check-mark}
| {check-mark}
| {check-mark}

| `[:A]`
| {check-mark}
|
|

| `[:A&B]`
|
|
|

| `[:A\|B]`
| {check-mark}
| {check-mark}
|

| `[:!A]`
|
| {check-mark}
| {check-mark}

| `[:!!A]`
| {check-mark}
|
|

| `[:A&!A]`
|
|
|

| `[:A\|!A]`
| {check-mark}
| {check-mark}
| {check-mark}

| `[:%]`
| {check-mark}
| {check-mark}
| {check-mark}

| `[:!%]`
|
|
|

| `[:%\|!%]`
| {check-mark}
| {check-mark}
| {check-mark}

| `[:%&!%]`
|
|
|

| `[:A&%]`
|
|
|

| `[:A\|%]`
| {check-mark}
| {check-mark}
| {check-mark}

|===

Label expressions cannot be combined with label syntax.
For example, `:A:B&C` will throw an error.
Instead, use either `:A&B&C` or `:A:B:C`.

*Examples:*

* xref:syntax/expressions.adoc#relationship-type-expressions-pattern-without-relationship-type-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-pattern-on-single-relationship-type[]
* xref:syntax/expressions.adoc#relationship-type-expressions-pattern-with-or-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-pattern-with-not-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-pattern-nested-type-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-pattern-predicate-type-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-pattern-with-return-type-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-case-type-label-expression[]


The following graph is used for the examples below:

image:graph_relationship_type_expressions.svg[]

////
[source, cypher, role=test-setup]
----
MATCH (_) DETACH DELETE _;
CREATE
  (:A:B)-[:R1 {name:'Teaches'}]->(:B),
  (:C)-[:R2 {name:'Studies'}]->(:D),
  (:E)-[:R3 {name:'Parents'}]->(:F)
----
////

[discrete]
[[relationship-type-expressions-pattern-without-relationship-type-expression]]
=== Relationship pattern without relationship type expression

A relationship pattern without a relationship type expression returns all relationships in the graph.


.Relationship type expressions
======

[source, cypher]
----
MATCH ()-[r]->()
RETURN r.name as name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Teaches"+
| +"Studies"+
| +"Parents"+
1+d|Rows: 3
|===

======


[discrete]
[[relationship-type-expressions-pattern-on-single-relationship-type]]
=== Relationship pattern with a single relationship type

A relationship pattern with a single relationship type returns the relationships that contain the specified type.


.Relationship type expression
======

[source, cypher]
----
MATCH ()-[r:R1]->()
RETURN r.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Teaches"+
1+d|Rows: 1
|===

======


[discrete]
[[relationship-type-expressions-pattern-with-or-expression]]
=== Relationship pattern with an `OR` expression for the relationship types

A relationship pattern with an `OR` expression for the relationship type returns all relationships that contain either of the specified types.


.Relationship type expression
======

[source, cypher]
----
MATCH ()-[r:R1|R2]->()
RETURN r.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Teaches"+
| +"Studies"+
1+d|Rows: 2
|===

======


[discrete]
[[relationship-type-expressions-pattern-with-not-expression]]
=== Relationship pattern with a `NOT` expression for the relationship types

A relationship pattern with a `NOT` expression for the relationship type returns all relationships that do not contain the specified type.


.Relationship type expression
======

[source, cypher]
----
MATCH ()-[r:!R1]->()
RETURN r.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Studies"+
| +"Parents"+
1+d|Rows: 2
|===

======


[discrete]
[[relationship-type-expressions-pattern-nested-type-expression]]
=== Relationship pattern with a nested relationship type expression

A relationship pattern with a nested relationship type expression returns all relationships for which the full expression is `true`.


.Relationship type expression
======

[source, cypher]
----
MATCH ()-[r:(!R1&!R2)|R3]->()
RETURN r.name as name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Parents"+
1+d|Rows: 1
|===

======


[discrete]
[[relationship-type-expressions-pattern-predicate-type-expression]]
=== `WHERE` clause with a relationship type expression in the predicate

A relationship type expression can also be used as a predicate in the `WHERE` clause.


.Relationship type expression
======

[source, cypher]
----
MATCH (n)-[r]->(m)
WHERE r:R1|R2
RETURN r.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Teaches"+
| +"Studies"+
1+d|Rows: 2
|===

======


[discrete]
[[relationship-type-expressions-pattern-with-return-type-expression]]
=== `WITH` and `RETURN` clauses with a relationship type expression

A relationship type expression can also be used in the `WITH` or `RETURN` clauses.


.Relationship type expression
======

[source, cypher]
----
MATCH (n)-[r]->(m)
RETURN r:R1|R2 AS result
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +true+
| +true+
| +false+
1+d|Rows: 3
|===

======


[discrete]
[[relationship-type-expressions-case-type-label-expression]]
=== `CASE` expression with relationship type and label expressions

A relationship type expression and a label expression can also be used in `CASE` expressions.


.Relationship type expression
======

[source, cypher]
----
MATCH (n)-[r]->(m)
RETURN
CASE
  WHEN n:A&B THEN 1
  WHEN r:!R1&!R2 THEN 2
  ELSE -1
END AS result
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +1+
| +-1+
| +2+
1+d|Rows: 3
|===

======

