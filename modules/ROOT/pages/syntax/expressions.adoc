:description: This section contains an overview of expressions in Cypher with examples.

[[cypher-expressions]]
= Expressions

[abstract]
--
This section contains an overview of expressions in Cypher with examples.
--

[[cypher-expressions-general]]
== Expressions in general

[NOTE]
====
Most expressions in Cypher evaluate to `null` if any of their inner expressions are `null`.
Notable exceptions are the operators `IS NULL` and `IS NOT NULL`.
====

An expression in Cypher can be:

* A decimal (integer or float) literal: `13`, `-40000`, `3.14`.
* A decimal (integer or float) literal in scientific notation: `6.022E23`.
* A hexadecimal integer literal (starting with `0x`): `0x13af`, `0xFC3A9`, `-0x66eff`.
* An octal integer literal (starting with `0o`): `0o1372`, `-0o5671`.
* A string literal: `'Hello'`, `"World"`.
* A boolean literal: `true`, `false`.
* A variable: `n`, `x`, `rel`, `myFancyVariable`, `++`A name with weird stuff in it[]!`++`.
* A property: `n.prop`, `x.prop`, `rel.thisProperty`, `++myFancyVariable.`(weird property name)`++`.
* A dynamic property: `n["prop"]`, `rel[n.city + n.zip]`, `map[coll[0]]`.
* A parameter: `$param`, `$0`.
* A list of expressions: `['a', 'b']`, `[1, 2, 3]`, `['a', 2, n.property, $param]`, `[]`.
* A function call: `length(p)`, `nodes(p)`.
* An aggregate function: `avg(x.prop)`, `+count(*)+`.
* A path-pattern: `+(a)-[r]->(b)+`, `+(a)-[r]-(b)+`, `+(a)--(b)+`, `+(a)-->()<--(b)+`.
* An operator application: `1 + 2`, `3 < 4`.
* A predicate expression is an expression that returns `true` or `false`: `a.prop = 'Hello'`, `length(p) > 10`, `a.name IS NOT NULL`.
* A special case of predicates are label and relationship type expressions: `(n:A|B)`, `()-[r:R1|R2]->()`.
* A subquery expression. For example:
`EXISTS {
  MATCH (n)-[r]->(p)
  WHERE p.name = 'Sven'
}`.
* A regular expression: `a.name =~ 'Tim.*'`.
* A case-sensitive string matching expression: `a.surname STARTS WITH 'Sven'`, `a.surname ENDS WITH 'son'` or `a.surname CONTAINS 'son'`.
* A `CASE` expression.


[[cypher-expressions-string-literals]]
== Note on string literals

String literals can contain the following escape sequences:

[options="header", cols=">1,<2", width="50%"]
|===================
|Escape sequence|Character
|`\t`|Tab
|`\b`|Backspace
|`\n`|Newline
|`\r`|Carriage return
|`\f`|Form feed
|`\'`|Single quote
|`\"`|Double quote
|`\\`|Backslash
|`\uxxxx`|Unicode UTF-16 code point (4 hex digits must follow the `\u`)
|`\Uxxxxxxxx`|Unicode UTF-32 code point (8 hex digits must follow the `\U`)
|===================


[[cypher-expressions-number-literals]]
== Note on number literals

Any number literal may contain an underscore `_` between digits.
There may be an underscore between the `0x` or `0o` and the digits for hexadecimal and octal literals.


[[query-syntax-case]]
== `CASE` expressions

Generic conditional expressions may be expressed using the `CASE` construct.
Two variants of `CASE` exist within Cypher: the simple form, which allows an expression to be compared against multiple values, and the generic form, which allows multiple conditional statements to be expressed.

[NOTE]
====
CASE can only be used as part of RETURN or WITH if you want to use the result in the succeeding clause or statement.
====

The following graph is used for the examples below:

////
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)
////

image:graph3.svg[]

[[syntax-simple-case]]
=== Simple `CASE` form: comparing an expression against multiple values

The expression is calculated, and compared in order with the `WHEN` clauses until a match is found.
If no match is found, the expression in the `ELSE` clause is returned.
However, if there is no `ELSE` case and no match is found, `null` will be returned.


*Syntax:*
[source, cypher, role=noplay, indent=0]
----
CASE test
  WHEN value THEN result
  [WHEN ...]
  [ELSE default]
END
----


*Arguments:*
[options="header"]
|===
| Name | Description

| `test`
| A valid expression.

| `value`
| An expression whose result will be compared to `test`.

| `result`
| This is the expression returned as output if `value` matches `test`.

| `default`
| If no match is found, `default` is returned.
|===


.Query
[source, cypher, indent=0]
----
MATCH (n)
RETURN
CASE n.eyes
  WHEN 'blue'  THEN 1
  WHEN 'brown' THEN 2
  ELSE 3
END AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +2+
| +1+
| +3+
| +2+
| +1+
1+d|Rows: 5
|===


[[syntax-generic-case]]
=== Generic `CASE` form: allowing for multiple conditionals to be expressed

The predicates are evaluated in order until a `true` value is found, and the result value is used.
If no match is found, the expression in the `ELSE` clause is returned.
However, if there is no `ELSE` case and no match is found, `null` will be returned.


*Syntax:*
[source, cypher, role=noplay, indent=0]
----
CASE
  WHEN predicate THEN result
  [WHEN ...]
  [ELSE default]
END
----


*Arguments:*
[options="header"]
|===
| Name | Description
| `predicate`
| A predicate that is tested to find a valid alternative.

| `result`
| This is the expression returned as output if `predicate` evaluates to `true`.

| `default`
| If no match is found, `default` is returned.
|===

////
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)
////

.Query
[source, cypher, indent=0]
----
MATCH (n)
RETURN
CASE
  WHEN n.eyes = 'blue' THEN 1
  WHEN n.age < 40      THEN 2
  ELSE 3
END AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +2+
| +1+
| +3+
| +3+
| +1+
1+d|Rows: 5
|===


[[syntax-distinguish-case]]
=== Distinguishing between when to use the simple and generic `CASE` forms

Owing to the close similarity between the syntax of the two forms, sometimes it may not be clear at the outset as to which form to use.
We illustrate this scenario by means of the following query, in which there is an expectation that `age_10_years_ago` is `-1` if `n.age` is `null`:

////
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)
////

.Query
[source, cypher, indent=0]
----
MATCH (n)
RETURN n.name,
CASE n.age
  WHEN n.age IS NULL THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
----

However, as this query is written using the simple `CASE` form, instead of `age_10_years_ago` being `-1` for the node named `Daniel`, it is `null`.
This is because a comparison is made between `n.age` and `n.age IS NULL`.
As `n.age IS NULL` is a boolean value, and `n.age` is an integer value, the `WHEN n.age IS NULL THEN -1` branch is never taken.
This results in the `ELSE n.age - 10` branch being taken instead, returning `null`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +age_10_years_ago+
| +"Alice"+ | +28+
| +"Bob"+ | +15+
| +"Charlie"+ | +43+
| +"Daniel"+ | +<null>+
| +"Eskil"+ | +31+
2+d|Rows: 5
|===

The corrected query, behaving as expected, is given by the following generic `CASE` form:

////
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)
////

.Query
[source, cypher, indent=0]
----
MATCH (n)
RETURN n.name,
CASE
  WHEN n.age IS NULL THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
----

We now see that the `age_10_years_ago` correctly returns `-1` for the node named `Daniel`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +age_10_years_ago+
| +"Alice"+ | +28+
| +"Bob"+ | +15+
| +"Charlie"+ | +43+
| +"Daniel"+ | +-1+
| +"Eskil"+ | +31+
2+d|Rows: 5
|===


[[syntax-use-case-result]]
=== Using the result of `CASE` in the succeeding clause or statement

You can use the result of `CASE` to set properties on a node or relationship.
For example, instead of specifying the node directly, you can set a property for a node selected by an expression:

////
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)
////

.Query
[source, cypher, indent=0]
----
MATCH (n)
WITH n,
CASE n.eyes
  WHEN 'blue'  THEN 1
  WHEN 'brown' THEN 2
  ELSE 3
END AS colourCode
SET n.colourCode = colourCode
----

For more information about using the `SET` clause, see xref::clauses/set.adoc[SET].

.Result
[role="queryresult",options="footer",cols="1*<m"]
|===
1+|(empty result)
1+d|Rows: 0 +
Properties set: 5
|===


[[syntax-use-case-with-null]]
=== Using `CASE` with null values

When using the simple `CASE` form, it is useful to remember that in Cypher `null = null` yields `null`.


.+CASE+
======

////
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)
////

For example, you might expect `age_10_years_ago` to be `-1` for the node named `Daniel`:

.Query
[source, cypher]
----
MATCH (n)
RETURN n.name,
CASE n.age
  WHEN null THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
----

However, as `null = null` does not yield `true`, the `WHEN null THEN -1` branch is never taken, resulting in the `ELSE n.age - 10` branch being taken instead, returning `null`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +age_10_years_ago+
| +"Alice"+ | +28+
| +"Bob"+ | +15+
| +"Charlie"+ | +43+
| +"Daniel"+ | +<null>+
| +"Eskil"+ | +31+
2+d|Rows: 5
|===

======


[[cypher-subquery-expressions]]
== Subquery expressions

Subquery expressions can appear anywhere that an expression is valid.
A subquery has a scope, as indicated by the opening and closing braces, `{` and `}`.
Any variable that is defined in the outside scope can be referenced inside the subquery's own scope.
Variables introduced inside the subquery are not part of the outside scope and therefore can't be accessed on the outside.


The following graph is used for the examples below:

.Graph
["dot", "Subquery expressions-1.svg", "neoviz", ""]
----
  N0 [
    label = "{Swedish, Person|age = 36\lname = \'Andy\'\l}"
  ]
  N0 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "HAS_DOG\nsince = 2016\l"
  ]
  N1 [
    label = "{Person|age = 25\lname = \'Timothy\'\l}"
  ]
  N2 [
    label = "{Person|age = 35\lname = \'Peter\'\l}"
  ]
  N2 -> N5 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "HAS_DOG\nsince = 2018\l"
  ]
  N2 -> N4 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "HAS_DOG\nsince = 2010\l"
  ]
  N3 [
    label = "{Dog|name = \'Andy\'\l}"
  ]
  N4 [
    label = "{Dog|name = \'Fido\'\l}"
  ]
  N4 -> N6 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "HAS_TOY\n"
  ]
  N5 [
    label = "{Dog|name = \'Ozzy\'\l}"
  ]
  N6 [
    label = "{Toy|name = \'Banana\'\l}"
  ]

----
 

[[existential-subqueries]]
=== `EXISTS` subqueries

An `EXISTS` subquery can be used to find out if a specified pattern exists at least once in the data.
It serves the same purpose as a <<filter-on-patterns, path pattern>> but is more powerful because it allows you to use `MATCH` and `WHERE` clauses internally.
Moreover, it can appear in any expression position, unlike path patterns.
If the subquery evaluates to at least one row, the whole expression will become true.
This also means that the system only needs to evaluate if there is at least one row and can skip the rest of the work.


*Syntax:*
[source, cypher, role=noplay]
EXISTS {
  MATCH [Pattern]
  WHERE [Expression]
}


It is worth noting that the `MATCH` keyword can be omitted in such subqueries and that the `WHERE` clause is optional.

[[existential-subquery-simple-case]]
==== Simple `EXISTS` subquery

Variables introduced by the outside scope can be used in the `EXISTS` subquery without importing them,
unlike the case for `CALL` subqueries, <<subquery-correlated-importing,as they require importing>>.
The following example shows this:


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(:Dog)
}
RETURN person.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
| +"Peter"+
1+d|Rows: 2
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(:Dog)
}
RETURN person.name AS name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[existential-subquery-with-where]]
==== `EXISTS` subquery with `WHERE` clause

A `WHERE` clause can be used in conjunction to the `MATCH`.
Variables introduced by the `MATCH` clause and the outside scope can be used in this scope.


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
}
RETURN person.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
}
RETURN person.name AS name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[existential-subquery-nesting]]
==== Nesting `EXISTS` subqueries

`EXISTS` subqueries can be nested like the following example shows.
The nesting also affects the scopes.
That means that it is possible to access all variables from inside the subquery which are either from the outside scope or defined in the very same subquery.


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE EXISTS {
    MATCH (dog)-[:HAS_TOY]->(toy:Toy)
    WHERE toy.name = 'Banana'
  }
}
RETURN person.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE EXISTS {
    MATCH (dog)-[:HAS_TOY]->(toy:Toy)
    WHERE toy.name = 'Banana'
  }
}
RETURN person.name AS name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[existential-subquery-outside-where]]
==== `EXISTS` subquery outside of a `WHERE` clause

`EXISTS` subquery expressions can appear anywhere that an expression is valid.
Here the result is a boolean that shows whether the subquery can find the given pattern.


.Query
[source, cypher]
----
MATCH (person:Person)
RETURN person.name AS name, EXISTS {
  MATCH (person)-[:HAS_DOG]->(:Dog)
} AS hasDog
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+ | +hasDog+
| +"Andy"+ | +true+
| +"Timothy"+ | +false+
| +"Peter"+ | +true+
2+d|Rows: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
RETURN person.name AS name, EXISTS {
  MATCH (person)-[:HAS_DOG]->(:Dog)
} AS hasDog
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[count-subqueries]]
=== `COUNT` subqueries

A `COUNT` subquery expression can be used to count the number of results of the subquery.


*Syntax:*
[source, cypher, role=noplay]
COUNT {
  MATCH [Pattern]
  WHERE [Expression]
}


It is worth noting that the `MATCH` keyword can be omitted in such subqueries and that the `WHERE` clause is optional.

[[count-subquery-simple-case]]
==== Simple `COUNT` subquery

Variables introduced by the outside scope can be used in the `COUNT` subquery without importing them,
unlike the case for `CALL` subqueries, <<subquery-correlated-importing,as they require importing>>.
The following query exemplifies this and outputs the owners of more than one dog:


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE COUNT { (person)-[:HAS_DOG]->(:Dog) } > 1
RETURN person.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE COUNT { (person)-[:HAS_DOG]->(:Dog) } > 1
RETURN person.name AS name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[count-subquery-with-where]]
==== `COUNT` subquery with `WHERE` clause

A `WHERE` clause can be used inside the `COUNT` pattern.
Variables introduced by the `MATCH` clause and the outside scope can be used in this scope.


.Query
[source, cypher]
----
MATCH (person:Person)
WHERE COUNT {
  (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
} = 1
RETURN person.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
WHERE COUNT {
  (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
} = 1
RETURN person.name AS name
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[count-subqueries-other-clauses]]
==== Using `COUNT` subqueries inside other clauses

`COUNT` can be used in any position in a query, with the exception of administration commands, where it is restricted.
See a few examples below:

[[count-subqueries-with-return]]
===== Using `COUNT` in `RETURN`


.Query
[source, cypher]
----
MATCH (person:Person)
RETURN person.name, COUNT { (person)-[:HAS_DOG]->(:Dog) } as howManyDogs
      
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +howManyDogs+
| +"Andy"+ | +1+
| +"Timothy"+ | +0+
| +"Peter"+ | +2+
2+d|Rows: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
RETURN person.name, COUNT { (person)-[:HAS_DOG]->(:Dog) } as howManyDogs
      
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[count-subqueries-with-set]]
===== Using `COUNT` in `SET`


.Query
[source, cypher]
----
MATCH (person:Person) WHERE person.name ="Andy"
SET person.howManyDogs = COUNT { (person)-[:HAS_DOG]->(:Dog) }
RETURN person.howManyDogs as howManyDogs
      
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +howManyDogs+
| +1+
1+d|Rows: 1 +
Properties set: 1
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person) WHERE person.name ="Andy"
SET person.howManyDogs = COUNT { (person)-[:HAS_DOG]->(:Dog) }
RETURN person.howManyDogs as howManyDogs
      
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[count-subqueries-with-case]]
===== Using `COUNT` in `CASE`


.Query
[source, cypher]
----
MATCH (person:Person)
RETURN
   CASE
     WHEN COUNT { (person)-[:HAS_DOG]->(:Dog) } > 1 THEN "Doglover " + person.name
     ELSE person.name
   END AS result
              
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +"Andy"+
| +"Timothy"+
| +"Doglover Peter"+
1+d|Rows: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
RETURN
   CASE
     WHEN COUNT { (person)-[:HAS_DOG]->(:Dog) } > 1 THEN "Doglover " + person.name
     ELSE person.name
   END AS result
              
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[count-subqueries-as-grouping-key]]
===== Using `COUNT` as a grouping key

The following query groups all persons by how many dogs they own,
and then calculates the average age for each group.


.Query
[source, cypher]
----
MATCH (person:Person)
RETURN COUNT { (person)-[:HAS_DOG]->(:Dog) } AS numDogs,
       avg(person.age) AS averageAge
 ORDER BY numDogs
              
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +numDogs+ | +averageAge+
| +0+ | +25.0+
| +1+ | +36.0+
| +2+ | +35.0+
2+d|Rows: 3
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', age: 25}),
(peter:Person {name: 'Peter', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})

]]></database><command><![CDATA[
MATCH (person:Person)
RETURN COUNT { (person)-[:HAS_DOG]->(:Dog) } AS numDogs,
       avg(person.age) AS averageAge
 ORDER BY numDogs
              
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]


[[label-expressions]]
== Label expressions

Label expressions evaluate to `true` or `false` when applied to the set of labels for a node.

Assuming no other filters are applied, then a label expression evaluating to `true` means the node is matched.

The following table displays whether the label expression matches the node:

.Label expression matches
[cols="^3,^2,^2,^2,^2,^2,^2,^2,^2"]
|===
|
8+^|*Node*

|*Label expression* | `()` | `(:A)` | `(:B)` | `(:C)` | `(:A:B)` | `(:A:C)` | `(:B:C)` | `(:A:B:C)`
| `()`
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:A)`
|
| {check-mark}
|
|
| {check-mark}
| {check-mark}
|
| {check-mark}

| `(:A&B)`
|
|
|
|
| {check-mark}
|
|
| {check-mark}

| `(:A\|B)`
|
| {check-mark}
| {check-mark}
|
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:!A)`
| {check-mark}
|
| {check-mark}
| {check-mark}
|
|
| {check-mark}
|

| `(:!!A)`
|
| {check-mark}
|
|
| {check-mark}
| {check-mark}
|
| {check-mark}

| `(:A&!A)`
|
|
|
|
|
|
|
|

| `(:A\|!A)`
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:%)`
|
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:!%)`
| {check-mark}
|
|
|
|
|
|
|

| `(:%\|!%)`
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:%&!%)`
|
|
|
|
|
|
|
|

| `(:A&%)`
|
| {check-mark}
|
|
| {check-mark}
| {check-mark}
|
| {check-mark}

| `(:A\|%)`
|
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}
| {check-mark}

| `(:(A&B)&!(B&C))`
|
|
|
|
| {check-mark}
|
|
|

| `(:!(A&%)&%))`
|
|
| {check-mark}
| {check-mark}
|
|
| {check-mark}
|

|===

[WARNING]
====
Label expressions cannot be combined with label syntax.
For example, `:A:B&C` will throw an error.
Instead, use either `:A&B&C` or `:A:B:C`.
====

The following graph is used for the examples below:

////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

image:graph_label_expressions.svg[]


*Examples:*

* xref:syntax/expressions.adoc#label-expressions-match-without-label-expression[]
* xref:syntax/expressions.adoc#label-expressions-match-on-single-node-label[]
* xref:syntax/expressions.adoc#label-expressions-match-and-expression[]
* xref:syntax/expressions.adoc#label-expressions-match-or-expression[]
* xref:syntax/expressions.adoc#label-expressions-match-not-expression[]
* xref:syntax/expressions.adoc#label-expressions-match-wildcard-expression[]
* xref:syntax/expressions.adoc#label-expressions-match-nesting-label-expression[]
* xref:syntax/expressions.adoc#label-expressions-match-predicate-label-expression[]
* xref:syntax/expressions.adoc#label-expressions-match-return-label-expression[]


[discrete]
[[label-expressions-match-without-label-expression]]
=== Match without label expression

A match without a label expression returns all nodes in the graph, non withstanding if the node is empty.

.+Label expression+
======
////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n)
RETURN n.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Bob"+
| +"Charlie"+
| +"Daniel"+
| +"Eskil"+
| +"Frank"+
| +"George"+
| +"Henry"+
1+d|Rows: 8
|===

======


[discrete]
[[label-expressions-match-on-single-node-label]]
=== Match on single node label

A match on a single node label returns the nodes that contains the specified label.


.+Label expression+
======
////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n:A)
RETURN n.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Daniel"+
| +"Eskil"+
| +"George"+
1+d|Rows: 4
|===

======


[discrete]
[[label-expressions-match-and-expression]]
=== Match with an `AND` expression for the node labels

A match with an `AND` expression for the node label returns the nodes that contains both the specified labels.


.+Label expression+
======

////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n:A&B)
RETURN n.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Daniel"+
| +"George"+
1+d|Rows: 2
|===

======


[discrete]
[[label-expressions-match-or-expression]]
=== Match with an `OR` expression for the node labels

A match with an `OR` expression for the node label returns the nodes that contains either of the specified labels.


.+Label expression+
======

////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n:A|B)
RETURN n.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Bob"+
| +"Daniel"+
| +"Eskil"+
| +"Frank"+
| +"George"+
1+d|Rows: 6
|===

======


[discrete]
[[label-expressions-match-not-expression]]
=== Match with a `NOT` expression for the node labels

A match with a `NOT` expression for the node label returns the nodes that does not contain the specified label.


.+Label expression+
======

////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n:!A)
RETURN n.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Bob"+
| +"Charlie"+
| +"Frank"+
| +"Henry"+
1+d|Rows: 4
|===

======


[discrete]
[[label-expressions-match-wildcard-expression]]
=== Match with a `Wildcard` expression for the node labels

A match with a `Wildcard` expression for the node label returns the nodes that contains any label.


.+Label expression+
======

////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n:%)
RETURN n.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Bob"+
| +"Charlie"+
| +"Daniel"+
| +"Eskil"+
| +"Frank"+
| +"George"+
1+d|Rows: 7
|===

======


[discrete]
[[label-expressions-match-nesting-label-expression]]
=== Match with a nesting of label expressions for the node labels

A match with a nesting of label expressions for the node label returns the nodes for which the full expression is `true`.


.+Label expression+
======

////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n:(!A&!B)|C)
RETURN n.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Charlie"+
| +"Eskil"+
| +"Frank"+
| +"George"+
| +"Henry"+
1+d|Rows: 5
|===

======


[discrete]
[[label-expressions-match-predicate-label-expression]]
=== Match with label expressions in the predicate

A label expression can also be used as a predicate in the `WHERE` clause.


.+Label expression+
======

////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n)
WHERE n:A|B
RETURN n.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Alice"+
| +"Bob"+
| +"Daniel"+
| +"Eskil"+
| +"Frank"+
| +"George"+
1+d|Rows: 6
|===

======


[discrete]
[[label-expressions-match-return-label-expression]]
=== Match with label expressions in the return

A label expression can also be used in the `WITH` or `RETURN` statement.


.+Label expression+
======

////
CREATE
  (:A {name:'Alice'}),
  (:B {name:'Bob'}),
  (:C {name:'Charlie'}),
  (:A:B {name:'Daniel'}),
  (:A:C {name:'Eskil'}),
  (:B:C {name:'Frank'}),
  (:A:B:C {name:'George'}),
  ({name:'Henry'})
////

.Query
[source, cypher]
----
MATCH (n)
RETURN n:A&B
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +n:A&B+
| +false+
| +false+
| +false+
| +true+
| +false+
| +false+
| +true+
| +false+
1+d|Rows: 8
|===

======


[[relationship-type-expressions]]
== Relationship type expressions

Relationship type expressions evaluate to `true` or `false` when applied to the type of a relationship.
 
Assuming no other filters are applied, then a relationship type expression evaluating to `true` means the relationship is matched.

[IMPORTANT]
====
Relationships must have exactly one type.
So for example the expressions: `(a)-[r:R&Q]-(b)` or `(a)-[r:!%]-(b)` will never return any results.
====

[NOTE]
====
<<cypher-pattern-varlength, Variable length relationships>> may only have relationship type expressions consisting of `|`.
That means that `()-[r:!R*]-()` is not allowed, whereas `()-[r:Q|R*]-()` is allowed.
====


The following table displays whether the relationship type expression matches the relationship:

[cols="^3,^2,^2,^2"]
|===
|
3+^|*Relationship*

|*Relationship type expression* |  `[:A]` | `[:B]` | `[:C]`

| `[]`
| {check-mark}
| {check-mark}
| {check-mark}

| `[:A]`
| {check-mark}
|
|

| `[:A&B]`
|
|
|

| `[:A\|B]`
| {check-mark}
| {check-mark}
|

| `[:!A]`
|
| {check-mark}
| {check-mark}

| `[:!!A]`
| {check-mark}
|
|

| `[:A&!A]`
|
|
|

| `[:A\|!A]`
| {check-mark}
| {check-mark}
| {check-mark}

| `[:%]`
| {check-mark}
| {check-mark}
| {check-mark}

| `[:!%]`
|
|
|

| `[:%\|!%]`
| {check-mark}
| {check-mark}
| {check-mark}

| `[:%&!%]`
|
|
|

| `[:A&%]`
|
|
|

| `[:A\|%]`
| {check-mark}
| {check-mark}
| {check-mark}

|===


*Examples:*

* xref:syntax/expressions.adoc#relationship-type-expressions-match-without-relationship-type-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-match-on-single-relationship-type[]
* xref:syntax/expressions.adoc#relationship-type-expressions-match-or-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-match-not-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-match-nesting-type-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-match-predicate-type-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-match-return-type-expression[]
* xref:syntax/expressions.adoc#relationship-type-expressions-match-case-type-expression[]


The following graph is used for the examples below:

image:graph_relationship_type_expressions.svg[]


[discrete]
[[relationship-type-expressions-match-without-relationship-type-expression]]
=== Match without relationship type expression

A match without a relationship type expression returns all relationships in the graph.


.Relationship type expression
======

////
CREATE
  (:A:B)-[:R1 {name:'Teaches'}]->(:B),
  (:C)-[:R2 {name:'Studies'}]->(:D),
  (:E)-[:R3 {name:'Parents'}]->(:F)
////

.Query
[source, cypher]
----
MATCH ()-[r]->()
RETURN r.name as name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Teaches"+
| +"Studies"+
| +"Parents"+
1+d|Rows: 3
|===

======


[discrete]
[[relationship-type-expressions-match-on-single-relationship-type]]
=== Match on single relationship type

A match on a single relationship type returns the relationships that contains the specified type.


.Relationship type expression
======

////
CREATE
  (:A:B)-[:R1 {name:'Teaches'}]->(:B),
  (:C)-[:R2 {name:'Studies'}]->(:D),
  (:E)-[:R3 {name:'Parents'}]->(:F)
////

.Query
[source, cypher]
----
MATCH ()-[r:R1]->()
RETURN r.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Teaches"+
1+d|Rows: 1
|===

======


[discrete]
[[relationship-type-expressions-match-or-expression]]
=== Match with an `OR` expression for the relationship types

A match with an `OR` expression for the relationship type returns the relationships that contains either of the specified types.


.Relationship type expression
======

.Query
[source, cypher]
----
MATCH ()-[r:R1|R2]->()
RETURN r.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Teaches"+
| +"Studies"+
1+d|Rows: 2
|===

======


[discrete]
[[relationship-type-expressions-match-not-expression]]
=== Match with a `NOT` expression for the relationship types

A match with a `NOT` expression for the relationship type returns the relationships that does not contain the specified type.


.Relationship type expression
======

////
CREATE
  (:A:B)-[:R1 {name:'Teaches'}]->(:B),
  (:C)-[:R2 {name:'Studies'}]->(:D),
  (:E)-[:R3 {name:'Parents'}]->(:F)
////

.Query
[source, cypher]
----
MATCH ()-[r:!R1]->()
RETURN r.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Studies"+
| +"Parents"+
1+d|Rows: 2
|===

======


[discrete]
[[relationship-type-expressions-match-nesting-type-expression]]
=== Match with a nesting of relationship type expressions for the relationship types

A match with a nesting of relationship type expressions for the relationship type returns the nodes for which the full expression is `true`.


.Relationship type expression
======

////
CREATE
  (:A:B)-[:R1 {name:'Teaches'}]->(:B),
  (:C)-[:R2 {name:'Studies'}]->(:D),
  (:E)-[:R3 {name:'Parents'}]->(:F)
////

.Query
[source, cypher]
----
MATCH ()-[r:(!R1&!R2)|R3]->()
RETURN r.name as name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Parents"+
1+d|Rows: 1
|===

======


[discrete]
[[relationship-type-expressions-match-predicate-type-expression]]
=== Match with relationship type expressions in the predicate

A relationship type expression can also be used as a predicate in the `WHERE` clause.


.Relationship type expression
======

////
CREATE
  (:A:B)-[:R1 {name:'Teaches'}]->(:B),
  (:C)-[:R2 {name:'Studies'}]->(:D),
  (:E)-[:R3 {name:'Parents'}]->(:F)
////

.Query
[source, cypher]
----
MATCH (n)-[r]->(m)
WHERE r:R1|R2
RETURN r.name AS name
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Teaches"+
| +"Studies"+
1+d|Rows: 2
|===

======


[discrete]
[[relationship-type-expressions-match-return-type-expression]]
=== Match with relationship type expression in the return

A relationship type expression can also be used in the `WITH` or `RETURN` statement.


.Relationship type expression
======

////
CREATE
  (:A:B)-[:R1 {name:'Teaches'}]->(:B),
  (:C)-[:R2 {name:'Studies'}]->(:D),
  (:E)-[:R3 {name:'Parents'}]->(:F)
////

.Query
[source, cypher]
----
MATCH (n)-[r]->(m)
RETURN r:R1|R2 AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +true+
| +true+
| +false+
1+d|Rows: 3
|===

======


[discrete]
[[relationship-type-expressions-match-case-type-expression]]
=== Match with relationship type expression and node label expression in a case

A relationship type expression and a label expression can also be used in a case statement.


.Relationship type expression
======

////
CREATE
  (:A:B)-[:R1 {name:'Teaches'}]->(:B),
  (:C)-[:R2 {name:'Studies'}]->(:D),
  (:E)-[:R3 {name:'Parents'}]->(:F)
////

.Query
[source, cypher]
----
MATCH (n)-[r]->(m)
RETURN
CASE
  WHEN n:A&B THEN 1
  WHEN r:!R1&!R2 THEN 2
  ELSE -1
END AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +1+
| +-1+
| +2+
1+d|Rows: 3
|===

======

