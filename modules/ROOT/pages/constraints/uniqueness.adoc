:description: Information about Neo4j's uniqueness constraints.
include::https://raw.githubusercontent.com/neo4j-graphacademy/courses/main/asciidoc/courses/cypher-indexes-constraints/ad.adoc[]
= Uniqueness constraints

Uniqueness constraints ensure that property values are unique for all nodes with a specific label or all relationships with a specific type.
For property uniqueness constraints on multiple properties, the combination of the property values is unique.
Property uniqueness constraints do not require all nodes relationships to have a unique value for the properties listed (nodes without all properties on which the constraint exists are not subject to this rule).

[[create-uniqueness-constraints]]
== Create uniqueness constraints

Uniqueness constraints are created with the `CREATE CONSTRAINT` command.
When creating a uniqueness constraint, it is recommended to provide a constraint name.

[NOTE]
Creating a constraint requires the link:{neo4j-docs-base-uri}/operations-manual/{page-version}/authentication-authorization/database-administration/#access-control-database-administration-constraints[`CREATE CONSTRAINT` privilege].

.Create a node property uniqueness constraint on a single property
======

.Query
[source, cypher]
----
CREATE CONSTRAINT book_isbn
FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

.Result
[queryresult]
----
Added 1 constraint.
----

[NOTE]
====
The detailed statistics view currently says `Unique constraints added: 1`.
It will be updated to say `Node property uniqueness constraints added: 1` in Neo4j 6.0.
====

======


.Create a relationship property uniqueness constraint on a single property
======

A relationship property uniqueness constraint ensures that certain relationships have a set of specified properties whose combined value is unique when all properties exist on the relationship.

.Query
[source, cypher]
----
CREATE CONSTRAINT sequels
FOR ()-[sequel:SEQUEL_OF]-() REQUIRE (sequel.order, sequel.seriesTitle) IS UNIQUE
----

.Result
[queryresult]
----
Added 1 constraint.
----

[NOTE]
====
The detailed statistics view currently says `Relationship uniqueness constraints added: 1`.
It will be updated to say `Relationship property uniqueness constraints added: 1` in Neo4j 6.0.
====

======

[[create-composite-uniqueness-constraints]]
=== Create composite uniqueness constraints


[role=label--new-5.16]
[[create-uniqueness-constraint-with-parameters]]
=== Create uniqueness constraints using parameters

The constraint name can also be given as a parameter.

.Create a node property uniqueness constraint using a parameter
======

.Parameters
[source, parameters]
----
{
  "name": "node_uniqueness_param"
}
----

.Query
[source, cypher]
----
CREATE CONSTRAINT $name
FOR (book:Book) REQUIRE book.prop1 IS UNIQUE
----

.Result
[queryresult]
----
Added 1 constraint.
----

======


.Create a relationship property uniqueness constraint using a parameter
======

.Parameters
[source, parameters]
----
{
  "name": "rel_uniqueness_param"
}
----

.Query
[source, cypher]
----
CREATE CONSTRAINT $name
FOR ()-[sequel:SEQUEL_OF]-() REQUIRE (sequel.prop1) IS UNIQUE
----

.Result
[queryresult]
----
Added 1 constraint.
----

======


[[create-uniqueness-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail.
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and that no constraint is created if any other constraint with the given name, or another node property uniqueness constraint on the same schema, already exists.
As of Neo4j 5.17, an informational notification is instead returned showing the existing constraint which blocks the creation.

.Create a node property uniqueness constraint when a constraint with the same name exists
======

.Query
[source, cypher]
----
CREATE CONSTRAINT book_isbn2 IF NOT EXISTS
FOR (book:Book) REQUIRE book.isbn2 IS UNIQUE
----

Assuming no constraint with the given name or other node property uniqueness constraint on the same schema already exists, the query will return:

.Result
[queryresult]
----
Added 1 constraint.
----

======


.Create a relationship property uniqueness constraint when a constraint with the same name exists
======

.Query
[source, cypher]
----
CREATE CONSTRAINT sequels IF NOT EXISTS
FOR ()-[sequel:SEQUEL_OF]-() REQUIRE (sequel.order) IS UNIQUE
----

Assuming a constraint with the name `sequels` already exists:

.Result
[queryresult]
----
(no changes, no records)
----

.Notification
[source]
----
`CREATE CONSTRAINT sequels IF NOT EXISTS FOR ()-[e:SEQUEL_OF]-() REQUIRE (e.order) IS UNIQUE` has no effect.
`CONSTRAINT sequels FOR ()-[e:SEQUEL_OF]-() REQUIRE (e.order, e.seriesTitle) IS UNIQUE` already exists.
----

======

[[uniqueness-constraints-and-indexes]]
=== Uniqueness constraints and indexes

Uniqueness constraints are backed by xref:indexes/search-performance-indexes/managing-indexes.adoc#create-range-index[range indexes].
This means that creating a key constraint will create a range index with the same name as its owning constraint.

A uniqueness constraint requires an index because it allows the system to quickly check if a node with the same label and property value or a relationship with the same type and property value already exists.
Without an index, the system would need to scan all nodes with the same label, which would be slow and inefficient, especially as the graph grows.
The index makes these checks much faster by enabling direct lookups instead of scanning the entire graph.
For more information about how indexes impact performance, see xref:

These indexes can be viewed in the `owningConstraint` column returned by the xref:indexes/search-performance-indexes/managing-indexes.adoc#list-indexes[`SHOW INDEX`] command, and the `ownedIndex` column returned by the xref:constraints/list-drop-constraints.adoc#list-constraints[`SHOW CONSTRAINT`] command.

[[create-uniqueness-constraint-with-index-provider]]
==== Specifying an index provider when creating a constraint

To create a property uniqueness constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]

// Only one valid value exists for the index provider in Neo4j 5.0


.Create a node property uniqueness constraint with a specified index provider
======

.Query
[source, cypher]
----
CREATE CONSTRAINT constraint_with_options
FOR (book:Book) REQUIRE (book.prop1, book.prop2) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
Added 1 constraint.
----

======

.Create a relationship property uniqueness constraint with a specified index provider
======

.Query
[source, cypher]
----
CREATE CONSTRAINT rel_constraint_with_options
FOR ()-[sequel:SEQUEL_OF]-() REQUIRE (sequel.order, sequel.seriesTitle, sequel.number) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0'
}
----

======

There is no valid index configuration values for the constraint-backing range indexes.

[[create-data-that-complies-with-uniqueness-constraint]]
=== Create data that complies with existing uniqueness constraints

.Create a node that complies with existing uniqueness constraint
======

Create a `Book` node with an `isbn` that is not already in the graph:

.Query
[source, cypher]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

.Result
[queryresult]
----
Added 1 label, created 1 node, set 2 properties
----

======


.Create a relationship that complies with existing uniqueness constraint
======

Create a `SEQUEL_OF` relationship with values for properties `order` and `seriesTitle` that are not already in the graph:

.Query
[source, cypher]
----
CREATE (:Book {title: 'Spirit Walker'})-[:SEQUEL_OF {order: 1, seriesTitle: 'Chronicles of Ancient Darkness'}]->(:Book {title: 'Wolf Brother'})
----

.Result
[queryresult]
----
Added 2 labels, created 2 nodes, set 4 properties, created 1 relationship.
----

======

[[node-uniqueness-constraint-fail-cases]]
== Fail cases

* xref:constraints/uniqueness.adoc#create-an-already-existing-uniqueness-constraint[]
* xref:constraints/uniqueness.adoc#create-uniqueness-constraint-on-same-schema-as-existing-index[]
* xref:constraints/uniqueness.adoc#create-uniqueness-constraint-on-same-schema-as-existing-index[]
[]
* xref:constraints/uniqueness.adoc#fail-to-create-a-uniqueness-constraint-due-to-conflicting-data[]


create-data-that-violates-a-uniqueness-constraint
[discrete]
[[create-an-already-existing-uniqueness-constraint]]
=== Creating already existing uniqueness constraints will fail


.Create an already existing node property uniqueness constraint
======

Create a property uniqueness constraint on the property `published` on nodes with the `Book` label, when that constraint already exists:

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT preExisting_book_published FOR (book:Book) REQUIRE book.published IS UNIQUE
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT book_published FOR (book:Book) REQUIRE book.published IS UNIQUE
----

In this case, the constraint cannot be created because it already exists.

.Error message
[source, error]
----
Constraint already exists:
Constraint( id=4, name='preExisting_book_published', type='UNIQUENESS', schema=(:Book {published}), ownedIndex=3 )
----

[NOTE]
====
The constraint type will be updated to say `NODE PROPERTY UNIQUENESS` in Neo4j 6.0.
====

======


.Create an already existing relationship property uniqueness constraint
======

Create a property uniqueness constraint on the properties `order` and `seriesTitle` on relationships with the `SEQUEL_OF` relationship type, when that constraint already exists:

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT sequel_order_seriestitle FOR ()-[sequel:SEQUEL_OF]-() REQUIRE (sequel.order, sequel.seriesTitle) IS UNIQUE
----

In this case, the constraint cannot be created because it already exists.

.Error message
[source, error]
----
Constraint already exists:
Constraint( id=13, name='sequels', type='RELATIONSHIP UNIQUENESS', schema=()-[:SEQUEL_OF {order, seriesTitle}]-(), ownedIndex=12 )
----

[NOTE]
====
The constraint type will be updated to say `RELATIONSHIP PROPERTY UNIQUENESS` in Neo4j 6.0.
====

======

[discrete]
[[create-uniqueness-constraint-on-same-schema-as-existing-index]]
=== Creating uniqueness constraints on the same schema as an existing index will fail


.Creating a node property uniqueness constraint on the same name as an existing index
======

Create a property uniqueness constraint on the property `wordCount` on nodes with the `Book` label, when an index already exists on that label and property combination:

////
[source, cypher, role=test-setup]
----
CREATE INDEX preExisting_book_word_count FOR (book:Book) ON (book.wordCount)
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT book_word_count FOR (book:Book) REQUIRE book.wordCount IS UNIQUE
----

In this case, the constraint cannot be created because there already exists an index covering that schema.

.Error message
[source, error]
----
There already exists an index (:Book {wordCount}).
A constraint cannot be created until the index has been dropped.
----

======

.Creating a relationship property key constraint on the same name as an existing index
======

Create a property uniqueness constraint on the property `order` on relationships with the `SEQUEL_OF` relationship type, when an index already exists on that relationship type and property combination:

////
[source, cypher, role=test-setup]
----
CREATE INDEX sequel_order FOR ()-[sequel:SEQUEL_OF]-() ON (sequel.order)
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT sequel_series_title FOR ()-[sequel:SEQUEL_OF]-() REQUIRE (sequel.order) IS UNIQUE
----

In this case, the constraint cannot be created because there already exists an index covering that schema.

.Error message
[source, error]
----
There already exists an index ()-[:SEQUEL_OF {order}]-().
A constraint cannot be created until the index has been dropped.
----

======

[discrete]
[[create-data-that-violates-a-uniqueness-constraint]]
=== Creating data that violates existing constraints will fail


.Create a node that violates existing node property uniqueness constraint
======

Create a `Book` node with an `isbn` that is already used in the graph:

.Query
[source, cypher, role=test-fail]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

In this case, the node is not created because the `isbn` property is in conflict with an existing constraint.

.Error message
[source, error]
----
Node(0) already exists with label `Book` and property `isbn` = '1449356265'
----

======


.Create a relationship that violates existing relaltionship property uniqueness constraint
======

Create a `SEQUEL_OF` relationship with values for properties `order` and `seriesTitle` that are already used in the graph:

.Query
[source, cypher, role=test-fail]
----
MATCH (wolfBrother:Book {title: 'Wolf Brother'}), (spiritWalker:Book {title: 'Spirit Walker'})
CREATE (spiritWalker)-[:SEQUEL_OF {order: 1, seriesTitle: 'Chronicles of Ancient Darkness'}]->(wolfBrother)
----

In this case, the relationship is not created because the combination of the `order` and `seriesTitle` properties are in conflict with an existing constraint.

.Error message
[source, error]
----
Relationship(0) already exists with type `SEQUEL_OF` and properties `order` = 1, `seriesTitle` = 'Chronicles of Ancient Darkness'
----

======

[discrete]
[[fail-to-create-a-uniqueness-constraint-due-to-conflicting-data]]
=== Creating uniqueness constraints when there exists conflicting data will fail


.Create a node property uniqueness constraint when conflicting nodes exist
======

Create a property uniqueness constraint on the property `title` on nodes with the `Book` label, when there are two nodes with the same `title`:

////
[source, cypher, role=test-setup]
----
CREATE (book:Book {isbn: '9780393972832', title: 'Moby Dick'});
CREATE (book:Book {isbn: '9780763630188', title: 'Moby Dick'})
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT book_title FOR (book:Book) REQUIRE book.title IS UNIQUE
----

In this case, the constraint cannot be created because it is in conflict with the existing graph.
Either use xref:indexes/search-performance-indexes/managing-indexes.adoc[] instead, or remove/correct the offending nodes and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( name='book_title', type='UNIQUENESS', schema=(:Book {title}) ):
Both Node(0) and Node(1) have the label `Book` and property `title` = 'Moby Dick'
----

The constraint creation fails on the first offending nodes that are found.
This does not guarantee that there are no other offending nodes in the graph.
Therefore, all the data should be checked and cleaned up before re-attempting the constraint creation.

This is an example `MATCH` query to find all offending nodes with the non-unique property values for the constraint above:

.Query
[source, cypher]
----
MATCH (book1:Book), (book2:Book)
WHERE book1.title = book2.title AND NOT book1 = book2
RETURN book1, book2
----

======


.Create a relationship property uniqueness constraint when conflicting relationships exist
======

Create a property uniqueness constraint on the property `seriesTitle` on relationships with the `SEQUEL_OF` relationship type, when two relationships with the same `seriesTitle` already exist:

////
[source, cypher, role=test-setup]
----
MATCH (spiritWalker:Book {title: 'Spirit Walker'})
CREATE (:Book {title: 'Soul Eater'})-[:SEQUEL_OF {order: 2, seriesTitle: 'Chronicles of Ancient Darkness'}]->(spiritWalker)
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT series_title FOR ()-[sequel:SEQUEL_OF]-() REQUIRE (sequel.seriesTitle) IS UNIQUE
----

In this case, the constraint cannot be created because it is in conflict with the existing graph.
Either use xref:indexes/search-performance-indexes/managing-indexes.adoc[] instead, or remove/correct the offending relationships and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( name='series_title', type='RELATIONSHIP UNIQUENESS', schema=()-[:SEQUEL_OF {seriesTitle}]-() ):
Both Relationship(0) and Relationship(1) have the type `SEQUEL_OF` and property `seriesTitle` = 'Chronicles of Ancient Darkness'
----

The constraint creation fails on the first offending relationships that are found.
This does not guarantee that there are no other offending relationships in the graph.
Therefore, all the data should be checked and cleaned up before re-attempting the constraint creation.

This is an example `MATCH` query to find all offending relationships for the constraint above:

.Query
[source, cypher]
----
MATCH ()-[knows1:KNOWS]->(), ()-[knows2:KNOWS]->()
WHERE knows1.level = knows2.level AND NOT knows1 = knows2
RETURN knows1, knows2
----

======