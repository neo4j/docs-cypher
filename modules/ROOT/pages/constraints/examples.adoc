[[administration-constraints-examples]]
= Examples
:description: Examples of how to manage constraints used for ensuring data integrity. 

[[administration-constraints-unique-nodes]]
== Unique node property constraints

[discrete]
[[administration-constraints-create-a-unique-constraint]]
== Create a unique constraint ==
When creating a unique constraint, a name can be provided. The constraint ensures that your database will never contain more than one node with a specific label and one property value.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_name ON (book:Book) ASSERT book.isbn IS UNIQUE
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_name ON (book:Book) ASSERT book.isbn IS UNIQUE
----


[discrete]
[[administration-constraints-create-a-unique-constraint-only-if-it-does-not-already-exist]]
== Create a unique constraint only if it does not already exist ==
If it is unknown if a constraint exists or not but we want to make sure it does, we add the `IF NOT EXISTS`. The uniqueness constraint ensures that your database will never contain more than one node with a specific label and one property value.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS ON (book:Book) ASSERT book.isbn IS UNIQUE
----


Note no constraint will be created if any other constraint with that name or another uniqueness constraint on the same schema already exists. Assuming no such constraints existed:

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_name IF NOT EXISTS ON (book:Book) ASSERT book.isbn IS UNIQUE
----


[discrete]
[[administration-constraints-create-a-unique-constraint-with-specified-index-provider-and-configuration]]
== Create a unique constraint with specified index provider and configuration ==
To create a unique constraint with a specific index provider and configuration for the backing index, the `OPTIONS` clause is used.
Valid values for the index provider is `native-btree-1.0` and `lucene+native-3.0`, default if nothing is specified is `native-btree-1.0`.
Valid configuration settings are `spatial.cartesian.min`, `spatial.cartesian.max`, `spatial.cartesian-3d.min`, `spatial.cartesian-3d.max`,
`spatial.wgs-84.min`, `spatial.wgs-84.max`, `spatial.wgs-84-3d.min`, and `spatial.wgs-84-3d.max`.
Non-specified settings get their respective default values.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_with_options ON (n:Label) ASSERT n.prop IS UNIQUE
OPTIONS {
 indexProvider: 'lucene+native-3.0',
 indexConfig: {`spatial.wgs-84.min`: [-100.0, -80.0], `spatial.wgs-84.max`: [100.0, 80.0]}
}
----


Specifying index provider and configuration can be done individually.

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_with_options ON (n:Label) ASSERT n.prop IS UNIQUE
OPTIONS {
 indexProvider: 'lucene+native-3.0',
 indexConfig: {`spatial.wgs-84.min`: [-100.0, -80.0], `spatial.wgs-84.max`: [100.0, 80.0]}
}
----


[discrete]
[[administration-constraints-create-a-node-that-complies-with-unique-property-constraints]]
== Create a node that complies with unique property constraints ==
Create a `Book` node with an `isbn` that isn't already in the database.

.Query
[source,cypher]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1
----



[discrete]
[[administration-constraints-create-a-node-that-violates-a-unique-property-constraint]]
== Create a node that violates a unique property constraint ==
Create a `Book` node with an `isbn` that is already used in the database.

.Query
[source,cypher]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----


In this case the node isn't created in the graph.

.Error message
[source]
----
Node(0) already exists with label `Book` and property `isbn` = '1449356265'
----



[discrete]
[[administration-constraints-failure-to-create-a-unique-property-constraint-due-to-conflicting-nodes]]
== Failure to create a unique property constraint due to conflicting nodes ==
Create a unique property constraint on the property `isbn` on nodes with the `Book` label when there are two nodes with the same `isbn`.

.Query
[source,cypher]
----
CREATE CONSTRAINT ON (book:Book) ASSERT book.isbn IS UNIQUE
----


In this case the constraint can't be created because it is violated by existing data. We may choose to use xref:indexes-for-search-performance.adoc[] instead or remove the offending nodes and then re-apply the constraint.

.Error message
[source]
----
Unable to create Constraint( name='constraint_ca412c3d', type='UNIQUENESS',
schema=(:Book {isbn}) ):
Both Node(0) and Node(1) have the label `Book` and property `isbn` = '1449356265'
----




[role=enterprise-edition]
[[administration-constraints-prop-exist-nodes]]
== Node property existence constraints

[discrete]
[[administration-constraints-create-a-node-property-existence-constraint]]
== Create a node property existence constraint ==
When creating a node property existence constraint, a name can be provided. The constraint ensures that all nodes with a certain label have a certain property.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_name ON (book:Book) ASSERT book.isbn IS NOT NULL
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints added: 1
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_name ON (book:Book) ASSERT book.isbn IS NOT NULL
----


[discrete]
[[administration-constraints-create-a-node-property-existence-constraint-only-if-it-does-not-already-exist]]
== Create a node property existence constraint only if it does not already exist ==
If it is unknown if a constraint exists or not but we want to make sure it does, we add the `IF NOT EXISTS`. The node property existence constraint ensures that all nodes with a certain label have a certain property.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS ON (book:Book) ASSERT book.isbn IS NOT NULL
----


Note no constraint will be created if any other constraint with that name or another node property existence constraint on the same schema already exists. Assuming a constraint with the name `constraint_name` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_name IF NOT EXISTS ON (book:Book) ASSERT book.isbn IS NOT NULL
----


[discrete]
[[administration-constraints-create-a-node-that-complies-with-property-existence-constraints]]
== Create a node that complies with property existence constraints ==
Create a `Book` node with an `isbn` property.

.Query
[source,cypher]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1
----



[discrete]
[[administration-constraints-create-a-node-that-violates-a-property-existence-constraint]]
== Create a node that violates a property existence constraint ==
Trying to create a `Book` node without an `isbn` property, given a property existence constraint on `:Book(isbn)`.

.Query
[source,cypher]
----
CREATE (book:Book {title: 'Graph Databases'})
----


In this case the node isn't created in the graph.

.Error message
[source]
----
Node(0) with label `Book` must have the property `isbn`
----



[discrete]
[[administration-constraints-removing-an-existence-constrained-node-property]]
== Removing an existence constrained node property ==
Trying to remove the `isbn` property from an existing node `book`, given a property existence constraint on `:Book(isbn)`.

.Query
[source,cypher]
----
MATCH (book:Book {title: 'Graph Databases'}) REMOVE book.isbn
----


In this case the property is not removed.

.Error message
[source]
----
Node(0) with label `Book` must have the property `isbn`
----



[discrete]
[[administration-constraints-failure-to-create-a-node-property-existence-constraint-due-to-existing-node]]
== Failure to create a node property existence constraint due to existing node ==
Create a constraint on the property `isbn` on nodes with the `Book` label when there already exists  a node without an `isbn`.

.Query
[source,cypher]
----
CREATE CONSTRAINT ON (book:Book) ASSERT book.isbn IS NOT NULL
----


In this case the constraint can't be created because it is violated by existing data. We may choose to remove the offending nodes and then re-apply the constraint.

.Error message
[source]
----
Unable to create Constraint( type='NODE PROPERTY EXISTENCE', schema=(:Book
{isbn}) ):
Node(0) with label `Book` must have the property `isbn`
----




[role=enterprise-edition]
[[administration-constraints-prop-exist-rels]]
== Relationship property existence constraints

[discrete]
[[administration-constraints-create-a-relationship-property-existence-constraint]]
== Create a relationship property existence constraint ==
When creating a relationship property existence constraint, a name can be provided. The constraint ensures all relationships with a certain type have a certain property.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_name ON ()-[like:LIKED]-() ASSERT like.day IS NOT NULL
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints added: 1
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_name ON ()-[like:LIKED]-() ASSERT like.day IS NOT NULL
----


[discrete]
[[administration-constraints-create-a-relationship-property-existence-constraint-only-if-it-does-not-already-exist]]
== Create a relationship property existence constraint only if it does not already exist ==
If it is unknown if a constraint exists or not but we want to make sure it does, we add the `IF NOT EXISTS`. The relationship property existence constraint ensures all relationships with a certain type have a certain property.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS ON ()-[like:LIKED]-() ASSERT like.day IS NOT NULL
----


Note no constraint will be created if any other constraint with that name or another relationship property existence constraint on the same schema already exists. Assuming a constraint with the name `constraint_name` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_name IF NOT EXISTS ON ()-[like:LIKED]-() ASSERT like.day IS NOT NULL
----


[discrete]
[[administration-constraints-create-a-relationship-that-complies-with-property-existence-constraints]]
== Create a relationship that complies with property existence constraints ==
Create a `LIKED` relationship with a `day` property.

.Query
[source,cypher]
----
CREATE (user:User)-[like:LIKED {day: 'yesterday'}]->(book:Book)
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 2
Relationships created: 1
Properties set: 1
Labels added: 2
----



[discrete]
[[administration-constraints-create-a-relationship-that-violates-a-property-existence-constraint]]
== Create a relationship that violates a property existence constraint ==
Trying to create a `LIKED` relationship without a `day` property, given a property existence constraint `:LIKED(day)`.

.Query
[source,cypher]
----
CREATE (user:User)-[like:LIKED]->(book:Book)
----


In this case the relationship isn't created in the graph.

.Error message
[source]
----
Relationship(0) with type `LIKED` must have the property `day`
----



[discrete]
[[administration-constraints-removing-an-existence-constrained-relationship-property]]
== Removing an existence constrained relationship property ==
Trying to remove the `day` property from an existing relationship `like` of type `LIKED`, given a property existence constraint `:LIKED(day)`.

.Query
[source,cypher]
----
MATCH (user:User)-[like:LIKED]->(book:Book) REMOVE like.day
----


In this case the property is not removed.

.Error message
[source]
----
Relationship(0) with type `LIKED` must have the property `day`
----



[discrete]
[[administration-constraints-failure-to-create-a-relationship-property-existence-constraint-due-to-existing-relationship]]
== Failure to create a relationship property existence constraint due to existing relationship ==
Create a constraint on the property `day` on relationships with the `LIKED` type when there already exists a relationship without a property named `day`.

.Query
[source,cypher]
----
CREATE CONSTRAINT ON ()-[like:LIKED]-() ASSERT like.day IS NOT NULL
----


In this case the constraint can't be created because it is violated by existing data. We may choose to remove the offending relationships and then re-apply the constraint.

.Error message
[source]
----
Unable to create Constraint( type='RELATIONSHIP PROPERTY EXISTENCE',
schema=-[:LIKED {day}]- ):
Relationship(0) with type `LIKED` must have the property `day`
----




[role=enterprise-edition]
[[administration-constraints-node-key]]
== Node key constraints

[discrete]
[[administration-constraints-create-a-node-key-constraint]]
== Create a node key constraint ==
When creating a node key constraint, a name can be provided. The constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique and all properties in the set are present.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_name ON (n:Person) ASSERT (n.firstname, n.surname) IS NODE KEY
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_name ON (n:Person) ASSERT (n.firstname, n.surname) IS NODE KEY
----


[discrete]
[[administration-constraints-create-a-node-key-constraint-only-if-it-does-not-already-exist]]
== Create a node key constraint only if it does not already exist ==
If it is unknown if a constraint exists or not but we want to make sure it does, we add the `IF NOT EXISTS`. The node key constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique and all properties in the set are present.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS ON (n:Person) ASSERT (n.firstname,
  n.surname) IS NODE KEY
----


Note no constraint will be created if any other constraint with that name or another node key constraint on the same schema already exists. Assuming a node key constraint on `(:Person {firstname, surname})` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_name IF NOT EXISTS ON (n:Person) ASSERT (n.firstname, n.surname) IS NODE KEY
----


[discrete]
[[administration-constraints-create-a-node-key-constraint-with-specified-index-provider]]
== Create a node key constraint with specified index provider ==
To create a node key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.
Valid values for the index provider is `native-btree-1.0` and `lucene+native-3.0`, default if nothing is specified is `native-btree-1.0`.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_with_provider ON (n:Label) ASSERT (n.prop1) IS NODE KEY OPTIONS
  {indexProvider: 'native-btree-1.0'}
----


Can be combined with specifying index configuration.

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_with_provider ON (n:Label) ASSERT (n.prop1) IS NODE KEY OPTIONS {indexProvider: 'native-btree-1.0'}
----


[discrete]
[[administration-constraints-create-a-node-key-constraint-with-specified-index-configuration]]
== Create a node key constraint with specified index configuration ==
To create a node key constraint with a specific index configuration for the backing index, the `OPTIONS` clause is used.
Valid configuration settings are `spatial.cartesian.min`, `spatial.cartesian.max`, `spatial.cartesian-3d.min`, `spatial.cartesian-3d.max`,
`spatial.wgs-84.min`, `spatial.wgs-84.max`, `spatial.wgs-84-3d.min`, and `spatial.wgs-84-3d.max`.
Non-specified settings get their respective default values.

.Query
[source,cypher]
----
CREATE CONSTRAINT constraint_with_config ON (n:Label) ASSERT (n.prop2) IS NODE KEY
OPTIONS {indexConfig: {`spatial.cartesian.min`: [-100.0, -100.0], `spatial.cartesian.max`: [100.0,
  100.0]}}
----


Can be combined with specifying index provider.

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----


.Try this query live
[console]
----
none

CREATE CONSTRAINT constraint_with_config ON (n:Label) ASSERT (n.prop2) IS NODE KEY
OPTIONS {indexConfig: {`spatial.cartesian.min`: [-100.0, -100.0], `spatial.cartesian.max`: [100.0, 100.0]}}
----


[discrete]
[[administration-constraints-create-a-node-that-complies-with-node-key-constraints]]
== Create a node that complies with node key constraints ==
Create a `Person` node with both a `firstname` and `surname` property.

.Query
[source,cypher]
----
CREATE (p:Person {firstname: 'John', surname: 'Wood', age: 55})
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 3
Labels added: 1
----



[discrete]
[[administration-constraints-create-a-node-that-violates-a-node-key-constraint]]
== Create a node that violates a node key constraint ==
Trying to create a `Person` node without a `surname` property, given a node key constraint on `:Person(firstname, surname)`, will fail.

.Query
[source,cypher]
----
CREATE (p:Person {firstname: 'Jane', age: 34})
----


In this case the node isn't created in the graph.

.Error message
[source]
----
Node(0) with label `Person` must have the properties (firstname, surname)
----



[discrete]
[[administration-constraints-removing-a-node-key-constrained-property]]
== Removing a `NODE KEY`-constrained property ==
Trying to remove the `surname` property from an existing node `Person`, given a `NODE KEY` constraint on `:Person(firstname, surname)`.

.Query
[source,cypher]
----
MATCH (p:Person {firstname: 'John', surname: 'Wood'}) REMOVE p.surname
----


In this case the property is not removed.

.Error message
[source]
----
Node(0) with label `Person` must have the properties (firstname, surname)
----



[discrete]
[[administration-constraints-failure-to-create-a-node-key-constraint-due-to-existing-node]]
== Failure to create a node key constraint due to existing node ==
Trying to create a node key constraint on the property `surname` on nodes with the `Person` label will fail when  a node without a `surname` already exists in the database.

.Query
[source,cypher]
----
CREATE CONSTRAINT ON (n:Person) ASSERT (n.firstname, n.surname) IS NODE KEY
----


In this case the node key constraint can't be created because it is violated by existing data. We may choose to remove the offending nodes and then re-apply the constraint.

.Error message
[source]
----
Unable to create Constraint( name='constraint_c57fc9b0', type='NODE KEY',
schema=(:Person {firstname, surname}) ):
Failed during property existence validation: Unable to create constraint
org.neo4j.internal.schema.constraints.ConstraintDescriptorImplementation@12000642:
Node(0) does not satisfy Constraint( type='NODE PROPERTY EXISTENCE',
schema=(:Person {firstname, surname}) ).
----




[[administration-constraints-drop-constraint]]
== Drop a constraint by name

[discrete]
[[administration-constraints-drop-a-constraint]]
== Drop a constraint ==
A constraint can be dropped using the name with the `DROP CONSTRAINT constraint_name` command.
It is the same command for unique property, property existence and node key constraints.
The name of the constraint can be found using the xref:constraints/syntax.adoc#administration-constraints-syntax-list[`SHOW CONSTRAINTS` command], given in the output column `name`.

.Query
[source,cypher]
----
DROP CONSTRAINT constraint_name
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Named constraints removed: 1
----



[discrete]
[[administration-constraints-drop-a-non-existing-constraint]]
== Drop a non-existing constraint ==
If it is uncertain if any constraint with a given name exists and you want to drop it if it does but not get an error should it not, use `IF EXISTS`. It is the same command for unique property, property existence and node key constraints.

.Query
[source,cypher]
----
DROP CONSTRAINT missing_constraint_name IF EXISTS
----


.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----




[[administration-constraints-list-constraint]]
== Listing constraints

[discrete]
[[administration-constraints-listing-all-constraints]]
== Listing all constraints ==

To list all constraints with the default output columns, the `SHOW CONSTRAINTS` command can be used.
If all columns are required, use `SHOW CONSTRAINTS YIELD *`.

.Query
[source,cypher]
----
SHOW CONSTRAINTS
----


One of the output columns from `SHOW CONSTRAINTS` is the name of the constraint.
This can be used to drop the constraint with the xref:constraints/syntax.adoc#administration-constraints-syntax-drop[`DROP CONSTRAINT` command].

.Result
[queryresult]
----
+----------------------------------------------------------------------------------------------------+
| id | name                  | type         | entityType | labelsOrTypes | properties | ownedIndexId |
+----------------------------------------------------------------------------------------------------+
| 4  | "constraint_ca412c3d" | "UNIQUENESS" | "NODE"     | ["Book"]      | ["isbn"]   | 3            |
+----------------------------------------------------------------------------------------------------+
1 row
----



[discrete]
[[administration-constraints-listing-constraints-with-filtering]]
== Listing constraints with filtering ==

One way of filtering the output from `SHOW CONSTRAINTS` by constraint type is the use of type keywords,
listed in xref:constraints/syntax.adoc#administration-constraints-syntax-list[Syntax for listing constraints].
For example, to show only unique node property constraints, use `SHOW UNIQUE CONSTRAINTS`.
Another more flexible way of filtering the output is to use the `WHERE` clause.
An example is to only show constraints on relationships.

.Query
[source,cypher]
----
SHOW EXISTENCE CONSTRAINTS WHERE entityType = 'RELATIONSHIP'
----


This will only return the default output columns.
To get all columns, use `SHOW INDEXES YIELD * WHERE ...`.

.Result
[queryresult]
----
+-----------------------------------------------------------------------------------------------------------------------------+
| id | name                  | type                              | entityType     | labelsOrTypes | properties | ownedIndexId |
+-----------------------------------------------------------------------------------------------------------------------------+
| 7  | "constraint_f076a74d" | "RELATIONSHIP_PROPERTY_EXISTENCE" | "RELATIONSHIP" | ["KNOWS"]     | ["since"]  | <null>       |
+-----------------------------------------------------------------------------------------------------------------------------+
1 row
----




[role=deprecated]
[[administration-constraints-deprecated-syntax]]
== Deprecated syntax

[discrete]
[[administration-constraints-drop-a-unique-constraint]]
== Drop a unique constraint ==
By using `DROP CONSTRAINT`, you remove a constraint from the database.

.Query
[source,cypher]
----
DROP CONSTRAINT ON (book:Book) ASSERT book.isbn IS UNIQUE
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints removed: 1
----



[discrete]
[[administration-constraints-drop-a-node-property-existence-constraint]]
== Drop a node property existence constraint ==
By using `DROP CONSTRAINT`, you remove a constraint from the database.

.Query
[source,cypher]
----
DROP CONSTRAINT ON (book:Book) ASSERT exists(book.isbn)
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints removed: 1
----



[discrete]
[[administration-constraints-drop-a-relationship-property-existence-constraint]]
== Drop a relationship property existence constraint ==
To remove a constraint from the database, use `DROP CONSTRAINT`.

.Query
[source,cypher]
----
DROP CONSTRAINT ON ()-[like:LIKED]-() ASSERT exists(like.day)
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints removed: 1
----



[discrete]
[[administration-constraints-drop-a-node-key-constraint]]
== Drop a node key constraint ==
Use `DROP CONSTRAINT` to remove a node key constraint from the database.

.Query
[source,cypher]
----
DROP CONSTRAINT ON (n:Person) ASSERT (n.firstname, n.surname) IS NODE KEY
----


.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints removed: 1
----


