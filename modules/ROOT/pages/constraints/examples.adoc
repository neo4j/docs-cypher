:description: Examples of how to manage constraints used for ensuring data integrity.

[[constraints-examples]]
= Examples

[abstract]
--
Examples of how to manage constraints used for ensuring data integrity.
--


[[constraints-examples-node-uniqueness]]
== Node property uniqueness constraints

A node property uniqueness constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique when existing.

* xref::constraints/examples.adoc#constraints-create-a-node-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-uniqueness-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-a-node-uniqueness-constraint-with-index-provider[]
* xref::constraints/examples.adoc#constraints-create-an-already-existing-node-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-uniqueness-constraint-on-same-schema-as-existing-index[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-complies-with-a-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-violates-a-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-uniqueness-constraint-due-to-conflicting-nodes[]


[discrete]
[[constraints-create-a-node-uniqueness-constraint]]
=== Create a node property uniqueness constraint

When creating a property uniqueness constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in Neo4j version 6.0.
====

======


[discrete]
[[constraints-create-a-node-uniqueness-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another node property uniqueness constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

Assuming no constraint with the given name or other node property uniqueness constraint on the same schema exists:

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in Neo4j version 6.0.
====

======


[discrete]
[[constraints-create-a-node-uniqueness-constraint-with-index-provider]]
=== Specifying an index provider when creating a constraint

To create a property uniqueness constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]

// Only one valid value exists for the index provider in Neo4j 5.0


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_options
FOR (n:Label) REQUIRE (n.prop1, n.prop2) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0',
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in Neo4j version 6.0.
====

======

There is no valid index configuration values for the constraint-backing range indexes.


[discrete]
[[constraints-create-an-already-existing-node-uniqueness-constraint]]
=== Creating an already existing constraint will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `title` on nodes with the `Book` label, when that constraint already exists.

////
Set-up to get expected behavior:
CREATE CONSTRAINT preExistingUnique FOR (book:Book) REQUIRE book.title IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.title IS UNIQUE
----

In this case the constraint can not be created because it already exists.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='UNIQUENESS', schema=(:Book {title}), ownedIndex=3 )
----

[NOTE]
====
The constraint type will be updated to say `NODE_UNIQUENESS` in Neo4j version 6.0.
====

======


[discrete]
[[constraints-create-a-node-uniqueness-constraint-on-same-schema-as-existing-index]]
=== Creating a constraint on the same schema as an existing index will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `wordCount` on nodes with the `Book` label, when an index already exists on that label and property combination.

////
Set-up to get expected behavior:
CREATE INDEX FOR (book:Book) ON (book.wordCount)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.wordCount IS UNIQUE
----

In this case the constraint can not be created because there already exists an index covering that schema.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index (:Book {wordCount}).
A constraint cannot be created until the index has been dropped.
----

======


[discrete]
[[constraints-create-a-node-that-complies-with-a-uniqueness-constraint]]
=== Creating a node that complies with an existing constraint


.+CREATE NODE+
======

Create a `Book` node with an `isbn` that is not already in the database.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1
----

======


[discrete]
[[constraints-create-a-node-that-violates-a-uniqueness-constraint]]
=== Creating a node that violates an existing constraint will fail


.+CREATE NODE+
======

Create a `Book` node with an `isbn` that is already used in the database.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) already exists with label `Book` and property `isbn` = '1449356265'
----

======


[discrete]
[[constraints-fail-to-create-a-uniqueness-constraint-due-to-conflicting-nodes]]
=== Creating a constraint when there exist conflicting nodes will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `isbn` on nodes with the `Book` label when there are two nodes with the same `isbn`.

////
Set-up to get expected behavior:
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

In this case the constraint can not be created because it is violated by existing data.
Either use xref::indexes-for-search-performance.adoc[] instead, or remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( name='constraint_62365a16', type='UNIQUENESS', schema=(:Book {isbn}) ):
Both Node(0) and Node(1) have the label `Book` and property `isbn` = '1449356265'
----

[NOTE]
====
The constraint type will be updated to say `NODE_UNIQUENESS` in Neo4j version 6.0.
====

======


[[constraints-examples-relationship-uniqueness]]
== Relationship property uniqueness constraints

A relationship property uniqueness constraint ensures that all relationships with a particular relationship type have a set of defined properties whose combined value is unique when existing.

* xref::constraints/examples.adoc#constraints-create-a-relationship-uniqueness-constraints[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-uniqueness-constraints-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-uniqueness-constraints-with-index-provider[]
* xref::constraints/examples.adoc#constraints-create-an-already-existing-relationship-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-uniqueness-constraint-on-same-schema-as-existing-index[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-complies-with-a-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-violates-a-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-uniqueness-constraint-due-to-conflicting-relationships[]


[discrete]
[[constraints-create-a-relationship-uniqueness-constraints]]
=== Create a relationship property uniqueness constraint

When creating a property uniqueness constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======


[discrete]
[[constraints-create-a-relationship-uniqueness-constraints-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another relationship property uniqueness constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

Assuming no constraint with the given name or other relationship property uniqueness constraint on the same schema exists:

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======


[discrete]
[[constraints-create-a-relationship-uniqueness-constraints-with-index-provider]]
=== Specifying an index provider when creating a constraint

To create a property uniqueness constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]

// Only one valid value exists for the index provider in Neo4j 5.0


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_options
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE (friend.nickname, friend.since) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0',
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======

There are no valid index configuration values for the constraint-backing range indexes.


[discrete]
[[constraints-create-an-already-existing-relationship-uniqueness-constraint]]
=== Creating an already existing constraint will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type, when that constraint already exists.

////
Set-up to get expected behavior:
CREATE CONSTRAINT preExistingUnique FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case, the constraint cannot be created because it already exists.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='RELATIONSHIP_UNIQUENESS', schema=()-[:FRIENDS_WITH {nickname}]-(), ownedIndex=3 )
----

======


[discrete]
[[constraints-create-a-relationship-uniqueness-constraint-on-same-schema-as-existing-index]]
=== Creating a constraint on the same schema as an existing index will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type, when an index already exists on that relationship type and property combination.

////
Set-up to get expected behavior:
CREATE INDEX FOR ()-[friend:FRIENDS_WITH]-() ON (friend.nickname)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case, the constraint cannot be created because there already exists an index covering that schema.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index ()-[:FRIENDS_WITH {nickname}]-().
A constraint cannot be created until the index has been dropped.
----

======


[discrete]
[[constraints-create-a-relationship-that-complies-with-a-uniqueness-constraint]]
=== Creating a relationship that complies with an existing constraint


.+CREATE RELATIONSHIP+
======

Create a `FRIENDS_WITH` relationship with an `nickname` that is not already in the database.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE (:Person {name: 'Josefin'})-[:FRIENDS_WITH {nickname: 'Mimi'}]->(:Person {name: 'Emilia'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 2
Relationships created: 1
Properties set: 3
Labels added: 2
----

======


[discrete]
[[constraints-create-a-relationship-that-violates-a-uniqueness-constraint]]
=== Creating a relationship that violates an existing constraint will fail


.+CREATE RELATIONSHIP+
======

Create a `FRIENDS_WITH` relationship with an `nickname` that is already used in the database.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
CREATE (:Person {name: 'Emma'}), (:Person {name: 'Josefin'})-[:FRIENDS_WITH {nickname: 'Mimi'}]->(:Person {name: 'Emilia'})
////

.Query
[source, cypher, indent=0]
----
MATCH (emma:Person {name: 'Emma'}), (emilia:Person {name: 'Emilia'})
CREATE (emma)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia)
----

In this case, the relationship is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) already exists with type `FRIENDS_WITH` and property `nickname` = 'Mimi'
----

======


[discrete]
[[constraints-fail-to-create-a-uniqueness-constraint-due-to-conflicting-relationships]]
=== Creating a constraint when there exist conflicting relationships will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type when there are two relationships with the same `nickname`.

////
Set-up to get expected behavior:
CREATE (emma:Person {name: 'Emma'}), (josefin:Person {name: 'Josefin'}), (emilia:Person {name: 'Emilia'})
CREATE (josefin)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia), (emma)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT friends FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case, the constraint cannot be created because it is violated by existing data.
Either use xref::indexes-for-search-performance.adoc[] instead, or remove the offending relationships and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( name='friends', type='RELATIONSHIP_UNIQUENESS', schema=()-[:FRIENDS_WITH {nickname}]-() ):
Both Relationship(0) and Relationship(1) have the type `FRIENDS_WITH` and property `nickname` = 'Mimi'
----

======


[role=enterprise-edition]
[[constraints-examples-node-property-existence]]
== Node property existence constraints

A node property existence constraint ensures that all nodes with a certain label have a certain property.

* xref::constraints/examples.adoc#constraints-create-a-node-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-property-existence-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-an-already-existing-node-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-complies-with-a-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-violates-a-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-removing-an-existence-constrained-node-property[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-property-existence-constraint-due-to-existing-node[]


[discrete]
[[constraints-create-a-node-property-existence-constraint]]
=== Create a node property existence constraint

When creating a node property existence constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints added: 1
----

[NOTE]
====
The statistics for property existence constraints will be split between nodes and relationships in Neo4j version 6.0.
For the node property existence constraints, they will say `Node property existence constraints`.
====

======


[discrete]
[[constraints-create-a-node-property-existence-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another node property existence constraint on the same schema already existed.


.+CREATE CONSTRAINT+
======

////
Set-up to get expected behavior:
CREATE CONSTRAINT constraint_name FOR (book:Book) REQUIRE book.isbn IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

Assuming a constraint with the name `constraint_name` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[constraints-create-an-already-existing-node-property-existence-constraint]]
=== Creating an already existing constraint will fail


.+CREATE CONSTRAINT+
======

Create a node property existence constraint on the property `title` on nodes with the `Book` label, when that constraint already exists.

////
Set-up to get expected behavior:
CREATE CONSTRAINT preExistingNodePropExist FOR (book:Book) REQUIRE book.title IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT booksShouldHaveTitles
FOR (book:Book) REQUIRE book.title IS NOT NULL
----

In this case the constraint can not be created because it already exists.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=3, name='preExistingNodePropExist', type='NODE PROPERTY EXISTENCE', schema=(:Book {title}) )
----

======


[discrete]
[[constraints-create-a-node-that-complies-with-a-property-existence-constraint]]
=== Creating a node that complies with an existing constraint


.+CREATE NODE+
======

Create a `Book` node with an `isbn` property.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1
----

======


[discrete]
[[constraints-create-a-node-that-violates-a-property-existence-constraint]]
=== Creating a node that violates an existing constraint will fail


.+CREATE NODE+
======

Trying to create a `Book` node without an `isbn` property, given a property existence constraint on `:Book(isbn)`.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {title: 'Graph Databases'})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Book` must have the property `isbn`
----

======


[discrete]
[[constraints-removing-an-existence-constrained-node-property]]
=== Removing an existence constrained node property will fail


.+REMOVE PROPERTY+
======

Trying to remove the `isbn` property from an existing node `book`, given a property existence constraint on `:Book(isbn)`.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
MATCH (book:Book {title: 'Graph Databases'})
REMOVE book.isbn
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Book` must have the property `isbn`
----

======


[discrete]
[[constraints-fail-to-create-a-property-existence-constraint-due-to-existing-node]]
=== Creating a constraint when there exist conflicting nodes will fail


.+CREATE CONSTRAINT+
======

Create a constraint on the property `isbn` on nodes with the `Book` label when there already exists  a node without an `isbn`.

////
Set-up to get expected behavior:
CREATE (book:Book {title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

In this case the constraint can't be created because it is violated by existing data.
Remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='NODE PROPERTY EXISTENCE', schema=(:Book {isbn}) ):
Node(0) with label `Book` must have the property `isbn`
----

======


[role=enterprise-edition]
[[constraints-examples-relationship-property-existence]]
== Relationship property existence constraints

A relationship property existence constraint ensures that all relationships with a certain type have a certain property.

* xref::constraints/examples.adoc#constraints-create-a-relationship-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-property-existence-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-an-already-existing-relationship-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-complies-with-a-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-violates-a-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-removing-an-existence-constrained-relationship-property[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-property-existence-constraint-due-to-existing-relationship[]


[discrete]
[[constraints-create-a-relationship-property-existence-constraint]]
=== Create a relationship property existence constraint

When creating a relationship property existence constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints added: 1
----

[NOTE]
====
The statistics for property existence constraints will be split between nodes and relationships in Neo4j version 6.0.
For the relationship property existence constraints, they will say `Relationship property existence constraints`.
====

======


[discrete]
[[constraints-create-a-relationship-property-existence-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another relationship property existence constraint on the same schema already existed.


.+CREATE CONSTRAINT+
======

////
Set-up to get expected behavior:
CREATE CONSTRAINT constraint_name FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
IF NOT EXISTS FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

Assuming a constraint with the name `constraint_name` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[constraints-create-an-already-existing-relationship-property-existence-constraint]]
=== Creating an already existing constraint will fail


.+CREATE CONSTRAINT+
======

Create a named relationship property existence constraint on the property `week` on relationships with the `LIKED` type, when a constraint with the given name already exists.

////
Set-up to get expected behavior:
CREATE CONSTRAINT relPropExist FOR ()-[like:LIKED]-() REQUIRE like.since IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT relPropExist
FOR ()-[like:LIKED]-() REQUIRE like.week IS NOT NULL
----

In this case the constraint can not be created because there already exists a constraint with the given name.

.Error message
[source, "error message", role="noheader"]
----
There already exists a constraint called 'relPropExist'.
----

======


[discrete]
[[constraints-create-a-relationship-that-complies-with-a-property-existence-constraint]]
=== Creating a relationship that complies with an existing constraint


.+CREATE RELATIONSHIP+
======

Create a `LIKED` relationship with a `day` property.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (user:User)-[like:LIKED {day: 'yesterday'}]->(book:Book)
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 2
Relationships created: 1
Properties set: 1
Labels added: 2
----

======


[discrete]
[[constraints-create-a-relationship-that-violates-a-property-existence-constraint]]
=== Creating a relationship that violates an existing constraint will fail


.+CREATE RELATIONSHIP+
======

Trying to create a `LIKED` relationship without a `day` property, given a property existence constraint `:LIKED(day)`.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (user:User)-[like:LIKED]->(book:Book)
----

In this case the relationship is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `LIKED` must have the property `day`
----

======


[discrete]
[[constraints-removing-an-existence-constrained-relationship-property]]
=== Removing an existence constrained relationship property will fail


.+REMOVE PROPERTY+
======

Trying to remove the `day` property from an existing relationship `like` of type `LIKED`, given a property existence constraint `:LIKED(day)`.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
CREATE (user:User)-[like:LIKED {day: 'yesterday'}]->(book:Book)
////

.Query
[source, cypher, indent=0]
----
MATCH (user:User)-[like:LIKED]->(book:Book) REMOVE like.day
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `LIKED` must have the property `day`
----

======


[discrete]
[[constraints-fail-to-create-a-property-existence-constraint-due-to-existing-relationship]]
=== Creating a constraint when there exist conflicting relationships will fail


.+CREATE CONSTRAINT+
======

Create a constraint on the property `day` on relationships with the `LIKED` type when there already exists a relationship without a property named `day`.

////
Set-up to get expected behavior:
CREATE (user:User)-[like:LIKED]->(book:Book)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

In this case the constraint can not be created because it is violated by existing data.
Remove the offending relationships and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='RELATIONSHIP PROPERTY EXISTENCE', schema=-[:LIKED {day}]- ):
Relationship(0) with type `LIKED` must have the property `day`
----

======


[role=enterprise-edition]
[[constraints-examples-node-key]]
== Node key constraints

A node key constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique and all properties in the set are present.

* xref::constraints/examples.adoc#constraints-create-a-node-key-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-key-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-a-node-key-constraint-with-index-provider[]
* xref::constraints/examples.adoc#constraints-node-key-and-uniqueness-constraint-on-the-same-schema[]
* xref::constraints/examples.adoc#constraints-create-a-node-key-constraint-with-the-same-name-as-existing-index[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-complies-with-a-node-key-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-violates-a-node-key-constraint[]
* xref::constraints/examples.adoc#constraints-removing-a-node-key-constrained-property[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-node-key-constraint-due-to-existing-node[]


[discrete]
[[constraints-create-a-node-key-constraint]]
=== Create a node key constraint

When creating a node key constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----

======


[discrete]
[[constraints-create-a-node-key-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another node key constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

Assuming a node key constraint on `(:Person {firstname, surname})` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[constraints-create-a-node-key-constraint-with-index-provider]]
=== Specifying an index provider when creating a constraint

To create a node key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_provider
FOR (n:Label) REQUIRE (n.prop1) IS NODE KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----

======

There is no valid index configuration values for the constraint-backing range indexes.


[discrete]
[[constraints-node-key-and-uniqueness-constraint-on-the-same-schema]]
=== Node key and property uniqueness constraints are not allowed on the same schema


.+CREATE CONSTRAINT+
======

Create a node key constraint on the properties `firstname` and `age` on nodes with the `Person` label, when a property uniqueness constraint already exists on the same label and property combination.

////
Set-up to get expected behavior:
CREATE CONSTRAINT preExistingUnique FOR (p:Person) REQUIRE (p.firstname, p.age) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (p:Person) REQUIRE (p.firstname, p.age) IS NODE KEY
----

In this case the constraint can not be created because there already exist a conflicting constraint on that label and property combination.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='UNIQUENESS', schema=(:Person {firstname, age}), ownedIndex=3 )
----

======


[discrete]
[[constraints-create-a-node-key-constraint-with-the-same-name-as-existing-index]]
=== Creating a constraint on same name as an existing index will fail


.+CREATE CONSTRAINT+
======

Create a named node key constraint on the property `title` on nodes with the `Book` label, when an index already exists with the given name.

////
Set-up to get expected behavior:
CREATE INDEX bookTitle FOR (book:ComicBook) ON (book.title)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT bookTitle
FOR (book:Book) REQUIRE book.title IS NODE KEY
----

In this case the constraint can't be created because there already exists an index with the given name.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index called 'bookTitle'.
----

======


[discrete]
[[constraints-create-a-node-that-complies-with-a-node-key-constraint]]
=== Creating a node that complies with an existing constraint


.+CREATE NODE+
======

Create a `Person` node with both a `firstname` and `surname` property.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE (p:Person {firstname: 'John', surname: 'Wood', age: 55})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 3
Labels added: 1
----

======


[discrete]
[[constraints-create-a-node-that-violates-a-node-key-constraint]]
=== Creating a node that violates an existing constraint will fail


.+CREATE NODE+
======

Trying to create a `Person` node without a `surname` property, given a node key constraint on `:Person(firstname, surname)`, will fail.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE (p:Person {firstname: 'Jane', age: 34})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Person` must have the properties (`firstname`, `surname`)
----

======


[discrete]
[[constraints-removing-a-node-key-constrained-property]]
=== Removing a +NODE KEY+-constrained property will fail


.+REMOVE PROPERTY+
======

Trying to remove the `surname` property from an existing node `Person`, given a `NODE KEY` constraint on `:Person(firstname, surname)`.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
CREATE (p:Person {firstname: 'John', surname: 'Wood', age: 55})
////

.Query
[source, cypher, indent=0]
----
MATCH (p:Person {firstname: 'John', surname: 'Wood'}) REMOVE p.surname
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Person` must have the properties (`firstname`, `surname`)
----

======


[discrete]
[[constraints-fail-to-create-a-node-key-constraint-due-to-existing-node]]
=== Creating a constraint when there exist conflicting node will fail


.+CREATE CONSTRAINT+
======

Trying to create a node key constraint on the property `surname` on nodes with the `Person` label will fail when a node without a `surname` already exists in the database.

////
Set-up to get expected behavior:
CREATE (p:Person {firstname: 'John', age: 55})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

In this case the node key constraint can not be created because it is violated by existing data.
Either use xref::indexes-for-search-performance.adoc[] instead, or remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='NODE KEY', schema=(:Person {firstname, surname}) ):
Node(0) with label `Person` must have the properties (`firstname`, `surname`)
----

======


[role=enterprise-edition]
[[constraints-examples-relationship-key]]
== Relationship key constraints

A relationship key constraint ensures that all relationships with a particular relationship type have a set of defined properties whose combined value is unique. 
It also ensures that all properties in the set are present.

* xref::constraints/examples.adoc#constraints-create-a-relationship-key-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-key-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-key-constraint-with-index-provider[]
* xref::constraints/examples.adoc#constraints-relationship-key-and-uniqueness-constraint-on-the-same-schema[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-key-constraint-with-the-same-name-as-existing-index[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-complies-with-a-relationship-key-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-violates-a-relationship-key-constraint[]
* xref::constraints/examples.adoc#constraints-removing-a-relationship-key-constrained-property[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-relationship-key-constraint-due-to-existing-relationship[]


[discrete]
[[constraints-create-a-relationship-key-constraint]]
=== Create a relationship key constraint

When creating a relationship key constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship key constraints added: 1
----

======


[discrete]
[[constraints-create-a-relationship-key-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another relationship key constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY
----

Assuming a relationship key constraint on `()-[:ROAD {startPoint, endPoint}]-()` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[constraints-create-a-relationship-key-constraint-with-index-provider]]
=== Specifying an index provider when creating a constraint

To create a relationship key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_provider
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship key constraints added: 1
----

======

There is no valid index configuration values for the constraint-backing range indexes.


[discrete]
[[constraints-relationship-key-and-uniqueness-constraint-on-the-same-schema]]
=== Relationship key and property uniqueness constraints are not allowed on the same schema


.+CREATE CONSTRAINT+
======

Create a relationship key constraint on the properties `startPoint` and `endPoint` on relationships with the `ROAD` relationship type, when a property uniqueness constraint already exists on the same relationship type and property combination.

////
Set-up to get expected behavior:
CREATE CONSTRAINT preExistingUnique FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
----

In this case, the constraint cannot be created because there already exists a conflicting constraint on that relationship type and property combination.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='RELATIONSHIP_UNIQUENESS', schema=()-[:ROAD {startPoint, endPoint}]-(), ownedIndex=3 )
----

======


[discrete]
[[constraints-create-a-relationship-key-constraint-with-the-same-name-as-existing-index]]
=== Creating a constraint on same name as an existing index will fail


.+CREATE CONSTRAINT+
======

Create a named relationship key constraint on the property `coordinates` on relationships with the `INTERSECTION` relationship type, when an index already exists with the given name.

////
Set-up to get expected behavior:
CREATE INDEX intersections FOR ()-[intersect:Roundabout]-() ON (intersect.coordinates)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT intersections
FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
----

In this case, the constraint cannot be created because there already exists an index with the given name.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index called 'intersections'.
----

======


[discrete]
[[constraints-create-a-relationship-that-complies-with-a-relationship-key-constraint]]
=== Creating a relationship that complies with an existing constraint


.+CREATE RELATIONSHIP+
======

Create a `ROAD` relationship with both a `startPoint` and `endPoint` property.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
CREATE (:Intersection {name: 'a', coordinates: point({x: 1, y:2})}), (:Intersection {name: 'b', coordinates: point({x: 2, y:5})})
////

.Query
[source, cypher, indent=0]
----
MATCH (a:Intersection {name: 'a'}), (b:Intersection {name: 'b'})
CREATE (a)-[:ROAD {startPoint: a.coordinates, endPoint: b.coordinates}]->(b)
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationships created: 1
Properties set: 2
----

======


[discrete]
[[constraints-create-a-relationship-that-violates-a-relationship-key-constraint]]
=== Creating a relationship that violates an existing constraint will fail


.+CREATE RELATIONSHIP+
======

Trying to create a `INTERSECTION` relationship without a `coordinates` property, given a relationship key constraint on `:INTERSECTION(coordinates)`, will fail.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
CREATE (:Road {name: 'a'}), (:Road {name: 'b'})
////

.Query
[source, cypher, indent=0]
----
MATCH (a:Road {name: 'a'}), (b:Road {name: 'b'})
CREATE (a)-[:INTERSECTION]->(b)
----

In this case, the relationship is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `INTERSECTION` must have the property `coordinates`
----

======


[discrete]
[[constraints-removing-a-relationship-key-constrained-property]]
=== Removing a +RELATIONSHIP KEY+-constrained property will fail


.+REMOVE PROPERTY+
======

Trying to remove the `endPoint` property from an existing relationship `ROAD`, given a `RELATIONSHIP KEY` constraint on `:ROAD(startPoint, endPoint)`.

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
CREATE (a:Intersection {name: 'a', coordinates: point({x: 1, y:2})}), (b:Intersection {name: 'b', coordinates: point({x: 2, y:5})})
CREATE (a)-[:ROAD {startPoint: a.coordinates, endPoint: b.coordinates}]->(b)
////

.Query
[source, cypher, indent=0]
----
MATCH ()-[r:ROAD {startPoint: point({x: 1, y:2}), endPoint: point({x: 2, y:5})}]->() REMOVE r.endPoint
----

In this case, the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `ROAD` must have the properties (`startPoint`, `endPoint`)
----

======


[discrete]
[[constraints-fail-to-create-a-relationship-key-constraint-due-to-existing-relationship]]
=== Creating a constraint when there exist conflicting relationships will fail


.+CREATE CONSTRAINT+
======

Trying to create a relationship key constraint on the property `coordinates` on relationships with the `INTERSECTION` relationship type will fail when two relationships with identical `coordinates` already exists in the database.

////
Set-up to get expected behavior:
CREATE (a:Road {name: 'a'}), (b:Road {name: 'b'})
CREATE (a)-[:INTERSECTION {coordinates: point({x:1, y:2})}]->(b)
CREATE (a)<-[:INTERSECTION {coordinates: point({x:1, y:2})}]-(b)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT intersectionConstraint FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
----

In this case, the relationship key constraint cannot be created because it is violated by existing data.
Either use xref::indexes-for-search-performance.adoc[] instead, or remove the offending relationships and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( name='intersectionConstraint', type='RELATIONSHIP KEY', schema=()-[:INTERSECTION {coordinates}]-() ):
Both Relationship(0) and Relationship(1) have the type `INTERSECTION` and property `coordinates` = {geometry: {type: "Point", coordinates: [1.0, 2.0], crs: {type: link, properties: {href: "http://spatialreference.org/ref/sr-org/7203/", code: 7203}}}}
----

======


[[constraints-examples-drop-constraint]]
== Drop a constraint by name

* xref::constraints/examples.adoc#constraints-drop-a-constraint[]
* xref::constraints/examples.adoc#constraints-drop-a-non-existing-constraint[]


[discrete]
[[constraints-drop-a-constraint]]
=== Drop a constraint

A constraint can be dropped using the name with the `DROP CONSTRAINT constraint_name` command.
It is the same command for uniqueness, property existence, and node/relationship key constraints.
The name of the constraint can be found using the xref::constraints/syntax.adoc#constraints-syntax-list[`SHOW CONSTRAINTS` command], given in the output column `name`.


.+DROP CONSTRAINT+
======

////
Set-up to get expected behavior:
CREATE CONSTRAINT constraint_name FOR (n:Person) REQUIRE (n.name) IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
DROP CONSTRAINT constraint_name
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Named constraints removed: 1
----

======


[discrete]
[[constraints-drop-a-non-existing-constraint]]
=== Drop a non-existing constraint

If it is uncertain if any constraint with a given name exists and you want to drop it if it does but not get an error should it not, use `IF EXISTS`.
It is the same command for uniqueness, property existence, and node/relationship key constraints.

.+DROP CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
DROP CONSTRAINT missing_constraint_name IF EXISTS
----

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[[constraints-examples-list-constraint]]
== Listing constraints

* xref::constraints/examples.adoc#constraints-listing-all-constraints[]
* xref::constraints/examples.adoc#constraints-listing-constraints-with-filtering[]


[discrete]
[[constraints-listing-all-constraints]]
=== Listing all constraints

To list all constraints with the default output columns, the `SHOW CONSTRAINTS` command can be used.
If all columns are required, use `SHOW CONSTRAINTS YIELD *`.

[NOTE]
====
One of the output columns from `SHOW CONSTRAINTS` is the name of the constraint.
This can be used to drop the constraint with the xref::constraints/syntax.adoc#constraints-syntax-drop[`DROP CONSTRAINT` command].
====


.+SHOW CONSTRAINTS+
======

////
Set-up to get expected behavior:
CREATE CONSTRAINT isbnConstraint FOR (n:Book) REQUIRE (n.isbn) IS UNIQUE
CREATE CONSTRAINT roadConstraint FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
SHOW CONSTRAINTS
----

[queryresult]
----
+------------------------------------------------------------------------------------------------------------------------------------+
| id | name             | type                      | entityType     | labelsOrTypes | properties                 | ownedIndex       |
+------------------------------------------------------------------------------------------------------------------------------------+
| 4  | "isbnConstraint" | "UNIQUENESS"              | "NODE"         | ["Book"]      | ["isbn"]                   | "isbnConstraint" |
| 6  | "roadConstraint" | "RELATIONSHIP_UNIQUENESS" | "RELATIONSHIP" | ["ROAD"]      | ["startPoint", "endPoint"] | "roadConstraint" |
+------------------------------------------------------------------------------------------------------------------------------------+
2 rows
----

[NOTE]
====
The `type` column returns `UNIQUENESS` for the node property uniqueness constraint and `RELATIONSHIP_UNIQUENESS` for the relationship property uniqueness constraint.
The `type` for node property uniqueness constraint will be updated to `NODE_UNIQUENESS` in Neo4j version 6.0.
====

======


[discrete]
[[constraints-listing-constraints-with-filtering]]
=== Listing constraints with filtering

One way of filtering the output from `SHOW CONSTRAINTS` by constraint type is the use of type keywords,
listed in the xref::constraints/syntax.adoc#constraints-syntax-list-type-filter[syntax for listing constraints type filter table].
For example, to show only property uniqueness constraints, use `SHOW UNIQUENESS CONSTRAINTS`.
Another more flexible way of filtering the output is to use the `WHERE` clause.
An example is to only show constraints on relationships.


.+SHOW CONSTRAINTS+
======

////
Set-up to get expected behavior:
CREATE CONSTRAINT FOR (n:Book) REQUIRE (n.isbn) IS UNIQUE
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.title IS NOT NULL
CREATE CONSTRAINT `constraint_f076a74d` FOR ()-[r:KNOWS]-() REQUIRE r.since IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
SHOW EXISTENCE CONSTRAINTS
WHERE entityType = 'RELATIONSHIP'
----

This will only return the default output columns.
To get all columns, use `+SHOW INDEXES YIELD * WHERE ...+`.

[queryresult]
----
+---------------------------------------------------------------------------------------------------------------------------+
| id | name                  | type                              | entityType     | labelsOrTypes | properties | ownedIndex |
+---------------------------------------------------------------------------------------------------------------------------+
| 7  | "constraint_f076a74d" | "RELATIONSHIP_PROPERTY_EXISTENCE" | "RELATIONSHIP" | ["KNOWS"]     | ["since"]  | <null>     |
+---------------------------------------------------------------------------------------------------------------------------+
1 row
----

======

