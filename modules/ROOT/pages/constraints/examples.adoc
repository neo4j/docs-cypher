:description: Examples of how to manage constraints used for ensuring data integrity.

[[constraints-examples]]
= Examples

[abstract]
--
Examples of how to manage constraints used for ensuring data integrity.
--


[[constraints-examples-node-uniqueness]]
== Node property uniqueness constraints

A node property uniqueness constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique when existing.

* xref::constraints/examples.adoc#constraints-create-a-node-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-uniqueness-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-a-node-uniqueness-constraint-with-index-provider[]
* xref::constraints/examples.adoc#constraints-create-an-already-existing-node-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-uniqueness-constraint-on-same-schema-as-existing-index[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-complies-with-a-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-violates-a-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-uniqueness-constraint-due-to-conflicting-nodes[]


[discrete]
[[constraints-create-a-node-uniqueness-constraint]]
=== Create a node property uniqueness constraint

When creating a property uniqueness constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT book_isbn
FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

.Result
[queryresult]
----
Added 1 constraint.
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in Neo4j version 6.0.
====
////

======


[discrete]
[[constraints-create-a-node-uniqueness-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another node property uniqueness constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT book_isbn2 IF NOT EXISTS
FOR (book:Book) REQUIRE book.isbn2 IS UNIQUE
----

Assuming no constraint with the given name or other node property uniqueness constraint on the same schema already exists, the query will return:

.Result
[queryresult]
----
Added 1 constraint.
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in Neo4j version 6.0.
====
////

======


[discrete]
[[constraints-create-a-node-uniqueness-constraint-with-index-provider]]
=== Specifying an index provider when creating a constraint

To create a property uniqueness constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]

// Only one valid value exists for the index provider in Neo4j 5.0


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT constraint_with_options
FOR (book:Book) REQUIRE (book.prop1, book.prop2) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
Added 1 constraint.
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in Neo4j version 6.0.
====
////

======

There is no valid index configuration values for the constraint-backing range indexes.


[discrete]
[[constraints-create-an-already-existing-node-uniqueness-constraint]]
=== Creating an already existing constraint will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `published` on nodes with the `Book` label, when that constraint already exists.

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT preExisting_book_published FOR (book:Book) REQUIRE book.published IS UNIQUE
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT book_published FOR (book:Book) REQUIRE book.published IS UNIQUE
----

In this case the constraint can not be created because it already exists.

.Error message
[source, error]
----
Constraint already exists:
Constraint( id=4, name='preExisting_book_published', type='UNIQUENESS', schema=(:Book {published}), ownedIndex=3 )
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[NOTE]
====
The constraint type will be updated to say `NODE_UNIQUENESS` in Neo4j version 6.0.
====
////

======


[discrete]
[[constraints-create-a-node-uniqueness-constraint-on-same-schema-as-existing-index]]
=== Creating a constraint on the same schema as an existing index will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `wordCount` on nodes with the `Book` label, when an index already exists on that label and property combination.

////
[source, cypher, role=test-setup]
----
CREATE INDEX preExisting_book_word_count FOR (book:Book) ON (book.wordCount)
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT book_word_count FOR (book:Book) REQUIRE book.wordCount IS UNIQUE
----

In this case the constraint can not be created because there already exists an index covering that schema.

.Error message
[source, error]
----
There already exists an index (:Book {wordCount}).
A constraint cannot be created until the index has been dropped.
----

======


[discrete]
[[constraints-create-a-node-that-complies-with-a-uniqueness-constraint]]
=== Creating a node that complies with an existing constraint


.+CREATE NODE+
======

Create a `Book` node with an `isbn` that is not already in the database.

.Query
[source, cypher]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

.Result
[queryresult]
----
Added 1 label, created 1 node, set 2 properties
----

======


[discrete]
[[constraints-create-a-node-that-violates-a-uniqueness-constraint]]
=== Creating a node that violates an existing constraint will fail


.+CREATE NODE+
======

Create a `Book` node with an `isbn` that is already used in the database.

.Query
[source, cypher, role=test-fail]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

In this case the node is not created in the graph.

.Error message
[source, error]
----
Node(0) already exists with label `Book` and property `isbn` = '1449356265'
----

======


[discrete]
[[constraints-fail-to-create-a-uniqueness-constraint-due-to-conflicting-nodes]]
=== Creating a constraint when there exist conflicting nodes will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `title` on nodes with the `Book` label when there are two nodes with the same `title`.

////
[source, cypher, role=test-setup]
----
CREATE (book:Book {isbn: '9780393972832', title: 'Moby Dick'});
CREATE (book:Book {isbn: '9780763630188', title: 'Moby Dick'})
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT book_title FOR (book:Book) REQUIRE book.title IS UNIQUE
----

In this case the constraint can not be created because it is violated by existing data.
Either use xref::indexes-for-search-performance.adoc[] instead, or remove the offending nodes and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( name='book_title', type='UNIQUENESS', schema=(:Book {title}) ):
Both Node(0) and Node(1) have the label `Book` and property `title` = 'Moby Dick'
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[NOTE]
====
The constraint type will be updated to say `NODE_UNIQUENESS` in Neo4j version 6.0.
====
////

======

The constraint creation fails on the first offending nodes that are found.
This does not guarantee that there are no other offending nodes in the data.
Therefore, all the data should be checked and cleaned up before re-attempting the constraint creation.

This is an example `MATCH` query to find all offending nodes with the non-unique property values for the constraint above:

.Query
[source, cypher]
----
MATCH (book1:Book), (book2:Book)
WHERE book1.title = book2.title AND NOT book1 = book2
RETURN book1, book2
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
TODO: Remove 'test-skip' message on queries when feature is introduced
[[constraints-examples-relationship-uniqueness]]
== Relationship property uniqueness constraints

A relationship property uniqueness constraint ensures that all relationships with a particular relationship type have a set of defined properties whose combined value is unique when existing.

* xref::constraints/examples.adoc#constraints-create-a-relationship-uniqueness-constraints[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-uniqueness-constraints-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-uniqueness-constraints-with-index-provider[]
* xref::constraints/examples.adoc#constraints-create-an-already-existing-relationship-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-uniqueness-constraint-on-same-schema-as-existing-index[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-complies-with-a-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-violates-a-uniqueness-constraint[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-uniqueness-constraint-due-to-conflicting-relationships[]


[discrete]
[[constraints-create-a-relationship-uniqueness-constraints]]
=== Create a relationship property uniqueness constraint

When creating a property uniqueness constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT constraint_name
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======


[discrete]
[[constraints-create-a-relationship-uniqueness-constraints-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another relationship property uniqueness constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

Assuming no constraint with the given name or other relationship property uniqueness constraint on the same schema exists:

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======


[discrete]
[[constraints-create-a-relationship-uniqueness-constraints-with-index-provider]]
=== Specifying an index provider when creating a constraint

To create a property uniqueness constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]

// Only one valid value exists for the index provider in Neo4j 5.0


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT constraint_with_options
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE (friend.nickname, friend.since) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0',
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======

There are no valid index configuration values for the constraint-backing range indexes.


[discrete]
[[constraints-create-an-already-existing-relationship-uniqueness-constraint]]
=== Creating an already existing constraint will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type, when that constraint already exists.

// Set-up to get expected behavior:
// CREATE CONSTRAINT preExistingUnique FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case, the constraint cannot be created because it already exists.

.Error message
[source, error]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='RELATIONSHIP_UNIQUENESS', schema=()-[:FRIENDS_WITH {nickname}]-(), ownedIndex=3 )
----

======


[discrete]
[[constraints-create-a-relationship-uniqueness-constraint-on-same-schema-as-existing-index]]
=== Creating a constraint on the same schema as an existing index will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type, when an index already exists on that relationship type and property combination.

// Set-up to get expected behavior:
// CREATE INDEX FOR ()-[friend:FRIENDS_WITH]-() ON (friend.nickname)

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case, the constraint cannot be created because there already exists an index covering that schema.

.Error message
[source, error]
----
There already exists an index ()-[:FRIENDS_WITH {nickname}]-().
A constraint cannot be created until the index has been dropped.
----

======


[discrete]
[[constraints-create-a-relationship-that-complies-with-a-uniqueness-constraint]]
=== Creating a relationship that complies with an existing constraint


.+CREATE RELATIONSHIP+
======

Create a `FRIENDS_WITH` relationship with an `nickname` that is not already in the database.

// Set-up to get expected behavior:
// CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE

.Query
[source, cypher, role=test-skip]
----
CREATE (:Person {name: 'Josefin'})-[:FRIENDS_WITH {nickname: 'Mimi'}]->(:Person {name: 'Emilia'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 2
Relationships created: 1
Properties set: 3
Labels added: 2
----

======


[discrete]
[[constraints-create-a-relationship-that-violates-a-uniqueness-constraint]]
=== Creating a relationship that violates an existing constraint will fail


.+CREATE RELATIONSHIP+
======

Create a `FRIENDS_WITH` relationship with an `nickname` that is already used in the database.

// Set-up to get expected behavior:
// CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
// CREATE (:Person {name: 'Emma'}), (:Person {name: 'Josefin'})-[:FRIENDS_WITH {nickname: 'Mimi'}]->(:Person {name: 'Emilia'})

.Query
[source, cypher, role=test-skip]
----
MATCH (emma:Person {name: 'Emma'}), (emilia:Person {name: 'Emilia'})
CREATE (emma)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia)
----

In this case, the relationship is not created in the graph.

.Error message
[source, error]
----
Relationship(0) already exists with type `FRIENDS_WITH` and property `nickname` = 'Mimi'
----

======


[discrete]
[[constraints-fail-to-create-a-uniqueness-constraint-due-to-conflicting-relationships]]
=== Creating a constraint when there exist conflicting relationships will fail


.+CREATE CONSTRAINT+
======

Create a property uniqueness constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type when there are two relationships with the same `nickname`.

// Set-up to get expected behavior:
// CREATE (emma:Person {name: 'Emma'}), (josefin:Person {name: 'Josefin'}), (emilia:Person {name: 'Emilia'})
// CREATE (josefin)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia), (emma)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia)

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT friends FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case, the constraint cannot be created because it is violated by existing data.
Either use xref::indexes-for-search-performance.adoc[] instead, or remove the offending relationships and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( name='friends', type='RELATIONSHIP_UNIQUENESS', schema=()-[:FRIENDS_WITH {nickname}]-() ):
Both Relationship(0) and Relationship(1) have the type `FRIENDS_WITH` and property `nickname` = 'Mimi'
----

======
////

[role=enterprise-edition]
[[constraints-examples-node-property-existence]]
== Node property existence constraints

A node property existence constraint ensures that all nodes with a certain label have a certain property.

* xref::constraints/examples.adoc#constraints-create-a-node-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-property-existence-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-an-already-existing-node-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-complies-with-a-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-violates-a-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-removing-an-existence-constrained-node-property[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-property-existence-constraint-due-to-existing-node[]


[discrete]
[[constraints-create-a-node-property-existence-constraint]]
=== Create a node property existence constraint

When creating a node property existence constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT author_name
FOR (author:Author) REQUIRE author.name IS NOT NULL
----

.Result
[queryresult]
----
Added 1 constraint.
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[NOTE]
====
The statistics for property existence constraints will be split between nodes and relationships in Neo4j version 6.0.
For the node property existence constraints, they will say `Node property existence constraints`.
====
////

======


[discrete]
[[constraints-create-a-node-property-existence-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another node property existence constraint on the same schema already existed.


.+CREATE CONSTRAINT+
======

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT author_pseudonym 
FOR (author:Author) REQUIRE author.pseudonym IS UNIQUE
----
////

.Query
[source, cypher]
----
CREATE CONSTRAINT author_pseudonym IF NOT EXISTS
FOR (author:Author) REQUIRE author.pseudonym IS NOT NULL
----

Assuming a constraint with the name `author_pseudonym` already existed:

.Result
[queryresult]
----
(no changes, no records)
----

======


[discrete]
[[constraints-create-an-already-existing-node-property-existence-constraint]]
=== Creating an already existing constraint will fail


.+CREATE CONSTRAINT+
======

Create a node property existence constraint on the property `name` on nodes with the `Author` label, when that constraint already exists.

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT author_name
FOR (author:Author) REQUIRE author.name IS NOT NULL
----

In this case the constraint can not be created because it already exists.

.Error message
[source, error]
----
An equivalent constraint already exists, 'Constraint( id=10, name='author_name', type='NODE PROPERTY EXISTENCE', schema=(:Author {name}) )'.
----

======


[discrete]
[[constraints-create-a-node-that-complies-with-a-property-existence-constraint]]
=== Creating a node that complies with an existing constraint


.+CREATE NODE+
======

Create an `Author` node with a `name` property.

.Query
[source, cypher]
----
CREATE (author:Author {name:'Virginia Woolf'})
----

.Result
[queryresult]
----
Added 1 label, created 1 node, set 1 properties
----

======


[discrete]
[[constraints-create-a-node-that-violates-a-property-existence-constraint]]
=== Creating a node that violates an existing constraint will fail


.+CREATE NODE+
======

Trying to create an `Author` node without a `name` property, given a property existence constraint on `:Author(name)`.

.Query
[source, cypher, role=test-fail]
----
CREATE (author:Author)
----

In this case the node is not created in the graph.

.Error message
[source, error]
----
Node(0) with label `Author` must have the property `name`
----

======


[discrete]
[[constraints-removing-an-existence-constrained-node-property]]
=== Removing an existence constrained node property will fail


.+REMOVE PROPERTY+
======

Trying to remove the `name` property from an existing node `Author`, given a property existence constraint on `:Author(name)`.

.Query
[source, cypher, role=test-fail]
----
MATCH (author:Author {name: 'Virginia Woolf'})
REMOVE author.name
----

In this case the property is not removed.

.Error message
[source, error]
----
Node(0) with label `Author` must have the property `name`
----

======


[discrete]
[[constraints-fail-to-create-a-property-existence-constraint-due-to-existing-node]]
=== Creating a constraint when there exist conflicting nodes will fail


.+CREATE CONSTRAINT+
======

Create a constraint on the property `nationality` on nodes with the `Author` label when there already exists a node without a `nationality` property.

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT author_nationality FOR (author:Author) REQUIRE author.nationality IS NOT NULL
----

In this case the constraint can't be created because it is violated by existing data.
Remove the offending nodes and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( type='NODE PROPERTY EXISTENCE', schema=(:Author {nationality}) ):
Node(0) with label `Author` must have the property `nationality`
----

======

The constraint creation fails on the first offending node that is found.
This does not guarantee that there are no other offending nodes in the data.
Therefore, all the data should be checked and cleaned up before re-attempting the constraint creation.

This is an example `MATCH` query to find all offending nodes missing the property for the constraint above:

.Query
[source, cypher]
----
MATCH (author:Author)
WHERE author.nationality IS NULL
RETURN author
----


[role=enterprise-edition]
[[constraints-examples-relationship-property-existence]]
== Relationship property existence constraints

A relationship property existence constraint ensures that all relationships with a certain type have a certain property.

* xref::constraints/examples.adoc#constraints-create-a-relationship-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-property-existence-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-an-already-existing-relationship-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-complies-with-a-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-violates-a-property-existence-constraint[]
* xref::constraints/examples.adoc#constraints-removing-an-existence-constrained-relationship-property[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-property-existence-constraint-due-to-existing-relationship[]


[discrete]
[[constraints-create-a-relationship-property-existence-constraint]]
=== Create a relationship property existence constraint

When creating a relationship property existence constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT wrote_year
FOR ()-[wrote:WROTE]-() REQUIRE wrote.year IS NOT NULL
----

.Result
[queryresult]
----
Added 1 constraint.
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[NOTE]
====
The statistics for property existence constraints will be split between nodes and relationships in Neo4j version 6.0.
For the relationship property existence constraints, they will say `Relationship property existence constraints`.
====
////

======


[discrete]
[[constraints-create-a-relationship-property-existence-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another relationship property existence constraint on the same schema already existed.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT wrote_year IF NOT EXISTS 
FOR ()-[wrote:WROTE]-() REQUIRE wrote.year IS NOT NULL
----

Assuming that such a constraint already existed:

.Result
[queryresult]
----
(no changes, no records)
----

======


[discrete]
[[constraints-create-an-already-existing-relationship-property-existence-constraint]]
=== Creating an already existing constraint will fail


.+CREATE CONSTRAINT+
======

Create a named relationship property existence constraint on the property `locations` on relationships with the `WROTE` type, when a constraint with the given name already exists.

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT wrote_locations FOR ()-[wrote:WROTE]-() REQUIRE wrote.location IS NOT NULL
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT wrote_locations
FOR ()-[wrote:WROTE]-() REQUIRE wrote.locations IS NOT NULL
----

In this case the constraint can not be created because there already exists a constraint with the given name.

.Error message
[source, error]
----
There already exists a constraint called 'wrote_locations'.
----

======


[discrete]
[[constraints-create-a-relationship-that-complies-with-a-property-existence-constraint]]
=== Creating a relationship that complies with an existing constraint


.+CREATE RELATIONSHIP+
======

Create a `WROTE` relationship with a `year` and `location` property, given property existence constraints on `:WROTE(year)` and `:WROTE(location)`.

.Query
[source, cypher]
----
CREATE (author:Author {name: 'Emily Brontë'})-[wrote:WROTE {year: 1847, location: 'Haworth, United Kingdom'}]->(book:Book {title:'Wuthering Heights', isbn: 9789186579296})
----

.Result
[queryresult]
----
Added 2 labels, created 2 nodes, set 5 properties, created 1 relationship
----

======


[discrete]
[[constraints-create-a-relationship-that-violates-a-property-existence-constraint]]
=== Creating a relationship that violates an existing constraint will fail


.+CREATE RELATIONSHIP+
======

Trying to create a `WROTE` relationship without a `location` property, given a property existence constraint `:WROTE(location)`.

.Query
[source, cypher, role=test-fail]
----
CREATE (author:Author {name: 'Charlotte Brontë'})-[wrote:WROTE {year: 1847}]->(book:Book {title: 'Jane Eyre', isbn:9780194241762})
----

In this case the relationship is not created in the graph.

.Error message
[source, error]
----
Relationship(0) with type `WROTE` must have the property `location`
----

======


[discrete]
[[constraints-removing-an-existence-constrained-relationship-property]]
=== Removing an existence constrained relationship property will fail


.+REMOVE PROPERTY+
======

Trying to remove the `location` property from an existing relationship of type `WROTE`, given a property existence constraint `:WROTE(location)`.

.Query
[source, cypher, role=test-fail]
----
MATCH (author:Author)-[wrote:WROTE]->(book:Book) REMOVE wrote.location
----

In this case the property is not removed.

.Error message
[source, error]
----
Relationship(0) with type `WROTE` must have the property `location`
----

======


[discrete]
[[constraints-fail-to-create-a-property-existence-constraint-due-to-existing-relationship]]
=== Creating a constraint when there exist conflicting relationships will fail


.+CREATE CONSTRAINT+
======

Create a constraint on the property `language` on relationships with the `WROTE` type when there already exists a relationship without a property named `language`.

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT wrote_language FOR ()-[wrote:WROTE]-() REQUIRE wrote.language IS NOT NULL
----

In this case the constraint can not be created because it is violated by existing data.
Remove the offending relationships and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( type='RELATIONSHIP PROPERTY EXISTENCE', schema=()-[:WROTE {language}]-() ):
Relationship(0) with type `WROTE` must have the property `language`
----

======

The constraint creation fails on the first offending relationship that are found.
This does not guarantee that there are no other offending relationships in the data.
Therefore, all the data should be checked and cleaned up before re-attempting the constraint creation.

This is an example `MATCH` query to find all offending relationships missing the property for the constraint above:

.Query
[source, cypher]
----
MATCH ()-[wrote:WROTE]-()
WHERE wrote.language IS NULL
RETURN wrote
----


[role=enterprise-edition]
[[constraints-examples-node-key]]
== Node key constraints

A node key constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique and all properties in the set are present.

* xref::constraints/examples.adoc#constraints-create-a-node-key-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-key-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-a-node-key-constraint-with-index-provider[]
* xref::constraints/examples.adoc#constraints-node-key-and-uniqueness-constraint-on-the-same-schema[]
* xref::constraints/examples.adoc#constraints-create-a-node-key-constraint-with-the-same-name-as-existing-index[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-complies-with-a-node-key-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-node-that-violates-a-node-key-constraint[]
* xref::constraints/examples.adoc#constraints-removing-a-node-key-constrained-property[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-node-key-constraint-due-to-existing-node[]


[discrete]
[[constraints-create-a-node-key-constraint]]
=== Create a node key constraint

When creating a node key constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT actor_fullname
FOR (actor:Actor) REQUIRE (actor.firstname, actor.surname) IS NODE KEY
----

.Result
[queryresult]
----
Added 1 constraint.
----

======


[discrete]
[[constraints-create-a-node-key-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another node key constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT actor_names IF NOT EXISTS
FOR (actor:Actor) REQUIRE (actor.firstname, actor.surname) IS NODE KEY
----

Assuming a node key constraint on `(:Actor {firstname, surname})` already existed:

.Result
[queryresult]
----
(no changes, no records)
----

======


[discrete]
[[constraints-create-a-node-key-constraint-with-index-provider]]
=== Specifying an index provider when creating a constraint

To create a node key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]


.+CREATE CONSTRAINT+
======

.Query
[source, cypher]
----
CREATE CONSTRAINT constraint_with_provider
FOR (actor:Actor) REQUIRE (actor.surname) IS NODE KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
Added 1 constraint.
----

======

There is no valid index configuration values for the constraint-backing range indexes.


[discrete]
[[constraints-node-key-and-uniqueness-constraint-on-the-same-schema]]
=== Node key and property uniqueness constraints are not allowed on the same schema


.+CREATE CONSTRAINT+
======

Create a node key constraint on the properties `firstname` and `age` on nodes with the `Actor` label, when a property uniqueness constraint already exists on the same label and property combination.

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT preExisting_actor_name_age FOR (actor:Actor) REQUIRE (actor.firstname, actor.age) IS UNIQUE
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT actor_name_age FOR (actor:Actor) REQUIRE (actor.firstname, actor.age) IS NODE KEY
----

In this case the constraint can not be created because there already exist a conflicting constraint on that label and property combination.

.Error message
[source, error]
----
Constraint already exists:
Constraint( id=10, name='preExisting_actor_name_age', type='UNIQUENESS', schema=(:Actor {firstname, age}), ownedIndex=9 )
----

======


[discrete]
[[constraints-create-a-node-key-constraint-with-the-same-name-as-existing-index]]
=== Creating a constraint on same name as an existing index will fail


.+CREATE CONSTRAINT+
======

Create a named node key constraint on the property `citizenship` on nodes with the `Actor` label, when an index already exists with the given name.

////
[source, cypher, role=test-setup]
----
CREATE INDEX citizenship FOR (person:Person) ON (person.citizenship)
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT citizenship
FOR (actor:Actor) REQUIRE actor.citizenship IS NODE KEY
----

In this case the constraint can't be created because there already exists an index with the given name.

.Error message
[source, error]
----
There already exists an index called 'citizenship'.
----

======


[discrete]
[[constraints-create-a-node-that-complies-with-a-node-key-constraint]]
=== Creating a node that complies with an existing constraint


.+CREATE NODE+
======

Create an `Actor` node with a `firstname` and `surname` property.

.Query
[source, cypher]
----
CREATE (actor:Actor {firstname: 'Keanu', surname: 'Reeves'})
----

.Result
[queryresult]
----
Added 1 label, created 1 node, set 2 properties.
----

======


[discrete]
[[constraints-create-a-node-that-violates-a-node-key-constraint]]
=== Creating a node that violates an existing constraint will fail


.+CREATE NODE+
======

Trying to create an `Actor` node without a `firstname` property, given a node key constraint on `:Actor(firstname, surname)`, will fail.


.Query
[source, cypher, role=test-fail]
----
CREATE (actor:Actor {surname: 'Wood'})
----

In this case the node is not created in the graph.

.Error message
[source, error]
----
Node(0) with label `Actor` must have the properties (`firstname`, `surname`)
----

======


[discrete]
[[constraints-removing-a-node-key-constrained-property]]
=== Removing a +NODE KEY+-constrained property will fail


.+REMOVE PROPERTY+
======

Trying to remove the `firstname` property from an existing node `Actor`, given a `NODE KEY` constraint on `:Actor(firstname, surname)`.

.Query
[source, cypher, role=test-fail]
----
MATCH (actor:Actor {firstname: 'Keanu', surname: 'Reeves'}) REMOVE actor.firstname
----

In this case the property is not removed.

.Error message
[source, error]
----
Node(0) with label `Actor` must have the properties (`firstname`, `surname`)
----

======


[discrete]
[[constraints-fail-to-create-a-node-key-constraint-due-to-existing-node]]
=== Creating a constraint when there exist conflicting node will fail


.+CREATE CONSTRAINT+
======

Trying to create a node key constraint on the property `born` on nodes with the `Actor` label will fail when a node without a `born` property already exists in the database.

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT actor_born FOR (actor:Actor) REQUIRE (actor.born) IS NODE KEY
----

In this case the node key constraint can not be created because it is violated by existing data.
Either use xref::indexes-for-search-performance.adoc[] instead, or remove the offending nodes and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( type='NODE KEY', schema=(:Actor {born}) ):
Node(0) with label `Actor` must have the property `born`
----

======

The constraint creation fails on the first offending nodes that are found.
This does not guarantee that there are no other offending nodes in the data.
Therefore, all the data should be checked and cleaned up before re-attempting the constraint creation.

This is an example `MATCH` query to find all offending nodes for the constraint above:

.Query
[source, cypher]
----
MATCH (actor1:Actor), (actor2:Actor)
WHERE actor1.born = actor2.born AND NOT actor1 = actor2
UNWIND [actor1, actor2] AS actor
RETURN actor, 'non-unique' AS reason

UNION

MATCH (actor:Actor)
WHERE actor.born IS NULL
RETURN actor, 'non-existing' AS reason
----

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[role=enterprise-edition]
TODO: Remove role=skip-test from queries once feature is introduced
[[constraints-examples-relationship-key]]
== Relationship key constraints

A relationship key constraint ensures that all relationships with a particular relationship type have a set of defined properties whose combined value is unique. 
It also ensures that all properties in the set are present.

* xref::constraints/examples.adoc#constraints-create-a-relationship-key-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-key-constraint-if-not-exist[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-key-constraint-with-index-provider[]
* xref::constraints/examples.adoc#constraints-relationship-key-and-uniqueness-constraint-on-the-same-schema[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-key-constraint-with-the-same-name-as-existing-index[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-complies-with-a-relationship-key-constraint[]
* xref::constraints/examples.adoc#constraints-create-a-relationship-that-violates-a-relationship-key-constraint[]
* xref::constraints/examples.adoc#constraints-removing-a-relationship-key-constrained-property[]
* xref::constraints/examples.adoc#constraints-fail-to-create-a-relationship-key-constraint-due-to-existing-relationship[]


[discrete]
[[constraints-create-a-relationship-key-constraint]]
=== Create a relationship key constraint

When creating a relationship key constraint, a name can be provided.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT constraint_name
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship key constraints added: 1
----

======


[discrete]
[[constraints-create-a-relationship-key-constraint-if-not-exist]]
=== Handling existing constraints when creating a constraint

Creating an already existing constraint will fail. 
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and no constraint is created if any other constraint with the given name or another relationship key constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

// Set-up to get expected behavior:
// CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY
----

Assuming a relationship key constraint on `()-[:ROAD {startPoint, endPoint}]-()` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[constraints-create-a-relationship-key-constraint-with-index-provider]]
=== Specifying an index provider when creating a constraint

To create a relationship key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT constraint_with_provider
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship key constraints added: 1
----

======

There is no valid index configuration values for the constraint-backing range indexes.


[discrete]
[[constraints-relationship-key-and-uniqueness-constraint-on-the-same-schema]]
=== Relationship key and property uniqueness constraints are not allowed on the same schema


.+CREATE CONSTRAINT+
======

Create a relationship key constraint on the properties `startPoint` and `endPoint` on relationships with the `ROAD` relationship type, when a property uniqueness constraint already exists on the same relationship type and property combination.

// Set-up to get expected behavior:
// CREATE CONSTRAINT preExistingUnique FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS UNIQUE

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
----

In this case, the constraint cannot be created because there already exists a conflicting constraint on that relationship type and property combination.

.Error message
[source, error]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='RELATIONSHIP_UNIQUENESS', schema=()-[:ROAD {startPoint, endPoint}]-(), ownedIndex=3 )
----

======


[discrete]
[[constraints-create-a-relationship-key-constraint-with-the-same-name-as-existing-index]]
=== Creating a constraint on same name as an existing index will fail


.+CREATE CONSTRAINT+
======

Create a named relationship key constraint on the property `coordinates` on relationships with the `INTERSECTION` relationship type, when an index already exists with the given name.

// Set-up to get expected behavior:
// CREATE INDEX intersections FOR ()-[intersect:Roundabout]-() ON (intersect.coordinates)

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT intersections
FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
----

In this case, the constraint cannot be created because there already exists an index with the given name.

.Error message
[source, error]
----
There already exists an index called 'intersections'.
----

======


[discrete]
[[constraints-create-a-relationship-that-complies-with-a-relationship-key-constraint]]
=== Creating a relationship that complies with an existing constraint


.+CREATE RELATIONSHIP+
======

Create a `ROAD` relationship with both a `startPoint` and `endPoint` property.

// Set-up to get expected behavior:
// CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
// CREATE (:Intersection {name: 'a', coordinates: point({x: 1, y:2})}), (:Intersection {name: 'b', coordinates: point({x: 2, y:5})})

.Query
[source, cypher, role=test-skip]
----
MATCH (a:Intersection {name: 'a'}), (b:Intersection {name: 'b'})
CREATE (a)-[:ROAD {startPoint: a.coordinates, endPoint: b.coordinates}]->(b)
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationships created: 1
Properties set: 2
----

======


[discrete]
[[constraints-create-a-relationship-that-violates-a-relationship-key-constraint]]
=== Creating a relationship that violates an existing constraint will fail


.+CREATE RELATIONSHIP+
======

Trying to create a `INTERSECTION` relationship without a `coordinates` property, given a relationship key constraint on `:INTERSECTION(coordinates)`, will fail.

// Set-up to get expected behavior:
// CREATE CONSTRAINT FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
// CREATE (:Road {name: 'a'}), (:Road {name: 'b'})

.Query
[source, cypher, role=test-skip]
----
MATCH (a:Road {name: 'a'}), (b:Road {name: 'b'})
CREATE (a)-[:INTERSECTION]->(b)
----

In this case, the relationship is not created in the graph.

.Error message
[source, error]
----
Relationship(0) with type `INTERSECTION` must have the property `coordinates`
----

======


[discrete]
[[constraints-removing-a-relationship-key-constrained-property]]
=== Removing a +RELATIONSHIP KEY+-constrained property will fail


.+REMOVE PROPERTY+
======

Trying to remove the `endPoint` property from an existing relationship `ROAD`, given a `RELATIONSHIP KEY` constraint on `:ROAD(startPoint, endPoint)`.

// Set-up to get expected behavior:
// CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
// CREATE (a:Intersection {name: 'a', coordinates: point({x: 1, y:2})}), (b:Intersection {name: 'b', coordinates: point({x: 2, y:5})})
// CREATE (a)-[:ROAD {startPoint: a.coordinates, endPoint: b.coordinates}]->(b)

.Query
[source, cypher, role=test-skip]
----
MATCH ()-[r:ROAD {startPoint: point({x: 1, y:2}), endPoint: point({x: 2, y:5})}]->() REMOVE r.endPoint
----

In this case, the property is not removed.

.Error message
[source, error]
----
Relationship(0) with type `ROAD` must have the properties (`startPoint`, `endPoint`)
----

======


[discrete]
[[constraints-fail-to-create-a-relationship-key-constraint-due-to-existing-relationship]]
=== Creating a constraint when there exist conflicting relationships will fail


.+CREATE CONSTRAINT+
======

Trying to create a relationship key constraint on the property `coordinates` on relationships with the `INTERSECTION` relationship type will fail when two relationships with identical `coordinates` already exists in the database.

// Set-up to get expected behavior:
// CREATE (a:Road {name: 'a'}), (b:Road {name: 'b'})
// CREATE (a)-[:INTERSECTION {coordinates: point({x:1, y:2})}]->(b)
// CREATE (a)<-[:INTERSECTION {coordinates: point({x:1, y:2})}]-(b)

.Query
[source, cypher, role=test-skip]
----
CREATE CONSTRAINT intersectionConstraint FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
----

In this case, the relationship key constraint cannot be created because it is violated by existing data.
Either use xref::indexes-for-search-performance.adoc[] instead, or remove the offending relationships and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( name='intersectionConstraint', type='RELATIONSHIP KEY', schema=()-[:INTERSECTION {coordinates}]-() ):
Both Relationship(0) and Relationship(1) have the type `INTERSECTION` and property `coordinates` = {geometry: {type: "Point", coordinates: [1.0, 2.0], crs: {type: link, properties: {href: "http://spatialreference.org/ref/sr-org/7203/", code: 7203}}}}
----

======
////

[[constraints-examples-drop-constraint]]
== Drop a constraint by name

* xref::constraints/examples.adoc#constraints-drop-a-constraint[]
* xref::constraints/examples.adoc#constraints-drop-a-non-existing-constraint[]


[discrete]
[[constraints-drop-a-constraint]]
=== Drop a constraint

A constraint can be dropped using the name with the `DROP CONSTRAINT constraint_name` command.
It is the same command for uniqueness, property existence, and node key constraints.
// TODO: Switch the row above to the one below when adding back relationship key and uniqueness constraints
//It is the same command for uniqueness, property existence, and node/relationship key constraints.
The name of the constraint can be found using the xref::constraints/syntax.adoc#constraints-syntax-list[`SHOW CONSTRAINTS` command], given in the output column `name`.


.+DROP CONSTRAINT+
======

.Query
[source, cypher]
----
DROP CONSTRAINT book_isbn
----

.Result
[queryresult]
----
Removed 1 constraint.
----

======


[discrete]
[[constraints-drop-a-non-existing-constraint]]
=== Drop a non-existing constraint

If it is uncertain if any constraint with a given name exists and you want to drop it if it does but not get an error should it not, use `IF EXISTS`.
It is the same command for uniqueness, property existence, and node constraints.
// TODO: Switch the row above to the one below when adding back relationship key and uniqueness constraints
//It is the same command for uniqueness, property existence, and node/relationship key constraints.

.+DROP CONSTRAINT+
======

.Query
[source, cypher]
----
DROP CONSTRAINT missing_constraint_name IF EXISTS
----

.Result
[queryresult]
----
(no changes, no records)
----

======


[[constraints-examples-list-constraint]]
== Listing constraints

* xref::constraints/examples.adoc#constraints-listing-all-constraints[]
* xref::constraints/examples.adoc#constraints-listing-constraints-with-filtering[]


[discrete]
[[constraints-listing-all-constraints]]
=== Listing all constraints

To list all constraints with the default output columns, the `SHOW CONSTRAINTS` command can be used.
If all columns are required, use `SHOW CONSTRAINTS YIELD *`.

[NOTE]
====
One of the output columns from `SHOW CONSTRAINTS` is the name of the constraint.
This can be used to drop the constraint with the xref::constraints/syntax.adoc#constraints-syntax-drop[`DROP CONSTRAINT` command].
====


.+SHOW CONSTRAINTS+
======

.Query
[source, cypher]
----
SHOW CONSTRAINTS
----

[queryresult]
----
╒════╤════════════════════════════╤═════════════════════════════════╤══════════════╤═══════════════╤═══════════════════════╤════════════════════════════╕
│"id"│"name"                      │"type"                           │"entityType"  │"labelsOrTypes"│"properties"           │"ownedIndex"                │
╞════╪════════════════════════════╪═════════════════════════════════╪══════════════╪═══════════════╪═══════════════════════╪════════════════════════════╡
│16  │"actor_fullname"            │"NODE_KEY"                       │"NODE"        │["Actor"]      │["firstname","surname"]│"actor_fullname"            │
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│10  │"author_name"               │"NODE_PROPERTY_EXISTENCE"        │"NODE"        │["Author"]     │["name"]               │null                        │
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│12  │"author_pseudonym"          │"UNIQUENESS"                     │"NODE"        │["Author"]     │["pseudonym"]          │"author_pseudonym"          │
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│4   │"book_isbn2"                │"UNIQUENESS"                     │"NODE"        │["Book"]       │["isbn2"]              │"book_isbn2"                │
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│6   │"constraint_with_options"   │"UNIQUENESS"                     │"NODE"        │["Book"]       │["prop1","prop2"]      │"constraint_with_options"   │
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│18  │"constraint_with_provider"  │"NODE_KEY"                       │"NODE"        │["Actor"]      │["surname"]            │"constraint_with_provider"  │
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│20  │"preExisting_actor_name_age"│"UNIQUENESS"                     │"NODE"        │["Actor"]      │["firstname","age"]    │"preExisting_actor_name_age"│
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│8   │"preExisting_book_published"│"UNIQUENESS"                     │"NODE"        │["Book"]       │["published"]          │"preExisting_book_published"│
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│14  │"wrote_locations"           │"RELATIONSHIP_PROPERTY_EXISTENCE"│"RELATIONSHIP"│["WROTE"]      │["location"]           │null                        │
├────┼────────────────────────────┼─────────────────────────────────┼──────────────┼───────────────┼───────────────────────┼────────────────────────────┤
│13  │"wrote_year"                │"RELATIONSHIP_PROPERTY_EXISTENCE"│"RELATIONSHIP"│["WROTE"]      │["year"]               │null                        │
└────┴────────────────────────────┴─────────────────────────────────┴──────────────┴───────────────┴───────────────────────┴────────────────────────────┘
10 rows
----

////
TODO: Update the above table of constraints once the relationship key and uniqueness constraints are no longer behind a feature flag. 
////

////
TODO: Re-add this part when adding back relationship key and uniqueness constraints
[NOTE]
====
The `type` column returns `UNIQUENESS` for the node property uniqueness constraint and `RELATIONSHIP_UNIQUENESS` for the relationship property uniqueness constraint.
The `type` for node property uniqueness constraint will be updated to `NODE_UNIQUENESS` in Neo4j version 6.0.
====
////

======


[discrete]
[[constraints-listing-constraints-with-filtering]]
=== Listing constraints with filtering

One way of filtering the output from `SHOW CONSTRAINTS` by constraint type is the use of type keywords,
listed in the xref::constraints/syntax.adoc#constraints-syntax-list-type-filter[syntax for listing constraints type filter table].
For example, to show only property uniqueness constraints, use `SHOW UNIQUENESS CONSTRAINTS`.
Another more flexible way of filtering the output is to use the `WHERE` clause.
An example is to only show constraints on relationships.


.+SHOW CONSTRAINTS+
======

.Query
[source, cypher]
----
SHOW EXISTENCE CONSTRAINTS
WHERE entityType = 'RELATIONSHIP'
----

This will only return the default output columns.
To get all columns, use `+SHOW INDEXES YIELD * WHERE ...+`.

[queryresult]
----
╒════╤═════════════════╤═════════════════════════════════╤══════════════╤═══════════════╤════════════╤════════════╕
│"id"│"name"           │"type"                           │"entityType"  │"labelsOrTypes"│"properties"│"ownedIndex"│
╞════╪═════════════════╪═════════════════════════════════╪══════════════╪═══════════════╪════════════╪════════════╡
│14  │"wrote_locations"│"RELATIONSHIP_PROPERTY_EXISTENCE"│"RELATIONSHIP"│["WROTE"]      │["location"]│null        │
├────┼─────────────────┼─────────────────────────────────┼──────────────┼───────────────┼────────────┼────────────┤
│13  │"wrote_year"     │"RELATIONSHIP_PROPERTY_EXISTENCE"│"RELATIONSHIP"│["WROTE"]      │["year"]    │null        │
└────┴─────────────────┴─────────────────────────────────┴──────────────┴───────────────┴────────────┴────────────┘
2 rows
----

======

