:description: Examples of how to manage constraints used for ensuring data integrity.

[[administration-constraints-examples]]
= Examples

[abstract]
--
Examples of how to manage constraints used for ensuring data integrity.
--


[[administration-constraints-unique-nodes]]
== Unique node property constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint-with-specified-index-provider[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-an-already-existing-unique-property-constraint[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-unique-property-constraint-on-same-schema-as-existing-index[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-complies-with-unique-property-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-violates-a-unique-property-constraint[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-unique-property-constraint-due-to-conflicting-nodes[]


[discrete]
[[administration-constraints-create-a-unique-constraint]]
=== Create a unique constraint

When creating a unique constraint, a name can be provided.
The constraint ensures that your database will never contain more than one node with a specific label and one property value.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

======


[discrete]
[[administration-constraints-create-a-unique-constraint-only-if-it-does-not-already-exist]]
=== Create a unique constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The uniqueness constraint ensures that your database will never contain more than one node with a specific label and one property value.

[NOTE]
====
No constraint will be created if any other constraint with the given name or another uniqueness constraint on the same schema already exists.
====


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

Assuming no constraint with the given name or other uniqueness constraint on the same schema exists:

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

======


[discrete]
[[administration-constraints-create-a-unique-constraint-with-specified-index-provider]]
=== Create a unique constraint with specified index provider

To create a unique constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

Valid values for the index provider are:

* `range-1.0` label:default[]

// Only one valid value exists for the index provider in Neo4j 5.0


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_options
FOR (n:Label) REQUIRE (n.prop1, n.prop2) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0',
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

======


[discrete]
[[administration-constraints-failure-to-create-an-already-existing-unique-property-constraint]]
=== Failure to create an already existing unique property constraint


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `title` on nodes with the `Book` label, when that constraint already exists.

////
CREATE CONSTRAINT preExistingUnique FOR (book:Book) REQUIRE book.title IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.title IS UNIQUE
----

In this case the constraint can not be created because it already exists.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='UNIQUENESS', schema=(:Book {title}), ownedIndex=3 )
----

======


[discrete]
[[administration-constraints-failure-to-create-a-unique-property-constraint-on-same-schema-as-existing-index]]
=== Failure to create a unique property constraint on same schema as existing index


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `wordCount` on nodes with the `Book` label, when an index already exists on that label and property combination.

////
CREATE INDEX FOR (book:Book) ON (book.wordCount)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.wordCount IS UNIQUE
----

In this case the constraint can not be created because there already exists an index covering that schema.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index (:Book {wordCount}).
A constraint cannot be created until the index has been dropped.
----

======


[discrete]
[[administration-constraints-create-a-node-that-complies-with-unique-property-constraints]]
=== Create a node that complies with unique property constraints


.+CREATE NODE+
======

Create a `Book` node with an `isbn` that is not already in the database.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1
----

======


[discrete]
[[administration-constraints-create-a-node-that-violates-a-unique-property-constraint]]
=== Create a node that violates a unique property constraint


.+CREATE NODE+
======

Create a `Book` node with an `isbn` that is already used in the database.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) already exists with label `Book` and property `isbn` = '1449356265'
----

======


[discrete]
[[administration-constraints-failure-to-create-a-unique-property-constraint-due-to-conflicting-nodes]]
=== Failure to create a unique property constraint due to conflicting nodes


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `isbn` on nodes with the `Book` label when there are two nodes with the same `isbn`.

////
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

In this case the constraint can not be created because it is violated by existing data.
You may choose to use xref::indexes-for-search-performance.adoc[] instead or remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( name='constraint_62365a16', type='UNIQUENESS',
schema=(:Book {isbn}) ):
Both Node(0) and Node(1) have the label `Book` and property `isbn` = '1449356265'
----

======


[role=enterprise-edition]
[[administration-constraints-prop-exist-nodes]]
== Node property existence constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-node-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-property-existence-constraint-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-an-already-existing-node-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-complies-with-property-existence-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-violates-a-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-removing-an-existence-constrained-node-property[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-node-property-existence-constraint-due-to-existing-node[]
//* xref::constraints/examples.adoc#


[discrete]
[[administration-constraints-create-a-node-property-existence-constraint]]
=== Create a node property existence constraint

When creating a node property existence constraint, a name can be provided.
The constraint ensures that all nodes with a certain label have a certain property.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints added: 1
----

======

[discrete]
[[administration-constraints-create-a-node-property-existence-constraint-only-if-it-does-not-already-exist]]
=== Create a node property existence constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The node property existence constraint ensures that all nodes with a certain label have a certain property.
No constraint will be created if any other constraint with the given name or another node property existence constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
CREATE CONSTRAINT constraint_name FOR (book:Book) REQUIRE book.isbn IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

Assuming a constraint with the name `constraint_name` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-constraints-failure-to-create-an-already-existing-node-property-existence-constraint]]
=== Failure to create an already existing node property existence constraint


.+CREATE CONSTRAINT+
======

Create a node property existence constraint on the property `title` on nodes with the `Book` label, when that constraint already exists.

////
CREATE CONSTRAINT preExistingNodePropExist FOR (book:Book) REQUIRE book.title IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT booksShouldHaveTitles
FOR (book:Book) REQUIRE book.title IS NOT NULL
----

In this case the constraint can not be created because it already exists.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=3, name='preExistingNodePropExist', type='NODE PROPERTY EXISTENCE', schema=(:Book {title}) )
----

======


[discrete]
[[administration-constraints-create-a-node-that-complies-with-property-existence-constraints]]
=== Create a node that complies with property existence constraints


.+CREATE NODE+
======

Create a `Book` node with an `isbn` property.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1
----

======


[discrete]
[[administration-constraints-create-a-node-that-violates-a-property-existence-constraint]]
=== Create a node that violates a property existence constraint


.+CREATE NODE+
======

Trying to create a `Book` node without an `isbn` property, given a property existence constraint on `:Book(isbn)`.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {title: 'Graph Databases'})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Book` must have the property `isbn`
----

======


[discrete]
[[administration-constraints-removing-an-existence-constrained-node-property]]
=== Removing an existence constrained node property


.+REMOVE PROPERTY+
======

Trying to remove the `isbn` property from an existing node `book`, given a property existence constraint on `:Book(isbn)`.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
MATCH (book:Book {title: 'Graph Databases'})
REMOVE book.isbn
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Book` must have the property `isbn`
----

======


[discrete]
[[administration-constraints-failure-to-create-a-node-property-existence-constraint-due-to-existing-node]]
=== Failure to create a node property existence constraint due to existing node


.+CREATE CONSTRAINT+
======

Create a constraint on the property `isbn` on nodes with the `Book` label when there already exists  a node without an `isbn`.

////
CREATE (book:Book {title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

In this case the constraint can't be created because it is violated by existing data. We may choose to remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='NODE PROPERTY EXISTENCE', schema=(:Book
{isbn}) ):
Node(0) with label `Book` must have the property `isbn`
----

======


[role=enterprise-edition]
[[administration-constraints-prop-exist-rels]]
== Relationship property existence constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-property-existence-constraint-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-an-already-existing-relationship-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-that-complies-with-property-existence-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-that-violates-a-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-removing-an-existence-constrained-relationship-property[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-relationship-property-existence-constraint-due-to-existing-relationship[]


[discrete]
[[administration-constraints-create-a-relationship-property-existence-constraint]]
=== Create a relationship property existence constraint

When creating a relationship property existence constraint, a name can be provided.
The constraint ensures all relationships with a certain type have a certain property.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints added: 1
----

======


[discrete]
[[administration-constraints-create-a-relationship-property-existence-constraint-only-if-it-does-not-already-exist]]
=== Create a relationship property existence constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The relationship property existence constraint ensures all relationships with a certain type have a certain property.
No constraint will be created if any other constraint with the given name or another relationship property existence constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
CREATE CONSTRAINT constraint_name FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
IF NOT EXISTS FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

Assuming a constraint with the name `constraint_name` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-constraints-failure-to-create-an-already-existing-relationship-property-existence-constraint]]
=== Failure to create an already existing relationship property existence constraint


.+CREATE CONSTRAINT+
======

Create a named relationship property existence constraint on the property `week` on relationships with the `LIKED` type, when a constraint with the given name already exists.

////
CREATE CONSTRAINT relPropExist FOR ()-[like:LIKED]-() REQUIRE like.since IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT relPropExist
FOR ()-[like:LIKED]-() REQUIRE like.week IS NOT NULL
----

In this case the constraint can not be created because there already exists a constraint with the given name.

.Error message
[source, "error message", role="noheader"]
----
There already exists a constraint called 'relPropExist'.
----

======


[discrete]
[[administration-constraints-create-a-relationship-that-complies-with-property-existence-constraints]]
=== Create a relationship that complies with property existence constraints


.+CREATE RELATIONSHIP+
======

Create a `LIKED` relationship with a `day` property.

////
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (user:User)-[like:LIKED {day: 'yesterday'}]->(book:Book)
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 2
Relationships created: 1
Properties set: 1
Labels added: 2
----

======


[discrete]
[[administration-constraints-create-a-relationship-that-violates-a-property-existence-constraint]]
=== Create a relationship that violates a property existence constraint


.+CREATE RELATIONSHIP+
======

Trying to create a `LIKED` relationship without a `day` property, given a property existence constraint `:LIKED(day)`.

////
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (user:User)-[like:LIKED]->(book:Book)
----

In this case the relationship is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `LIKED` must have the property `day`
----

======


[discrete]
[[administration-constraints-removing-an-existence-constrained-relationship-property]]
=== Removing an existence constrained relationship property


.+REMOVE PROPERTY+
======

Trying to remove the `day` property from an existing relationship `like` of type `LIKED`, given a property existence constraint `:LIKED(day)`.

////
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
CREATE (user:User)-[like:LIKED {day: 'yesterday'}]->(book:Book)
////

.Query
[source, cypher, indent=0]
----
MATCH (user:User)-[like:LIKED]->(book:Book) REMOVE like.day
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `LIKED` must have the property `day`
----

======


[discrete]
[[administration-constraints-failure-to-create-a-relationship-property-existence-constraint-due-to-existing-relationship]]
=== Failure to create a relationship property existence constraint due to existing relationship


.+CREATE CONSTRAINT+
======

Create a constraint on the property `day` on relationships with the `LIKED` type when there already exists a relationship without a property named `day`.

////
CREATE (user:User)-[like:LIKED]->(book:Book)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

In this case the constraint can not be created because it is violated by existing data. We may choose to remove the offending relationships and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='RELATIONSHIP PROPERTY EXISTENCE',
schema=-[:LIKED {day}]- ):
Relationship(0) with type `LIKED` must have the property `day`
----

======


[role=enterprise-edition]
[[administration-constraints-node-key]]
== Node key constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-node-key-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-key-constraint-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-key-constraint-with-specified-index-provider[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-node-key-constraint-when-a-unique-property-constraint-exists-on-the-same-schema[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-node-key-constraint-with-the-same-name-as-existing-index[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-complies-with-node-key-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-violates-a-node-key-constraint[]
* xref::constraints/examples.adoc#administration-constraints-removing-a-node-key-constrained-property[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-node-key-constraint-due-to-existing-node[]


[discrete]
[[administration-constraints-create-a-node-key-constraint]]
=== Create a node key constraint

When creating a node key constraint, a name can be provided.
The constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique and all properties in the set are present.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----

======


[discrete]
[[administration-constraints-create-a-node-key-constraint-only-if-it-does-not-already-exist]]
=== Create a node key constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The node key constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique and all properties in the set are present.
No constraint will be created if any other constraint with the given name or another node key constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

Assuming a node key constraint on `(:Person {firstname, surname})` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-constraints-create-a-node-key-constraint-with-specified-index-provider]]
=== Create a node key constraint with specified index provider

To create a node key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

Valid values for the index provider are:

* `range-1.0` label:default[]


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_provider
FOR (n:Label) REQUIRE (n.prop1) IS NODE KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----

======


[discrete]
[[administration-constraints-failure-to-create-a-node-key-constraint-when-a-unique-property-constraint-exists-on-the-same-schema]]
=== Failure to create a node key constraint when a unique property constraint exists on the same schema


.+CREATE CONSTRAINT+
======

Create a node key constraint on the properties `firstname` and `age` on nodes with the `Person` label, when a unique property constraint already exists on the same label and property combination.

////
CREATE CONSTRAINT preExistingUnique FOR (p:Person) REQUIRE (p.firstname, p.age) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (p:Person) REQUIRE (p.firstname, p.age) IS NODE KEY
----

In this case the constraint can not be created because there already exist a conflicting constraint on that label and property combination.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='UNIQUENESS', schema=(:Person {firstname, age}), ownedIndex=3 )
----

======


[discrete]
[[administration-constraints-failure-to-create-a-node-key-constraint-with-the-same-name-as-existing-index]]
=== Failure to create a node key constraint with the same name as existing index


.+CREATE CONSTRAINT+
======

Create a named node key constraint on the property `title` on nodes with the `Book` label, when an index already exists with the given name.

////
CREATE INDEX bookTitle FOR (book:ComicBook) ON (book.title)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT bookTitle
FOR (book:Book) REQUIRE book.title IS NODE KEY
----

In this case the constraint can't be created because there already exists an index with the given name.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index called 'bookTitle'.
----

======


[discrete]
[[administration-constraints-create-a-node-that-complies-with-node-key-constraints]]
=== Create a node that complies with node key constraints


.+CREATE NODE+
======

Create a `Person` node with both a `firstname` and `surname` property.

////
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE (p:Person {firstname: 'John', surname: 'Wood', age: 55})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 3
Labels added: 1
----

======


[discrete]
[[administration-constraints-create-a-node-that-violates-a-node-key-constraint]]
=== Create a node that violates a node key constraint


.+CREATE NODE+
======

Trying to create a `Person` node without a `surname` property, given a node key constraint on `:Person(firstname, surname)`, will fail.

////
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE (p:Person {firstname: 'Jane', age: 34})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Person` must have the properties (firstname, surname)
----

======


[discrete]
[[administration-constraints-removing-a-node-key-constrained-property]]
=== Removing a +NODE KEY+-constrained property


.+REMOVE PROPERTY+
======

Trying to remove the `surname` property from an existing node `Person`, given a `NODE KEY` constraint on `:Person(firstname, surname)`.

////
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
CREATE (p:Person {firstname: 'John', surname: 'Wood', age: 55})
////

.Query
[source, cypher, indent=0]
----
MATCH (p:Person {firstname: 'John', surname: 'Wood'}) REMOVE p.surname
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Person` must have the properties (firstname, surname)
----

======


[discrete]
[[administration-constraints-failure-to-create-a-node-key-constraint-due-to-existing-node]]
=== Failure to create a node key constraint due to existing node


.+CREATE CONSTRAINT+
======

Trying to create a node key constraint on the property `surname` on nodes with the `Person` label will fail when a node without a `surname` already exists in the database.

////
CREATE (p:Person {firstname: 'John', age: 55})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

In this case the node key constraint can not be created because it is violated by existing data.
We may choose to remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='NODE PROPERTY EXISTENCE', schema=(:Person
{firstname, surname}) ):
Node(0) with label `Person` must have the properties (firstname, surname)
----

======


[[administration-constraints-drop-constraint]]
== Drop a constraint by name

* xref::constraints/examples.adoc#administration-constraints-drop-a-constraint[]
* xref::constraints/examples.adoc#administration-constraints-drop-a-non-existing-constraint[]


[discrete]
[[administration-constraints-drop-a-constraint]]
=== Drop a constraint

A constraint can be dropped using the name with the `DROP CONSTRAINT constraint_name` command.
It is the same command for unique property, property existence and node key constraints.
The name of the constraint can be found using the xref::constraints/syntax.adoc#administration-constraints-syntax-list[`SHOW CONSTRAINTS` command], given in the output column `name`.


.+DROP CONSTRAINT+
======

////
CREATE CONSTRAINT constraint_name FOR (n:Person) REQUIRE (n.name) IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
DROP CONSTRAINT constraint_name
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Named constraints removed: 1
----

======


[discrete]
[[administration-constraints-drop-a-non-existing-constraint]]
=== Drop a non-existing constraint

If it is uncertain if any constraint with a given name exists and you want to drop it if it does but not get an error should it not, use `IF EXISTS`.
It is the same command for unique property, property existence and node key constraints.

.+DROP CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
DROP CONSTRAINT missing_constraint_name IF EXISTS
----

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[[administration-constraints-list-constraint]]
== Listing constraints

* xref::constraints/examples.adoc#administration-constraints-listing-all-constraints[]
* xref::constraints/examples.adoc#administration-constraints-listing-constraints-with-filtering[]


[discrete]
[[administration-constraints-listing-all-constraints]]
=== Listing all constraints

To list all constraints with the default output columns, the `SHOW CONSTRAINTS` command can be used.
If all columns are required, use `SHOW CONSTRAINTS YIELD *`.

[NOTE]
====
One of the output columns from `SHOW CONSTRAINTS` is the name of the constraint.
This can be used to drop the constraint with the xref::constraints/syntax.adoc#administration-constraints-syntax-drop[`DROP CONSTRAINT` command].
====


.+SHOW CONSTRAINTS+
======

////
CREATE CONSTRAINT constraint_1bc95fcb FOR (n:Book) REQUIRE (n.isbn) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
SHOW CONSTRAINTS
----

[queryresult]
----
+-------------------------------------------------------------------------------------------------------------+
| id | name                  | type         | entityType | labelsOrTypes | properties | ownedIndex            |
+-------------------------------------------------------------------------------------------------------------+
| 4  | "constraint_1bc95fcb" | "UNIQUENESS" | "NODE"     | ["Book"]      | ["isbn"]   | "constraint_1bc95fcb" |
+-------------------------------------------------------------------------------------------------------------+
1 row
----

======


[discrete]
[[administration-constraints-listing-constraints-with-filtering]]
=== Listing constraints with filtering

One way of filtering the output from `SHOW CONSTRAINTS` by constraint type is the use of type keywords,
listed in xref::constraints/syntax.adoc#administration-constraints-syntax-list[Syntax for listing constraints].
For example, to show only unique node property constraints, use `SHOW UNIQUE CONSTRAINTS`.
Another more flexible way of filtering the output is to use the `WHERE` clause.
An example is to only show constraints on relationships.


.+SHOW CONSTRAINTS+
======

////
CREATE CONSTRAINT FOR (n:Book) REQUIRE (n.isbn) IS UNIQUE
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.title IS NOT NULL
CREATE CONSTRAINT `constraint_f076a74d` FOR ()-[r:KNOWS]-() REQUIRE r.since IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
SHOW EXISTENCE CONSTRAINTS
WHERE entityType = 'RELATIONSHIP'
----

This will only return the default output columns.
To get all columns, use `+SHOW INDEXES YIELD * WHERE ...+`.

[queryresult]
----
+---------------------------------------------------------------------------------------------------------------------------+
| id | name                  | type                              | entityType     | labelsOrTypes | properties | ownedIndex |
+---------------------------------------------------------------------------------------------------------------------------+
| 7  | "constraint_f076a74d" | "RELATIONSHIP_PROPERTY_EXISTENCE" | "RELATIONSHIP" | ["KNOWS"]     | ["since"]  | <null>     |
+---------------------------------------------------------------------------------------------------------------------------+
1 row
----

======

