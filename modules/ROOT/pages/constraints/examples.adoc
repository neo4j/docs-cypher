:description: Examples of how to manage constraints used for ensuring data integrity.

[[administration-constraints-examples]]
= Examples

[abstract]
--
Examples of how to manage constraints used for ensuring data integrity.
--


[[administration-constraints-unique-nodes]]
== Unique node property constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint-nodes[]
* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint-nodes-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint-nodes-with-specified-index-provider[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-an-already-existing-unique-property-constraint-nodes[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-unique-property-constraint-nodes-on-same-schema-as-existing-index[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-complies-with-unique-property-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-violates-a-unique-property-constraint[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-unique-property-constraint-due-to-conflicting-nodes[]


[discrete]
[[administration-constraints-create-a-unique-constraint-nodes]]
=== Create a node unique constraint

When creating a unique constraint, a name can be provided.
The constraint ensures that your database will never contain more than one node with a specific label and one property value.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in 6.0.
====

======


[discrete]
[[administration-constraints-create-a-unique-constraint-nodes-only-if-it-does-not-already-exist]]
=== Create a node unique constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The uniqueness constraint ensures that your database will never contain more than one node with a specific label and one property value.

[NOTE]
====
No constraint will be created if any other constraint with the given name or another node uniqueness constraint on the same schema already exists.
====


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

Assuming no constraint with the given name or other node uniqueness constraint on the same schema exists:

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in 6.0.
====

======


[discrete]
[[administration-constraints-create-a-unique-constraint-nodes-with-specified-index-provider]]
=== Create a node unique constraint with specified index provider

To create a unique constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

Valid values for the index provider are:

* `range-1.0` label:default[]

// Only one valid value exists for the index provider in Neo4j 5.0


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_options
FOR (n:Label) REQUIRE (n.prop1, n.prop2) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0',
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Unique constraints added: 1
----

[NOTE]
====
The statistics will be updated to say `Node uniqueness constraints` in 6.0.
====

======


[discrete]
[[administration-constraints-failure-to-create-an-already-existing-unique-property-constraint-nodes]]
=== Failure to create an already existing node unique property constraint


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `title` on nodes with the `Book` label, when that constraint already exists.

////
CREATE CONSTRAINT preExistingUnique FOR (book:Book) REQUIRE book.title IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.title IS UNIQUE
----

In this case the constraint can not be created because it already exists.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='UNIQUENESS', schema=(:Book {title}), ownedIndex=3 )
----

[NOTE]
====
The constraint type will be updated to say `NODE_UNIQUENESS` in 6.0.
====

======


[discrete]
[[administration-constraints-failure-to-create-a-unique-property-constraint-nodes-on-same-schema-as-existing-index]]
=== Failure to create a node unique property constraint on same schema as existing index


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `wordCount` on nodes with the `Book` label, when an index already exists on that label and property combination.

////
CREATE INDEX FOR (book:Book) ON (book.wordCount)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.wordCount IS UNIQUE
----

In this case the constraint can not be created because there already exists an index covering that schema.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index (:Book {wordCount}).
A constraint cannot be created until the index has been dropped.
----

======


[discrete]
[[administration-constraints-create-a-node-that-complies-with-unique-property-constraints]]
=== Create a node that complies with unique property constraints


.+CREATE NODE+
======

Create a `Book` node with an `isbn` that is not already in the database.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1
----

======


[discrete]
[[administration-constraints-create-a-node-that-violates-a-unique-property-constraint]]
=== Create a node that violates a unique property constraint


.+CREATE NODE+
======

Create a `Book` node with an `isbn` that is already used in the database.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) already exists with label `Book` and property `isbn` = '1449356265'
----

======


[discrete]
[[administration-constraints-failure-to-create-a-unique-property-constraint-due-to-conflicting-nodes]]
=== Failure to create a unique property constraint due to conflicting nodes


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `isbn` on nodes with the `Book` label when there are two nodes with the same `isbn`.

////
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS UNIQUE
----

In this case the constraint can not be created because it is violated by existing data.
You may choose to use xref::indexes-for-search-performance.adoc[] instead or remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( name='constraint_62365a16', type='UNIQUENESS', schema=(:Book {isbn}) ):
Both Node(0) and Node(1) have the label `Book` and property `isbn` = '1449356265'
----

[NOTE]
====
The constraint type will be updated to say `NODE_UNIQUENESS` in 6.0.
====

======


[[administration-constraints-unique-relationships]]
== Unique relationship property constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint-relationships[]
* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint-relationships-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-create-a-unique-constraint-relationships-with-specified-index-provider[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-an-already-existing-unique-property-constraint-relationships[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-unique-property-constraint-relationships-on-same-schema-as-existing-index[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-that-complies-with-unique-property-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-that-violates-a-unique-property-constraint[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-unique-property-constraint-due-to-conflicting-relationships[]


[discrete]
[[administration-constraints-create-a-unique-constraint-relationships]]
=== Create a relationship unique constraint

When creating a unique constraint, a name can be provided.
The constraint ensures that your database will never contain more than one relationship with a specific relationship type and one property value.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======


[discrete]
[[administration-constraints-create-a-unique-constraint-relationships-only-if-it-does-not-already-exist]]
=== Create a relationship unique constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The uniqueness constraint ensures that your database will never contain more than one relationship with a specific relationship type and one property value.

[NOTE]
====
No constraint will be created if any other constraint with the given name or another relationship uniqueness constraint on the same schema already exists.
====


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

Assuming no constraint with the given name or other relationship uniqueness constraint on the same schema exists:

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======


[discrete]
[[administration-constraints-create-a-unique-constraint-relationships-with-specified-index-provider]]
=== Create a relationship unique constraint with specified index provider

To create a unique constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

Valid values for the index provider are:

* `range-1.0` label:default[]

// Only one valid value exists for the index provider in Neo4j 5.0


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_options
FOR ()-[friend:FRIENDS_WITH]-() REQUIRE (friend.nickname, friend.since) IS UNIQUE
OPTIONS {
  indexProvider: 'range-1.0',
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship uniqueness constraints added: 1
----

======


[discrete]
[[administration-constraints-failure-to-create-an-already-existing-unique-property-constraint-relationships]]
=== Failure to create an already existing relationship unique property constraint


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type, when that constraint already exists.

////
CREATE CONSTRAINT preExistingUnique FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case the constraint can not be created because it already exists.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='RELATIONSHIP_UNIQUENESS', schema=()-[:FRIENDS_WITH {nickname}]-(), ownedIndex=3 )
----

======


[discrete]
[[administration-constraints-failure-to-create-a-unique-property-constraint-relationships-on-same-schema-as-existing-index]]
=== Failure to create a relationship unique property constraint on same schema as existing index


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type, when an index already exists on that relationship type and property combination.

////
CREATE INDEX FOR ()-[friend:FRIENDS_WITH]-() ON (friend.nickname)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case the constraint can not be created because there already exists an index covering that schema.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index ()-[:FRIENDS_WITH {nickname}]-().
A constraint cannot be created until the index has been dropped.
----

======


[discrete]
[[administration-constraints-create-a-relationship-that-complies-with-unique-property-constraints]]
=== Create a relationship that complies with unique property constraints


.+CREATE RELATIONSHIP+
======

Create a `FRIENDS_WITH` relationship with an `nickname` that is not already in the database.

////
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE (:Person {name: 'Josefin'})-[:FRIENDS_WITH {nickname: 'Mimi'}]->(:Person {name: 'Emilia'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 2
Relationships created: 1
Properties set: 3
Labels added: 2
----

======


[discrete]
[[administration-constraints-create-a-relationship-that-violates-a-unique-property-constraint]]
=== Create a relationship that violates a unique property constraint


.+CREATE RELATIONSHIP+
======

Create a `FRIENDS_WITH` relationship with an `nickname` that is already used in the database.

////
CREATE CONSTRAINT FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
CREATE (:Person {name: 'Emma'}), (:Person {name: 'Josefin'})-[:FRIENDS_WITH {nickname: 'Mimi'}]->(:Person {name: 'Emilia'})
////

.Query
[source, cypher, indent=0]
----
MATCH (emma:Person {name: 'Emma'}), (emilia:Person {name: 'Emilia'})
CREATE (emma)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia)
----

In this case the relationship is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) already exists with type `FRIENDS_WITH` and property `nickname` = 'Mimi'
----

======


[discrete]
[[administration-constraints-failure-to-create-a-unique-property-constraint-due-to-conflicting-relationships]]
=== Failure to create a unique property constraint due to conflicting relationships


.+CREATE CONSTRAINT+
======

Create a unique property constraint on the property `nickname` on relationships with the `FRIENDS_WITH` relationship type when there are two relationships with the same `nickname`.

////
CREATE (emma:Person {name: 'Emma'}), (josefin:Person {name: 'Josefin'}), (emilia:Person {name: 'Emilia'})
CREATE (josefin)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia), (emma)-[:FRIENDS_WITH {nickname: 'Mimi'}]->(emilia)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT friends FOR ()-[friend:FRIENDS_WITH]-() REQUIRE friend.nickname IS UNIQUE
----

In this case the constraint can not be created because it is violated by existing data.
You may choose to use xref::indexes-for-search-performance.adoc[] instead or remove the offending relationships and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( name='friends', type='RELATIONSHIP_UNIQUENESS', schema=()-[:FRIENDS_WITH {nickname}]-() ):
Both Relationship(0) and Relationship(1) have the type `FRIENDS_WITH` and property `nickname` = 'Mimi'
----

======


[role=enterprise-edition]
[[administration-constraints-prop-exist-nodes]]
== Node property existence constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-node-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-property-existence-constraint-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-an-already-existing-node-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-complies-with-property-existence-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-violates-a-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-removing-an-existence-constrained-node-property[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-node-property-existence-constraint-due-to-existing-node[]
//* xref::constraints/examples.adoc#


[discrete]
[[administration-constraints-create-a-node-property-existence-constraint]]
=== Create a node property existence constraint

When creating a node property existence constraint, a name can be provided.
The constraint ensures that all nodes with a certain label have a certain property.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints added: 1
----

[NOTE]
====
The statistics for property existence constraints wil be split between nodes and relationships in 6.0.
For the node property existence constraints they will say `Node property existence constraints`.
====

======

[discrete]
[[administration-constraints-create-a-node-property-existence-constraint-only-if-it-does-not-already-exist]]
=== Create a node property existence constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The node property existence constraint ensures that all nodes with a certain label have a certain property.
No constraint will be created if any other constraint with the given name or another node property existence constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
CREATE CONSTRAINT constraint_name FOR (book:Book) REQUIRE book.isbn IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

Assuming a constraint with the name `constraint_name` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-constraints-failure-to-create-an-already-existing-node-property-existence-constraint]]
=== Failure to create an already existing node property existence constraint


.+CREATE CONSTRAINT+
======

Create a node property existence constraint on the property `title` on nodes with the `Book` label, when that constraint already exists.

////
CREATE CONSTRAINT preExistingNodePropExist FOR (book:Book) REQUIRE book.title IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT booksShouldHaveTitles
FOR (book:Book) REQUIRE book.title IS NOT NULL
----

In this case the constraint can not be created because it already exists.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=3, name='preExistingNodePropExist', type='NODE PROPERTY EXISTENCE', schema=(:Book {title}) )
----

======


[discrete]
[[administration-constraints-create-a-node-that-complies-with-property-existence-constraints]]
=== Create a node that complies with property existence constraints


.+CREATE NODE+
======

Create a `Book` node with an `isbn` property.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 2
Labels added: 1
----

======


[discrete]
[[administration-constraints-create-a-node-that-violates-a-property-existence-constraint]]
=== Create a node that violates a property existence constraint


.+CREATE NODE+
======

Trying to create a `Book` node without an `isbn` property, given a property existence constraint on `:Book(isbn)`.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (book:Book {title: 'Graph Databases'})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Book` must have the property `isbn`
----

======


[discrete]
[[administration-constraints-removing-an-existence-constrained-node-property]]
=== Removing an existence constrained node property


.+REMOVE PROPERTY+
======

Trying to remove the `isbn` property from an existing node `book`, given a property existence constraint on `:Book(isbn)`.

////
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
CREATE (book:Book {isbn: '1449356265', title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
MATCH (book:Book {title: 'Graph Databases'})
REMOVE book.isbn
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Book` must have the property `isbn`
----

======


[discrete]
[[administration-constraints-failure-to-create-a-node-property-existence-constraint-due-to-existing-node]]
=== Failure to create a node property existence constraint due to existing node


.+CREATE CONSTRAINT+
======

Create a constraint on the property `isbn` on nodes with the `Book` label when there already exists  a node without an `isbn`.

////
CREATE (book:Book {title: 'Graph Databases'})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.isbn IS NOT NULL
----

In this case the constraint can't be created because it is violated by existing data. We may choose to remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='NODE PROPERTY EXISTENCE', schema=(:Book {isbn}) ):
Node(0) with label `Book` must have the property `isbn`
----

======


[role=enterprise-edition]
[[administration-constraints-prop-exist-rels]]
== Relationship property existence constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-property-existence-constraint-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-an-already-existing-relationship-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-that-complies-with-property-existence-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-that-violates-a-property-existence-constraint[]
* xref::constraints/examples.adoc#administration-constraints-removing-an-existence-constrained-relationship-property[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-relationship-property-existence-constraint-due-to-existing-relationship[]


[discrete]
[[administration-constraints-create-a-relationship-property-existence-constraint]]
=== Create a relationship property existence constraint

When creating a relationship property existence constraint, a name can be provided.
The constraint ensures all relationships with a certain type have a certain property.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Property existence constraints added: 1
----

[NOTE]
====
The statistics for property existence constraints wil be split between nodes and relationships in 6.0.
For the relationship property existence constraints they will say `Relationship property existence constraints`.
====

======


[discrete]
[[administration-constraints-create-a-relationship-property-existence-constraint-only-if-it-does-not-already-exist]]
=== Create a relationship property existence constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The relationship property existence constraint ensures all relationships with a certain type have a certain property.
No constraint will be created if any other constraint with the given name or another relationship property existence constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
CREATE CONSTRAINT constraint_name FOR (book:Book) REQUIRE book.isbn IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
IF NOT EXISTS FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

Assuming a constraint with the name `constraint_name` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-constraints-failure-to-create-an-already-existing-relationship-property-existence-constraint]]
=== Failure to create an already existing relationship property existence constraint


.+CREATE CONSTRAINT+
======

Create a named relationship property existence constraint on the property `week` on relationships with the `LIKED` type, when a constraint with the given name already exists.

////
CREATE CONSTRAINT relPropExist FOR ()-[like:LIKED]-() REQUIRE like.since IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT relPropExist
FOR ()-[like:LIKED]-() REQUIRE like.week IS NOT NULL
----

In this case the constraint can not be created because there already exists a constraint with the given name.

.Error message
[source, "error message", role="noheader"]
----
There already exists a constraint called 'relPropExist'.
----

======


[discrete]
[[administration-constraints-create-a-relationship-that-complies-with-property-existence-constraints]]
=== Create a relationship that complies with property existence constraints


.+CREATE RELATIONSHIP+
======

Create a `LIKED` relationship with a `day` property.

////
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (user:User)-[like:LIKED {day: 'yesterday'}]->(book:Book)
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 2
Relationships created: 1
Properties set: 1
Labels added: 2
----

======


[discrete]
[[administration-constraints-create-a-relationship-that-violates-a-property-existence-constraint]]
=== Create a relationship that violates a property existence constraint


.+CREATE RELATIONSHIP+
======

Trying to create a `LIKED` relationship without a `day` property, given a property existence constraint `:LIKED(day)`.

////
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
CREATE (user:User)-[like:LIKED]->(book:Book)
----

In this case the relationship is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `LIKED` must have the property `day`
----

======


[discrete]
[[administration-constraints-removing-an-existence-constrained-relationship-property]]
=== Removing an existence constrained relationship property


.+REMOVE PROPERTY+
======

Trying to remove the `day` property from an existing relationship `like` of type `LIKED`, given a property existence constraint `:LIKED(day)`.

////
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
CREATE (user:User)-[like:LIKED {day: 'yesterday'}]->(book:Book)
////

.Query
[source, cypher, indent=0]
----
MATCH (user:User)-[like:LIKED]->(book:Book) REMOVE like.day
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `LIKED` must have the property `day`
----

======


[discrete]
[[administration-constraints-failure-to-create-a-relationship-property-existence-constraint-due-to-existing-relationship]]
=== Failure to create a relationship property existence constraint due to existing relationship


.+CREATE CONSTRAINT+
======

Create a constraint on the property `day` on relationships with the `LIKED` type when there already exists a relationship without a property named `day`.

////
CREATE (user:User)-[like:LIKED]->(book:Book)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[like:LIKED]-() REQUIRE like.day IS NOT NULL
----

In this case the constraint can not be created because it is violated by existing data. We may choose to remove the offending relationships and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='RELATIONSHIP PROPERTY EXISTENCE', schema=-[:LIKED {day}]- ):
Relationship(0) with type `LIKED` must have the property `day`
----

======


[role=enterprise-edition]
[[administration-constraints-node-key]]
== Node key constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-node-key-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-key-constraint-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-key-constraint-with-specified-index-provider[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-node-key-constraint-when-a-unique-property-constraint-exists-on-the-same-schema[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-node-key-constraint-with-the-same-name-as-existing-index[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-complies-with-node-key-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-node-that-violates-a-node-key-constraint[]
* xref::constraints/examples.adoc#administration-constraints-removing-a-node-key-constrained-property[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-node-key-constraint-due-to-existing-node[]


[discrete]
[[administration-constraints-create-a-node-key-constraint]]
=== Create a node key constraint

When creating a node key constraint, a name can be provided.
The constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique and all properties in the set are present.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----

======


[discrete]
[[administration-constraints-create-a-node-key-constraint-only-if-it-does-not-already-exist]]
=== Create a node key constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The node key constraint ensures that all nodes with a particular label have a set of defined properties whose combined value is unique and all properties in the set are present.
No constraint will be created if any other constraint with the given name or another node key constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

Assuming a node key constraint on `(:Person {firstname, surname})` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-constraints-create-a-node-key-constraint-with-specified-index-provider]]
=== Create a node key constraint with specified index provider

To create a node key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

Valid values for the index provider are:

* `range-1.0` label:default[]


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_provider
FOR (n:Label) REQUIRE (n.prop1) IS NODE KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Node key constraints added: 1
----

======


[discrete]
[[administration-constraints-failure-to-create-a-node-key-constraint-when-a-unique-property-constraint-exists-on-the-same-schema]]
=== Failure to create a node key constraint when a unique property constraint exists on the same schema


.+CREATE CONSTRAINT+
======

Create a node key constraint on the properties `firstname` and `age` on nodes with the `Person` label, when a unique property constraint already exists on the same label and property combination.

////
CREATE CONSTRAINT preExistingUnique FOR (p:Person) REQUIRE (p.firstname, p.age) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (p:Person) REQUIRE (p.firstname, p.age) IS NODE KEY
----

In this case the constraint can not be created because there already exist a conflicting constraint on that label and property combination.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='UNIQUENESS', schema=(:Person {firstname, age}), ownedIndex=3 )
----

======


[discrete]
[[administration-constraints-failure-to-create-a-node-key-constraint-with-the-same-name-as-existing-index]]
=== Failure to create a node key constraint with the same name as existing index


.+CREATE CONSTRAINT+
======

Create a named node key constraint on the property `title` on nodes with the `Book` label, when an index already exists with the given name.

////
CREATE INDEX bookTitle FOR (book:ComicBook) ON (book.title)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT bookTitle
FOR (book:Book) REQUIRE book.title IS NODE KEY
----

In this case the constraint can't be created because there already exists an index with the given name.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index called 'bookTitle'.
----

======


[discrete]
[[administration-constraints-create-a-node-that-complies-with-node-key-constraints]]
=== Create a node that complies with node key constraints


.+CREATE NODE+
======

Create a `Person` node with both a `firstname` and `surname` property.

////
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE (p:Person {firstname: 'John', surname: 'Wood', age: 55})
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Nodes created: 1
Properties set: 3
Labels added: 1
----

======


[discrete]
[[administration-constraints-create-a-node-that-violates-a-node-key-constraint]]
=== Create a node that violates a node key constraint


.+CREATE NODE+
======

Trying to create a `Person` node without a `surname` property, given a node key constraint on `:Person(firstname, surname)`, will fail.

////
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
////

.Query
[source, cypher, indent=0]
----
CREATE (p:Person {firstname: 'Jane', age: 34})
----

In this case the node is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Person` must have the properties (`firstname`, `surname`)
----

======


[discrete]
[[administration-constraints-removing-a-node-key-constrained-property]]
=== Removing a +NODE KEY+-constrained property


.+REMOVE PROPERTY+
======

Trying to remove the `surname` property from an existing node `Person`, given a `NODE KEY` constraint on `:Person(firstname, surname)`.

////
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
CREATE (p:Person {firstname: 'John', surname: 'Wood', age: 55})
////

.Query
[source, cypher, indent=0]
----
MATCH (p:Person {firstname: 'John', surname: 'Wood'}) REMOVE p.surname
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Node(0) with label `Person` must have the properties (`firstname`, `surname`)
----

======


[discrete]
[[administration-constraints-failure-to-create-a-node-key-constraint-due-to-existing-node]]
=== Failure to create a node key constraint due to existing node


.+CREATE CONSTRAINT+
======

Trying to create a node key constraint on the property `surname` on nodes with the `Person` label will fail when a node without a `surname` already exists in the database.

////
CREATE (p:Person {firstname: 'John', age: 55})
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR (n:Person) REQUIRE (n.firstname, n.surname) IS NODE KEY
----

In this case the node key constraint can not be created because it is violated by existing data.
We may choose to remove the offending nodes and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( type='NODE KEY', schema=(:Person {firstname, surname}) ):
Node(0) with label `Person` must have the properties (`firstname`, `surname`)
----

======


[role=enterprise-edition]
[[administration-constraints-rel-key]]
== Relationship key constraints

* xref::constraints/examples.adoc#administration-constraints-create-a-rel-key-constraint[]
* xref::constraints/examples.adoc#administration-constraints-create-a-rel-key-constraint-only-if-it-does-not-already-exist[]
* xref::constraints/examples.adoc#administration-constraints-create-a-rel-key-constraint-with-specified-index-provider[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-rel-key-constraint-when-a-unique-property-constraint-exists-on-the-same-schema[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-rel-key-constraint-with-the-same-name-as-existing-index[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-that-complies-with-rel-key-constraints[]
* xref::constraints/examples.adoc#administration-constraints-create-a-relationship-that-violates-a-rel-key-constraint[]
* xref::constraints/examples.adoc#administration-constraints-removing-a-rel-key-constrained-property[]
* xref::constraints/examples.adoc#administration-constraints-failure-to-create-a-rel-key-constraint-due-to-existing-relationship[]


[discrete]
[[administration-constraints-create-a-rel-key-constraint]]
=== Create a relationship key constraint

When creating a relationship key constraint, a name can be provided.
The constraint ensures that all relationships with a particular relationship type have a set of defined properties whose combined value is unique and all properties in the set are present.


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship key constraints added: 1
----

======


[discrete]
[[administration-constraints-create-a-rel-key-constraint-only-if-it-does-not-already-exist]]
=== Create a relationship key constraint only if it does not already exist

If it is not known whether a constraint exists or not, add `IF NOT EXISTS` to ensure it does.
The relationship key constraint ensures that all relationships with a particular relationship type have a set of defined properties whose combined value is unique and all properties in the set are present.
No constraint will be created if any other constraint with the given name or another relationship key constraint on the same schema already exists.


.+CREATE CONSTRAINT+
======

////
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_name IF NOT EXISTS
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS RELATIONSHIP KEY
----

Assuming a relationship key constraint on `()-[:ROAD {startPoint, endPoint}]-()` already existed:

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[discrete]
[[administration-constraints-create-a-rel-key-constraint-with-specified-index-provider]]
=== Create a relationship key constraint with specified index provider

To create a relationship key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

Valid values for the index provider are:

* `range-1.0` label:default[]


.+CREATE CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT constraint_with_provider
FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationship key constraints added: 1
----

======


[discrete]
[[administration-constraints-failure-to-create-a-rel-key-constraint-when-a-unique-property-constraint-exists-on-the-same-schema]]
=== Failure to create a relationship key constraint when a unique property constraint exists on the same schema


.+CREATE CONSTRAINT+
======

Create a relationship key constraint on the properties `startPoint` and `endPoint` on relationships with the `ROAD` relationship type, when a unique property constraint already exists on the same relationship type and property combination.

////
CREATE CONSTRAINT preExistingUnique FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
----

In this case the constraint can not be created because there already exist a conflicting constraint on that relationship type and property combination.

.Error message
[source, "error message", role="noheader"]
----
Constraint already exists:
Constraint( id=4, name='preExistingUnique', type='RELATIONSHIP_UNIQUENESS', schema=()-[:ROAD {startPoint, endPoint}]-(), ownedIndex=3 )
----

======


[discrete]
[[administration-constraints-failure-to-create-a-rel-key-constraint-with-the-same-name-as-existing-index]]
=== Failure to create a relationship key constraint with the same name as existing index


.+CREATE CONSTRAINT+
======

Create a named relationship key constraint on the property `coordinates` on relationships with the `INTERSECTION` relationship type, when an index already exists with the given name.

////
CREATE INDEX intersections FOR ()-[intersect:Roundabout]-() ON (intersect.coordinates)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT intersections
FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
----

In this case the constraint can't be created because there already exists an index with the given name.

.Error message
[source, "error message", role="noheader"]
----
There already exists an index called 'intersections'.
----

======


[discrete]
[[administration-constraints-create-a-relationship-that-complies-with-rel-key-constraints]]
=== Create a relationship that complies with relationship key constraints


.+CREATE RELATIONSHIP+
======

Create a `ROAD` relationship with both a `startPoint` and `endPoint` property.

////
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
CREATE (:Intersection {name: 'a', coordinates: point({x: 1, y:2})}), (:Intersection {name: 'b', coordinates: point({x: 2, y:5})})
////

.Query
[source, cypher, indent=0]
----
MATCH (a:Intersection {name: 'a'}), (b:Intersection {name: 'b'})
CREATE (a)-[:ROAD {startPoint: a.coordinates, endPoint: b.coordinates}]->(b)
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Relationships created: 1
Properties set: 2
----

======


[discrete]
[[administration-constraints-create-a-relationship-that-violates-a-rel-key-constraint]]
=== Create a relationship that violates a relationship key constraint


.+CREATE RELATIONSHIP+
======

Trying to create a `INTERSECTION` relationship without a `coordinates` property, given a relationship key constraint on `:INTERSECTION(coordinates)`, will fail.

////
CREATE CONSTRAINT FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
CREATE (:Road {name: 'a'}), (:Road {name: 'b'})
////

.Query
[source, cypher, indent=0]
----
MATCH (a:Road {name: 'a'}), (b:Road {name: 'b'})
CREATE (a)-[:INTERSECTION]->(b)
----

In this case the relationship is not created in the graph.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `INTERSECTION` must have the property `coordinates`
----

======


[discrete]
[[administration-constraints-removing-a-rel-key-constrained-property]]
=== Removing a +RELATIONSHIP KEY+-constrained property


.+REMOVE PROPERTY+
======

Trying to remove the `endPoint` property from an existing relationship `ROAD`, given a `RELATIONSHIP KEY` constraint on `:ROAD(startPoint, endPoint)`.

////
CREATE CONSTRAINT FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS REL KEY
CREATE (a:Intersection {name: 'a', coordinates: point({x: 1, y:2})}), (b:Intersection {name: 'b', coordinates: point({x: 2, y:5})})
CREATE (a)-[:ROAD {startPoint: a.coordinates, endPoint: b.coordinates}]->(b)
////

.Query
[source, cypher, indent=0]
----
MATCH ()-[r:ROAD {startPoint: point({x: 1, y:2}), endPoint: point({x: 2, y:5})}]->() REMOVE r.endPoint
----

In this case the property is not removed.

.Error message
[source, "error message", role="noheader"]
----
Relationship(0) with type `ROAD` must have the properties (`startPoint`, `endPoint`)
----

======


[discrete]
[[administration-constraints-failure-to-create-a-rel-key-constraint-due-to-existing-relationship]]
=== Failure to create a relationship key constraint due to existing relationship


.+CREATE CONSTRAINT+
======

Trying to create a relationship key constraint on the property `coordinates` on relationships with the `INTERSECTION` relationship type will fail when two relationships with identical `coordinates` already exists in the database.

////
CREATE (a:Road {name: 'a'}), (b:Road {name: 'b'})
CREATE (a)-[:INTERSECTION {coordinates: point({x:1, y:2})}]->(b)
CREATE (a)<-[:INTERSECTION {coordinates: point({x:1, y:2})}]-(b)
////

.Query
[source, cypher, indent=0]
----
CREATE CONSTRAINT intersectionConstriant FOR ()-[r:INTERSECTION]-() REQUIRE (r.coordinates) IS REL KEY
----

In this case the relationship key constraint can not be created because it is violated by existing data.
We may choose to remove the offending relationships and then re-apply the constraint.

.Error message
[source, "error message", role="noheader"]
----
Unable to create Constraint( name='intersectionConstriant', type='RELATIONSHIP KEY', schema=()-[:INTERSECTION {coordinates}]-() ):
Both Relationship(0) and Relationship(1) have the type `INTERSECTION` and property `coordinates` = {geometry: {type: "Point", coordinates: [1.0, 2.0], crs: {type: link, properties: {href: "http://spatialreference.org/ref/sr-org/7203/", code: 7203}}}}
----

======


[[administration-constraints-drop-constraint]]
== Drop a constraint by name

* xref::constraints/examples.adoc#administration-constraints-drop-a-constraint[]
* xref::constraints/examples.adoc#administration-constraints-drop-a-non-existing-constraint[]


[discrete]
[[administration-constraints-drop-a-constraint]]
=== Drop a constraint

A constraint can be dropped using the name with the `DROP CONSTRAINT constraint_name` command.
It is the same command for unique property, property existence and node/relationship key constraints.
The name of the constraint can be found using the xref::constraints/syntax.adoc#administration-constraints-syntax-list[`SHOW CONSTRAINTS` command], given in the output column `name`.


.+DROP CONSTRAINT+
======

////
CREATE CONSTRAINT constraint_name FOR (n:Person) REQUIRE (n.name) IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
DROP CONSTRAINT constraint_name
----

.Result
[queryresult]
----
+-------------------+
| No data returned. |
+-------------------+
Named constraints removed: 1
----

======


[discrete]
[[administration-constraints-drop-a-non-existing-constraint]]
=== Drop a non-existing constraint

If it is uncertain if any constraint with a given name exists and you want to drop it if it does but not get an error should it not, use `IF EXISTS`.
It is the same command for unique property, property existence and node/relationship key constraints.

.+DROP CONSTRAINT+
======

.Query
[source, cypher, indent=0]
----
DROP CONSTRAINT missing_constraint_name IF EXISTS
----

.Result
[queryresult]
----
+--------------------------------------------+
| No data returned, and nothing was changed. |
+--------------------------------------------+
----

======


[[administration-constraints-list-constraint]]
== Listing constraints

* xref::constraints/examples.adoc#administration-constraints-listing-all-constraints[]
* xref::constraints/examples.adoc#administration-constraints-listing-constraints-with-filtering[]


[discrete]
[[administration-constraints-listing-all-constraints]]
=== Listing all constraints

To list all constraints with the default output columns, the `SHOW CONSTRAINTS` command can be used.
If all columns are required, use `SHOW CONSTRAINTS YIELD *`.

[NOTE]
====
One of the output columns from `SHOW CONSTRAINTS` is the name of the constraint.
This can be used to drop the constraint with the xref::constraints/syntax.adoc#administration-constraints-syntax-drop[`DROP CONSTRAINT` command].
====


.+SHOW CONSTRAINTS+
======

////
CREATE CONSTRAINT isbnConstraint FOR (n:Book) REQUIRE (n.isbn) IS UNIQUE
CREATE CONSTRAINT roadConstraint FOR ()-[r:ROAD]-() REQUIRE (r.startPoint, r.endPoint) IS UNIQUE
////

.Query
[source, cypher, indent=0]
----
SHOW CONSTRAINTS
----

[queryresult]
----
+------------------------------------------------------------------------------------------------------------------------------------+
| id | name             | type                      | entityType     | labelsOrTypes | properties                 | ownedIndex       |
+------------------------------------------------------------------------------------------------------------------------------------+
| 4  | "isbnConstraint" | "UNIQUENESS"              | "NODE"         | ["Book"]      | ["isbn"]                   | "isbnConstraint" |
| 6  | "roadConstraint" | "RELATIONSHIP_UNIQUENESS" | "RELATIONSHIP" | ["ROAD"]      | ["startPoint", "endPoint"] | "roadConstraint" |
+------------------------------------------------------------------------------------------------------------------------------------+
2 rows
----

[NOTE]
====
The `type` column returns `UNIQUENESS` for the node unique property constraint and `RELATIONSHIP_UNIQUENESS` for the relationship unique property constraint.
The `type` for node unique property constraint will be updated to `NODE_UNIQUENESS` in 6.0.
====

======


[discrete]
[[administration-constraints-listing-constraints-with-filtering]]
=== Listing constraints with filtering

One way of filtering the output from `SHOW CONSTRAINTS` by constraint type is the use of type keywords,
listed in the xref::constraints/syntax.adoc#administration-constraints-syntax-list-type-filter[syntax for listing constraints type filter table].
For example, to show only unique property constraints, use `SHOW UNIQUENESS CONSTRAINTS`.
Another more flexible way of filtering the output is to use the `WHERE` clause.
An example is to only show constraints on relationships.


.+SHOW CONSTRAINTS+
======

////
CREATE CONSTRAINT FOR (n:Book) REQUIRE (n.isbn) IS UNIQUE
CREATE CONSTRAINT FOR (book:Book) REQUIRE book.title IS NOT NULL
CREATE CONSTRAINT `constraint_f076a74d` FOR ()-[r:KNOWS]-() REQUIRE r.since IS NOT NULL
////

.Query
[source, cypher, indent=0]
----
SHOW EXISTENCE CONSTRAINTS
WHERE entityType = 'RELATIONSHIP'
----

This will only return the default output columns.
To get all columns, use `+SHOW INDEXES YIELD * WHERE ...+`.

[queryresult]
----
+---------------------------------------------------------------------------------------------------------------------------+
| id | name                  | type                              | entityType     | labelsOrTypes | properties | ownedIndex |
+---------------------------------------------------------------------------------------------------------------------------+
| 7  | "constraint_f076a74d" | "RELATIONSHIP_PROPERTY_EXISTENCE" | "RELATIONSHIP" | ["KNOWS"]     | ["since"]  | <null>     |
+---------------------------------------------------------------------------------------------------------------------------+
1 row
----

======

