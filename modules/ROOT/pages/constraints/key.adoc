:description: Information about Neo4j's key constraints.
include::https://raw.githubusercontent.com/neo4j-graphacademy/courses/main/asciidoc/courses/cypher-indexes-constraints/ad.adoc[]
:page-role: enterprise-edition
= Key constraints

Key constraints ensure that, for a given node label or relationship type, all specified properties exist on all relevant nodes or relationships, and the combination of their values is unique.

[[create-key-constraints]]
== Create key constraints

Key constraints are created with the `CREATE CONSTRAINT` command.
When creating a key constraint, it is recommended to provide a constraint name.

[NOTE]
Creating a constraint requires the link:{neo4j-docs-base-uri}/operations-manual/{page-version}/authentication-authorization/database-administration/#access-control-database-administration-constraints[`CREATE CONSTRAINT` privilege].

.Create node key property constraint
======

A node key constraint ensures that certain nodes have a set of specified properties whose combined value is unique and all properties in the set are present.

.Query
[source, cypher]
----
CREATE CONSTRAINT actor_fullname
FOR (actor:Actor) REQUIRE (actor.firstname, actor.surname) IS NODE KEY
----

.Result
[queryresult]
----
Added 1 constraint.
----

======

.Create relationship property key constraint label:new[Introduced in 5.7]
======

A relationship key constraint ensures that certain relationships have a set of defined properties whose combined value is unique.
It also ensures that all properties in the set are present.

.Query
[source, cypher]
----
CREATE CONSTRAINT knows_since_how
FOR ()-[knows:KNOWS]-() REQUIRE (knows.since, knows.how) IS RELATIONSHIP KEY
----

.Result
[queryresult]
----
Added 1 constraint.
----

======

[[create-key-constraints-with-parameters]]
[role=label--new-5.16]
=== Create key constraints using parameters

The constraint name can also be given as a parameter.

.Create a node key property constraint using a parameter
======

.Parameters
[source, parameters]
----
{
  "name": "node_key_param"
}
----

.Query
[source, cypher]
----
CREATE CONSTRAINT $name
FOR (actor:Actor) REQUIRE actor.firstname IS KEY
----

.Result
[queryresult]
----
Added 1 constraint.
----

======


.Create a relationship property key constraint using a parameter
======

.Parameters
[source, parameters]
----
{
  "name": "rel_key_param"
}
----

.Query
[source, cypher]
----
CREATE CONSTRAINT $name
FOR ()-[knows:KNOWS]-() REQUIRE knows.friend IS KEY
----

.Result
[queryresult]
----
Added 1 constraint.
----

======


[[create-a-key-constraint-if-not-exist]]
=== Handling existing key constraints when creating a constraint

Creating an already existing constraint will fail.
To avoid such an error, `IF NOT EXISTS` can be added to the `CREATE` command.
This will ensure that no error is thrown and that no constraint is created if any other constraint with the given name, or another node key constraint on the same schema, already exists.
As of Neo4j 5.17, an informational notification is instead returned showing the existing constraint which blocks the creation.

.Create a node property key constraint when a constraint with the same name exists
======

.Query
[source, cypher]
----
CREATE CONSTRAINT actor_names IF NOT EXISTS
FOR (actor:Actor) REQUIRE (actor.firstname, actor.surname) IS NODE KEY
----

Assuming a node key constraint on `(:Actor {firstname, surname})` already exists:

.Result
[queryresult]
----
(no changes, no records)
----

.Notification
[source]
----
`CREATE CONSTRAINT actor_names IF NOT EXISTS FOR (e:Actor) REQUIRE (e.firstname, e.surname) IS NODE KEY` has no effect.
`CONSTRAINT actor_fullname FOR (e:Actor) REQUIRE (e.firstname, e.surname) IS NODE KEY` already exists.
----

======

.Create a relationship property key constraint when a constraint with the same name exists
======

.Query
[source, cypher]
----
CREATE CONSTRAINT knows IF NOT EXISTS
FOR ()-[knows:KNOWS]-() REQUIRE (knows.since, knows.how) IS RELATIONSHIP KEY
----

Assuming a relationship key constraint on `()-[:KNOWS {since, how}]-()` already exists:

.Result
[queryresult]
----
(no changes, no records)
----

.Notification
[source]
----
`CREATE CONSTRAINT knows IF NOT EXISTS FOR ()-[e:KNOWS]-() REQUIRE (e.since, e.how) IS RELATIONSHIP KEY` has no effect.
`CONSTRAINT knows_since_how FOR ()-[e:KNOWS]-() REQUIRE (e.since, e.how) IS RELATIONSHIP KEY` already exists.
----

======

[[create-key-constraint-with-index-provider]]
=== Specify an index provider when creating a constraint

To create a key constraint with a specific index provider for the backing index, the `OPTIONS` clause is used.

The index type of the backing index is set with the `indexProvider` option.

The only valid value for the index provider is:

* `range-1.0` label:default[]


.Create a node property key constraint with a specified index provider
======

.Query
[source, cypher]
----
CREATE CONSTRAINT constraint_with_provider
FOR (actor:Actor) REQUIRE (actor.surname) IS NODE KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
Added 1 constraint.
----

======


.Create a relationship property key constraint with a specified index provider
======

.Query
[source, cypher]
----
CREATE CONSTRAINT rel_constraint_with_provider
FOR ()-[knows:KNOWS]-() REQUIRE (knows.since) IS REL KEY
OPTIONS {
  indexProvider: 'range-1.0'
}
----

.Result
[queryresult]
----
Added 1 constraint.
----

======

There is no valid index configuration values for the constraint-backing range indexes.

[[create-data-that-complies-with-key-constraint]]
=== Create data that complies with existing key constraints

.Creating a node that complies with an existing node key constraint
======

Create an `Actor` node with `firstname` and `surname` properties:

.Query
[source, cypher]
----
CREATE (actor:Actor {firstname: 'Keanu', surname: 'Reeves'})
----

.Result
[queryresult]
----
Added 1 label, created 1 node, set 2 properties.
----

======


.Creating a relationship that complies with an existing relationship key constraint
======

Create a `KNOWS` relationship with both `since` and `how` properties and a relationship key constraint on `:KNOWS(since, how)`:

.Query
[source, cypher]
----
CREATE (:Actor {firstname: 'Jensen', surname: 'Ackles'})-[:KNOWS {since: 2008, how: 'coworkers', friend: true}]->(:Actor {firstname: 'Misha', surname: 'Collins'})
----

.Result
[queryresult]
----
Added 2 labels, created 2 nodes, set 6 properties, created 1 relationship.
----

======


[[key-constraints-fail-cases]]
== Fail cases

* xref:constraints/key.adoc#key-and-uniqueness-constraint-on-the-same-schema[]
* xref:constraints/key.adoc#create-key-constraint-with-the-same-name-as-existing-index[]
* xref:constraints/key.adoc#create-data-that-violates-a-node-key-constraint[]
* xref:constraints/key.adoc#removing-a-key-constrained-property[]
* xref:constraints/key.adoc#fail-to-create-a-key-constraint-due-to-existing-data[]

[discrete]
[[key-and-uniqueness-constraint-on-the-same-schema]]
=== Key and property uniqueness constraints are not allowed on the same schema

.Creating a node key property constraint on the same schema as existing uniqueness constraint
======

Create a node key constraint on the properties `firstname` and `age` on nodes with the `Actor` label, when a property uniqueness constraint already exists on the same label and property combination:

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT preExisting_actor_name_age FOR (actor:Actor) REQUIRE (actor.firstname, actor.age) IS UNIQUE
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT actor_name_age FOR (actor:Actor) REQUIRE (actor.firstname, actor.age) IS NODE KEY
----

In this case, the constraint cannot be created because there already exist a conflicting constraint on that label and property combination.

.Error message
[source, error]
----
Constraint already exists:
Constraint( id=10, name='preExisting_actor_name_age', type='UNIQUENESS', schema=(:Actor {firstname, age}), ownedIndex=9 )
----

======

.Creating a relationship key property constraint on the same schema as existing uniqueness constraint
======

Create a relationship key constraint on the property `how` on relationships with the `KNOWS` relationship type, when a property uniqueness constraint already exists on the same relationship type and property combination:

////
[source, cypher, role=test-setup]
----
CREATE CONSTRAINT preExisting_how FOR ()-[knows:KNOWS]-() REQUIRE (knows.how) IS UNIQUE
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT knows_how FOR ()-[knows:KNOWS]-() REQUIRE (knows.how) IS REL KEY
----

In this case, the constraint cannot be created because there already exists a conflicting constraint on that relationship type and property combination.

.Error message
[source, error]
----
Constraint already exists:
Constraint( id=34, name='preExisting_how', type='RELATIONSHIP UNIQUENESS', schema=()-[:KNOWS {how}]-(), ownedIndex=33 )
----

[NOTE]
====
The constraint type for relationship property uniqueness constraints will be updated to say `RELATIONSHIP PROPERTY UNIQUENESS` in Neo4j 6.0.
====

======

[discrete]
[[create-key-constraint-with-the-same-name-as-existing-index]]
=== Creating a constraint on same name as an existing index will fail

.Creating a node property key constraint on the same name as an existing index
======

Create a named node key constraint on the property `citizenship` on nodes with the `Actor` label, when an index already exists with the given name:

////
[source, cypher, role=test-setup]
----
CREATE INDEX citizenship FOR (person:Person) ON (person.citizenship)
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT citizenship
FOR (actor:Actor) REQUIRE actor.citizenship IS NODE KEY
----

In this case, the constraint cannot be created because there already exists an index with the given name.

.Error message
[source, error]
----
There already exists an index called 'citizenship'.
----

======


.Creating a relationship property key constraint on the same name as an existing index
======

Create a named relationship key constraint on the property `level` on relationships with the `KNOWS` relationship type, when an index already exists with the given name:

////
[source, cypher, role=test-setup]
----
CREATE INDEX knows FOR ()-[know:KNOW]-() ON (know.levels)
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT knows
FOR ()-[knows:KNOWS]-() REQUIRE (knows.level) IS REL KEY
----

In this case, the constraint cannot be created because there already exists an index with the given name.

.Error message
[source, error]
----
There already exists an index called 'knows'.
----

======

[discrete]
[[create-data-that-violates-a-node-key-constraint]]
=== Creating data that violates existing constraints will fail

.Create a node that violates existing node key constraint
======

Create an `Actor` node without a `firstname` property, given a node key constraint on `:Actor(firstname, surname)`:


.Query
[source, cypher, role=test-fail]
----
CREATE (actor:Actor {surname: 'Wood'})
----

In this case, the node is not created because it is missing the `firstname` property which is in conflict with an existing constraint.

.Error message
[source, error]
----
Node(0) with label `Actor` must have the properties (`firstname`, `surname`)
----

======

.Create a relationship that violates existing relationship key constraint
======

Create a `KNOWS` relationship without a `since` property, given a relationship key constraint on `:KNOWS(since, how)`:

.Query
[source, cypher, role=test-fail]
----
MATCH (jensen:Actor {firstname: 'Jensen', surname: 'Ackles'}), (misha:Actor {firstname: 'Misha', surname: 'Collins'})
CREATE (misha)-[:KNOWS {how: 'coworkers'}]->(jensen)
----

In this case, the relationship is not created because it is missing the `since` property which is in conflict with an existing constraint.

.Error message
[source, error]
----
Relationship(0) already exists with type `KNOWS` and property `how` = 'coworkers'
----

======

[discrete]
[[removing-a-key-constrained-property]]
=== Removing key-constrained properties will fail

.Remove a node key-constrained property
======

Remove the `firstname` property from an existing node `Actor`, given a `NODE KEY` constraint on `:Actor(firstname, surname)`:

.Query
[source, cypher, role=test-fail]
----
MATCH (actor:Actor {firstname: 'Keanu', surname: 'Reeves'}) 
REMOVE actor.firstname
----

In this case, the property is not removed because it is in conflict with an existing constraint.

.Error message
[source, error]
----
Node(0) with label `Actor` must have the properties (`firstname`, `surname`)
----

======

.Remove a relationship key-constrained property
======

Remove the `since` property from an existing relationship `KNOWS`, given a `RELATIONSHIP KEY` constraint on `:KNOWS(since, how)`:

.Query
[source, cypher, role=test-fail]
----
MATCH ()-[knows:KNOWS {since: 2008, how: 'coworkers'}]->() REMOVE knows.since
----

In this case, the property is not removed because it is in conflict with an existing constraint.

.Error message
[source, error]
----
Relationship(0) with type `KNOWS` must have the properties (`since`, `how`)
----

======

[discrete]
[[fail-to-create-a-key-constraint-due-to-existing-data]]
=== Creating constraints when there exists conflicting data will fail

.Create a node key constraint when conflicting nodes exist
======

Create a node key constraint on the property `born` on nodes with the `Actor` label, when a node without a `born` property already exists in the graph:

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT actor_born FOR (actor:Actor) REQUIRE (actor.born) IS NODE KEY
----

In this case, the node key constraint cannot be created because it is in conflict with the existing graph.
Either use xref:indexes/search-performance-indexes/managing-indexes.adoc[] instead, or remove/correct the offending nodes and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( type='NODE KEY', schema=(:Actor {born}) ):
Node(0) with label `Actor` must have the property `born`
----

The constraint creation fails on the first offending nodes that are found.
This does not guarantee that there are no other offending nodes in the graph.
Therefore, all the data should be checked and cleaned up before re-attempting the constraint creation.

This is an example `MATCH` query to find all offending nodes for the constraint above:

.Query
[source, cypher]
----
MATCH (actor1:Actor), (actor2:Actor)
WHERE actor1.born = actor2.born AND NOT actor1 = actor2
UNWIND [actor1, actor2] AS actor
RETURN actor, 'non-unique' AS reason

UNION

MATCH (actor:Actor)
WHERE actor.born IS NULL
RETURN actor, 'non-existing' AS reason
----

======


.Create a relationship key constraint when conflicting relationships exist
======

Create a relationship key constraint on the property `level` on relationships with the `KNOWS` relationship type, when two relationships with identical `level` property values already exist in the graph:

////
[source, cypher, role=test-setup]
----
MATCH (jensen:Actor {firstname: 'Jensen', surname: 'Ackles'})-[knows:KNOWS {since: 2008, how: 'coworkers'}]->(:Actor {firstname: 'Misha', surname: 'Collins'})
SET knows.level = 10
CREATE (jensen)-[:KNOWS {since: 2005, how: 'costars', friend: false, level: 10}]->(:Actor {firstname: 'Jared', surname: 'Padalecki'})
----
////

.Query
[source, cypher, role=test-fail]
----
CREATE CONSTRAINT knows_level FOR ()-[knows:KNOWS]-() REQUIRE (knows.level) IS REL KEY
----

In this case, the relationship key constraint cannot be created because it is in conflict with the existing graph.
Either use xref:indexes/search-performance-indexes/managing-indexes.adoc[] instead, or remove or correct the offending relationships and then re-apply the constraint.

.Error message
[source, error]
----
Unable to create Constraint( name='knows_level', type='RELATIONSHIP KEY', schema=()-[:KNOWS {level}]-() ):
Both Relationship(0) and Relationship(1) have the type `KNOWS` and property `level` = 10
----

The constraint creation fails on the first offending relationships that are found.
This does not guarantee that there are no other offending relationships in the graph.
Therefore, all the data should be checked and cleaned up before re-attempting the constraint creation.

This is an example `MATCH` query to find all offending relationships for the constraint above:

.Query
[source, cypher]
----
MATCH ()-[knows1:KNOWS]->(), ()-[knows2:KNOWS]->()
WHERE knows1.level = knows2.level AND NOT knows1 = knows2
UNWIND [knows1, knows2] AS knows
RETURN knows, 'non-unique' AS reason
UNION
MATCH ()-[knows:KNOWS]->()
WHERE knows.level IS NULL
RETURN knows, 'non-existing' AS reason
----
======
