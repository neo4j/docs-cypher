[[expressions-subquery]]
= Subquery expressions

Cypher includes three different types of subquery expressions:

* xref:expressions/subquery.adoc#existential[Existential subquery expressions]
* xref:expressions/subquery.adoc#count[Count subquery expressions]
* xref:expressions/subquery.adoc#collect[Collect subquery expressions] label:new[Introduced in 5.6]

Subquery expressions can appear anywhere that an expression is valid.
A subquery has a scope, as indicated by the opening and closing braces, `{` and `}`.
Any variable that is defined in the outside scope can be referenced inside the subquery's own scope.
Variables introduced inside the subquery are not part of the outside scope and therefore can't be accessed on the outside.

[[expressions-subquery-example]]

== Example graph
The following graph is used for the examples below:

////
[source, cypher, role=test-setup]
----
MATCH (n:A|B|C|D|E) DETACH DELETE n;
CREATE
(andy:Swedish:Person {name: 'Andy', age: 36}),
(timothy:Person {name: 'Timothy', nickname: 'Tim', age: 25}),
(peter:Person {name: 'Peter', nickname: 'Pete', age: 35}),
(andy)-[:HAS_DOG {since: 2016}]->(:Dog {name:'Andy'}),
(timothy)-[:HAS_CAT {since: 2019}]->(:Cat {name:'Mittens'}),
(fido:Dog {name:'Fido'})<-[:HAS_DOG {since: 2010}]-(peter)-[:HAS_DOG {since: 2018}]->(:Dog {name:'Ozzy'}),
(fido)-[:HAS_TOY]->(:Toy{name:'Banana'})
----
////

image:graph_expression_subqueries.svg[]

[[existential]]
== `EXISTS` subqueries

An `EXISTS` subquery can be used to find out if a specified pattern exists at least once in the data.
It serves the same purpose as a xref::clauses/where.adoc#filter-on-patterns[path pattern] but is more powerful because it allows you to use `MATCH` and `WHERE` clauses internally.
Moreover, it can appear in any expression position, unlike path patterns.
If the subquery evaluates to at least one row, the whole expression will become `true`.
This also means that the system only needs to evaluate if there is at least one row and can skip the rest of the work.

Any non-writing query is allowed. `EXISTS` subqueries differ from regular queries in that the final `RETURN` clause may be omitted,
as any variable defined within the subquery will not be available outside of the expression, even if a final `RETURN` clause is used.

It is worth noting that the `MATCH` keyword can be omitted in subqueries in cases where the `EXISTS` consists of only
a pattern and an optional `WHERE` clause.

[[existential-simple]]
=== Simple `EXISTS` subquery

Variables introduced by the outside scope can be used in the `EXISTS` subquery without importing them.
In this regard, `EXISTS` subqueries are different from `CALL` subqueries, xref::clauses/call-subquery.adoc#subquery-correlated-importing[which do require importing].
The following example shows this:


[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
    (person)-[:HAS_DOG]->(:Dog)
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
| +"Peter"+
1+d|Rows: 2
|===

[[existential-where]]
=== `EXISTS` subquery with `WHERE` clause

A `WHERE` clause can be used in conjunction to the `MATCH`.
Variables introduced by the `MATCH` clause and the outside scope can be used in this scope.

[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===


[[existential-nesting]]
=== Nesting `EXISTS` subqueries

`EXISTS` subqueries can be nested like the following example shows.
The nesting also affects the scopes.
That means that it is possible to access all variables from inside the subquery which are either from the outside scope or defined in the very same subquery.


[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  MATCH (person)-[:HAS_DOG]->(dog:Dog)
  WHERE EXISTS {
    MATCH (dog)-[:HAS_TOY]->(toy:Toy)
    WHERE toy.name = 'Banana'
  }
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===

[[existential-outside-where]]
=== `EXISTS` subquery outside of a `WHERE` clause

`EXISTS` subquery expressions can appear anywhere that an expression is valid.
Here the result is a boolean that shows whether the subquery can find the given pattern.


[source, cypher]
----
MATCH (person:Person)
RETURN person.name AS name, EXISTS {
  MATCH (person)-[:HAS_DOG]->(:Dog)
} AS hasDog
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+ | +hasDog+
| +"Andy"+ | +true+
| +"Timothy"+ | +false+
| +"Peter"+ | +true+
2+d|Rows: 3
|===


[[existential-union]]
=== `EXISTS` subquery with a `UNION`

_This feature was introduced in Neo4j 5.3._

`Exists` can be used with a `UNION` clause, and the `RETURN` clauses are not required.
It is worth noting that if one branch has a `RETURN` clause, then all branches require one.
The below example demonstrates that if one of the `UNION` branches was to return at least one row, the entire `EXISTS` expression will evaluate to true.

[source, cypher]
----
MATCH (person:Person)
RETURN
    person.name AS name,
    EXISTS {
        MATCH (person)-[:HAS_DOG]->(:Dog)
        UNION
        MATCH (person)-[:HAS_CAT]->(:Cat)
    } AS hasPet
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +hasPet+
| +"Andy"+      | +true+
| +"Timothy"+   | +true+
| +"Peter"+     | +true+
2+d|Rows: 3
|===


[[existential-with]]
=== `EXISTS` subquery with `WITH`

_This feature was introduced in Neo4j 5.3._

Variables from the outside scope are visible for the entire subquery, even when using a `WITH` clause.
To avoid confusion, shadowing of these variables is not allowed.
An outside scope variable is shadowed when a newly introduced variable within the inner scope is defined with the same variable.
In the example below, the outer variable `name` is shadowed and will therefore throw an error.

[source, cypher, role=test-fail]
----
WITH 'Peter' as name
MATCH (person:Person {name: name})
WHERE EXISTS {
    WITH "Ozzy" AS name
    MATCH (person)-[:HAS_DOG]->(d:Dog)
    WHERE d.name = name
}
RETURN person.name AS name
----

.Error message
[source, output, role="noheader"]
----
The variable `name` is shadowing a variable with the same name from the outer scope and needs to be renamed (line 4, column 20 (offset: 90))
----

New variables can be introduced into the subquery, as long as they use a different identifier.
In the example below, a `WITH` clause introduces a new variable.
Note that the outer scope variable `person` referenced in the main query is still available after the `WITH` clause.

[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
    WITH "Ozzy" AS dogName
    MATCH (person)-[:HAS_DOG]->(d:Dog)
    WHERE d.name = dogName
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===


[[existential-return]]
=== `EXISTS` subquery with `RETURN`

_This feature was introduced in Neo4j 5.3._

`EXISTS` subqueries do not require a `RETURN` clause at the end of the subquery. If one is present, it does not
need to be aliased, which is different compared to xref::clauses/call-subquery.adoc[`CALL` subqueries].
Any variables returned in an `EXISTS` subquery will not be available after the subquery.

[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
    MATCH (person)-[:HAS_DOG]->(:Dog)
    RETURN person.name
}
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
| +"Peter"+
1+d|Rows: 2
|===


[[count]]
== `COUNT` subqueries

A `COUNT` subquery expression can be used to count the number of rows returned by the subquery.

Any non-writing query is allowed. `COUNT` subqueries differ from regular queries in that the final `RETURN` clause may be omitted,
as any variable defined within the subquery will not be available outside of the expression,
even if a final `RETURN` clause is used. One exception to this is that for a `DISTINCT UNION` clause, the `RETURN` clause is still mandatory.

It is worth noting that the `MATCH` keyword can be omitted in subqueries in cases where the `COUNT` consists of only a pattern and an optional `WHERE` clause.

[[count-simple]]
=== Simple `COUNT` subquery

Variables introduced by the outside scope can be used in the `COUNT` subquery without importing them.
In this regard, `COUNT` subqueries are different from `CALL` subqueries, xref::clauses/call-subquery.adoc#subquery-correlated-importing[which do require importing].
The following query exemplifies this and outputs the owners of more than one dog:


[source, cypher]
----
MATCH (person:Person)
WHERE COUNT { (person)-[:HAS_DOG]->(:Dog) } > 1
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===


[[count-where]]
=== `COUNT` subquery with `WHERE` clause

A `WHERE` clause can be used inside the `COUNT` pattern.
Variables introduced by the `MATCH` clause and the outside scope can be used in this scope.


[source, cypher]
----
MATCH (person:Person)
WHERE COUNT {
  (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
} = 1
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===

[[count-union]]
=== `COUNT` subquery with a `UNION`

_This feature was introduced in Neo4j 5.3._

`COUNT` can be used with a `UNION` clause. If the `UNION` clause is distinct, the `RETURN` clause is required.
`UNION ALL` clauses do not require the `RETURN` clause. However, it is worth noting that if one branch has a `RETURN` clause, then all require one.
The below example shows the count of pets each person has by using a `UNION` clause:

[source, cypher]
----
MATCH (person:Person)
RETURN
    person.name AS name,
    COUNT {
        MATCH (person)-[:HAS_DOG]->(dog:Dog)
        RETURN dog.name AS petName
        UNION
        MATCH (person)-[:HAS_CAT]->(cat:Cat)
        RETURN cat.name AS petName
    } AS numPets
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +numPets+
| +"Andy"+      | +1+
| +"Timothy"+   | +1+
| +"Peter"+     | +2+
2+d|Rows: 3
|===


[[count-with]]
=== `COUNT` subquery with `WITH`

_This feature was introduced in Neo4j 5.3._

Variables from the outside scope are visible for the entire subquery, even when using a `WITH` clause.
To avoid confusion, shadowing of these variables is not allowed.
An outside scope variable is shadowed when a newly introduced variable within the inner scope is defined with the same variable.
In the example below, the outer variable `name` is shadowed and will therefore throw an error.

[source, cypher, role=test-fail]
----
WITH 'Peter' as name
MATCH (person:Person {name: name})
WHERE COUNT {
    WITH "Ozzy" AS name
    MATCH (person)-[:HAS_DOG]->(d:Dog)
    WHERE d.name = name
} = 1
RETURN person.name AS name
----

.Error message
[source, output, role="noheader"]
----
The variable `name` is shadowing a variable with the same name from the outer scope and needs to be renamed (line 4, column 20 (offset: 90))
----

New variables can be introduced into the subquery, as long as they use a different identifier.
In the example below, a `WITH` clause introduces a new variable.
Note that the outer scope variable `person` referenced in the main query is still available after the `WITH` clause.

[source, cypher]
----
MATCH (person:Person)
WHERE COUNT {
    WITH "Ozzy" AS dogName
    MATCH (person)-[:HAS_DOG]->(d:Dog)
    WHERE d.name = dogName
} = 1
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===


[[count-inside-clauses]]
=== Using `COUNT` subqueries inside other clauses

`COUNT` can be used in any position in a query, with the exception of administration commands, where it is restricted.
See a few examples below:

[[count-subqueries-with-return]]
==== Using `COUNT` in `RETURN`


[source, cypher]
----
MATCH (person:Person)
RETURN person.name, COUNT { (person)-[:HAS_DOG]->(:Dog) } as howManyDogs

----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +howManyDogs+
| +"Andy"+ | +1+
| +"Timothy"+ | +0+
| +"Peter"+ | +2+
2+d|Rows: 3
|===


[[count-set]]
==== Using `COUNT` in `SET`


[source, cypher]
----
MATCH (person:Person) WHERE person.name ="Andy"
SET person.howManyDogs = COUNT { (person)-[:HAS_DOG]->(:Dog) }
RETURN person.howManyDogs as howManyDogs

----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +howManyDogs+
| +1+
1+d|Rows: 1 +
Properties set: 1
|===


[[count-case]]
==== Using `COUNT` in `CASE`

[source, cypher]
----
MATCH (person:Person)
RETURN
   CASE
     WHEN COUNT { (person)-[:HAS_DOG]->(:Dog) } > 1 THEN "Doglover " + person.name
     ELSE person.name
   END AS result

----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +"Andy"+
| +"Timothy"+
| +"Doglover Peter"+
1+d|Rows: 3
|===


[[count-grouping-key]]
==== Using `COUNT` as a grouping key

The following query groups all persons by how many dogs they own,
and then calculates the average age for each group.


[source, cypher]
----
MATCH (person:Person)
RETURN COUNT { (person)-[:HAS_DOG]->(:Dog) } AS numDogs,
       avg(person.age) AS averageAge
 ORDER BY numDogs

----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +numDogs+ | +averageAge+
| +0+ | +25.0+
| +1+ | +36.0+
| +2+ | +35.0+
2+d|Rows: 3
|===


[[count-return]]
==== `COUNT` subquery with `RETURN`

_This feature was introduced in Neo4j 5.3._

`COUNT` subqueries do not require a `RETURN` clause at the end of the subquery. If one is present, it does not need to be aliased.
This is a difference compared to from xref::clauses/call-subquery.adoc[`CALL` subqueries].
Any variables returned in a `COUNT` subquery will not be available after the subquery.

[source, cypher]
----
MATCH (person:Person)
WHERE COUNT {
    MATCH (person)-[:HAS_DOG]->(:Dog)
    RETURN person.name
} = 1
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Andy"+
1+d|Rows: 1
|===


[[collect]]
== `COLLECT` subqueries

_This feature was introduced in Neo4j 5.6._

A `COLLECT` subquery expression can be used to create a list with the rows returned by a given subquery.

Any non-writing query is allowed.
`COLLECT` subqueries differ from `COUNT` and `EXISTS` subqueries in that the final `RETURN` clause is mandatory.
The `RETURN` clause must return exactly one column.

[[collect-simple]]
=== Simple `COLLECT` subquery

Variables introduced by the outside scope can be used in the `COLLECT` subquery without importing them.
In this regard, `COLLECT` subqueries are different from `CALL` subqueries, xref::clauses/call-subquery.adoc#subquery-correlated-importing[which do require importing].
The following query exemplifies this and outputs the owners of the dog named `Ozzy`:

[source, cypher]
----
MATCH (person:Person)
WHERE 'Ozzy' IN COLLECT { MATCH (person)-[:HAS_DOG]->(dog:Dog) RETURN dog.name }
RETURN person.name AS name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +"Peter"+
1+d|Rows: 1
|===


[[collect-where]]
=== `COLLECT` subquery with `WHERE` clause

A `WHERE` clause can be used inside the `COLLECT` pattern.
Variables introduced by the `MATCH` clause and the outside scope can be used in the inner scope.

[source, cypher]
----
MATCH (person:Person)
RETURN person.name as name, COLLECT {
  MATCH (person)-[r:HAS_DOG]->(dog:Dog)
  WHERE r.since > 2017
  RETURN dog.name
} as youngDogs
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +youngDogs+
| +"Andy"+      | +[]+
| +"Timothy"+   | +[]+
| +"Peter"+     | +["Ozzy"]+
2+d|Rows: 3
|===


[[collect-union]]
=== `COLLECT` subquery with a `UNION`

`COLLECT` can be used with a `UNION` clause.
The below example shows the collection of pet names each person has by using a `UNION` clause:

[source, cypher]
----
MATCH (person:Person)
RETURN
    person.name AS name,
    COLLECT {
        MATCH (person)-[:HAS_DOG]->(dog:Dog)
        RETURN dog.name AS petName
        UNION
        MATCH (person)-[:HAS_CAT]->(cat:Cat)
        RETURN cat.name AS petName
    } AS petNames
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +petNames+
| +"Andy"+      | +["Andy"]+
| +"Timothy"+   | +["Mittens"]+
| +"Peter"+     | +["Ozzy", "Fido"]+
2+d|Rows: 3
|===


[[collect-with]]
==== `COLLECT` subquery with `WITH`

Variables from the outside scope are visible for the entire subquery, even when using a `WITH` clause.
To avoid confusion, shadowing of these variables is not allowed.
An outside scope variable is shadowed when a newly introduced variable within the inner scope is defined with the same variable.
In the example below, the outer variable `name` is shadowed and will therefore throw an error.

[source, cypher, role=test-fail]
----
WITH 'Peter' as name
MATCH (person:Person {name: name})
RETURN COLLECT {
    WITH 'Ozzy' AS name
    MATCH (person)-[r:HAS_DOG]->(d:Dog {name: name})
    RETURN d.name
} as dogsOfTheYear
----

.Error message
[source, output, role="noheader"]
----
The variable `name` is shadowing a variable with the same name from the outer scope and needs to be renamed (line 4, column 20 (offset: 92))
----

New variables can be introduced into the subquery, as long as they use a different identifier.
In the example below, a `WITH` clause introduces a new variable.
Note that the outer scope variable `person` referenced in the main query is still available after the `WITH` clause.

[source, cypher]
----
MATCH (person:Person)
RETURN person.name AS name, COLLECT {
    WITH 2018 AS yearOfTheDog
    MATCH (person)-[r:HAS_DOG]->(d:Dog)
    WHERE r.since = yearOfTheDog
    RETURN d.name
} as dogsOfTheYear
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +name+        | +dogsOfTheYear+
| +"Andy"+      | +[]+
| +"Timothy"+   | +[]+
| +"Peter"+     | +["Ozzy"]+
2+d|Rows: 3
|===


[[collect-inside-clauses]]
=== Using `COLLECT` subqueries inside other clauses

`COLLECT` can be used in any position in a query, with the exception of administration commands, where the `COLLECT` expression is restricted.
See a few examples below of how `COLLECT` can be used in different positions within a query:


[[collect-return]]
==== Using `COLLECT` in `RETURN`

[source, cypher]
----
MATCH (person:Person)
RETURN person.name,
       COLLECT {
            MATCH (person)-[:HAS_DOG]->(d:Dog)
            MATCH (d)-[:HAS_TOY]->(t:Toy)
            RETURN t.name
       } as toyNames
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +person.name+ | +toyNames+
| +"Andy"+      | +[]+
| +"Timothy"+   | +[]+
| +"Peter"+     | +["Banana"]+
2+d|Rows: 3
|===


[[collect-set]]
==== Using `COLLECT` in `SET`

[source, cypher]
----
MATCH (person:Person) WHERE person.name = "Peter"
SET person.dogNames = COLLECT { MATCH (person)-[:HAS_DOG]->(d:Dog) RETURN d.name }
RETURN person.dogNames as dogNames
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +dogNames+
| +["Ozzy", "Fido"]+
1+d|Rows: 1 +
Properties set: 1
|===


[[collect-case]]
==== Using `COLLECT` in `CASE`

[source, cypher]
----
MATCH (person:Person)
RETURN
   CASE
     WHEN COLLECT { MATCH (person)-[:HAS_DOG]->(d:Dog) RETURN d.name } = []  THEN "No Dogs " + person.name
     ELSE person.name
   END AS result
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +"Andy"+
| +"No Dogs Timothy"+
| +"Peter"+
1+d|Rows: 3
|===


[[collect-grouping-key]]
==== Using `COLLECT` as a grouping key

The following query collects all persons by their dogs' names,
and then calculates the average age for each group.

[source, cypher]
----
MATCH (person:Person)
RETURN COLLECT { MATCH (person)-[:HAS_DOG]->(d:Dog) RETURN d.name } AS dogNames,
       avg(person.age) AS averageAge
 ORDER BY dogNames
----

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +dogNames+         | +averageAge+
| +[]+               | +25.0+
| +["Andy"]+         | +36.0+
| +["Ozzy", "Fido"]+ | +35.0+
2+d|Rows: 3
|===


[[collect-differentiation]]
==== Using `COLLECT` vs `collect()`

`COLLECT` does not handle `null` values in the same way that function `collect()` does.
The `collect()` function automatically removes `null` values.
`COLLECT` will not remove `null` values automatically.
However, they can be removed by adding a filtering step in the subquery.

The following queries illustrate these differences:

[source, cypher]
----
MATCH (p:Person)
RETURN collect(p.nickname) AS names
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +names+
| +["Pete", "Tim"]+
1+d|Rows: 1
|===

[source, cypher]
----
RETURN COLLECT {
        MATCH (p:Person)
        RETURN p.nickname ORDER BY p.nickname
      } AS names
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +names+
| +["Pete", "Tim", null]+
1+d|Rows: 1
|===

[source, cypher]
----
RETURN COLLECT {
        MATCH (p:Person)
        WHERE p.nickname IS NOT NULL
        RETURN p.nickname ORDER BY p.nickname
      } AS names
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +name+
| +["Pete", "Tim"]+
1+d|Rows: 1
|===